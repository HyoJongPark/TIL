# 완전 탐색

다음 블로그들을 참고해 작성함.

겐지충 프로그래머님 블로그 : [https://hongjw1938.tistory.com/category/자바 프로그래밍/알고리즘(Algorithm)](https://hongjw1938.tistory.com/category/%EC%9E%90%EB%B0%94%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%28Algorithm%29)

뱀귤님  : [https://bcp0109.tistory.com/14](https://bcp0109.tistory.com/14)

---

완전탐색은 간단히 가능한 모든 경우의 수를 다 체크해서 정답을 찾는 방법, 즉 가능한 방법을 전부 만들어 보는 알고리즘을 뜻한다.(무식하게 다 해보는 것)

이 방법을 무식하게 한다는 의미로 “Brute Force”라고도 하며, 직관적이고 이해하기 쉽고 문제의 정확한 결과 값을 얻어낼 수 있는 확실하며 기초적 방법이다. 또한 컴퓨터의 빠른 계산 속도를 잘 이용하는 방법이다.

다만 Computer Sience에서는 문제 해결 알고리즘을 사할 때, 기본적으로 2가지 규칙을 적용한다.

1. 사용된 알고리즘이 적절한가?(문제를 해결할 수 있는가)
2. 효율적으로 동작하는가?

이 중 2번 문항으로 인해 이 방법이 사용되는데는 제한이 따른다.

## 완전탐색 기법을 활용하는 방법

완전탐색 기법으로 문제를 해결하기 위해서는 다음과 같이 고려해서 수행한다.

1. 해결하고자 하는 문제의 경우의 수를 대략적으로 계산
2. 가능한 모든 방법 고려
    1. Brute Force 기법 : 반복/조건문을 활용해 모두 테스트하는 방법
    2. 순열(Permutation) : n개의 원소 중 r개의 원소를 중복 허용 없이 나열하는 방법
    3. 재귀 호출
    4. 비트마스크 : 2진수 표현 기법을 활용하는 방법
    5. BFS, DFS를 활용하는 방법
3. 실제 답을 구할 수 있는지 적용

## 1. Brute Force 기법

이 방법은 반복/조건문을 통해 가능한 모든 방법을 단순히 찾는 경우를 의미.

## 2. 순열(Permutation)

순열은 임의의 수열이 있을 때, 그것을 다른 순서로 연산하는 방법을 의미한다.

즉, 순서가 중요하다. 만약 수열에서 숫자 (1,2,3)이 있다면, 이것을 (1,2,3)으로 보는 것과 (3,2,1)로 보는 순서가 차이가 있음이 중요한 경우를 의미한다.

같은 데이터가 입력된 수열이지만, 그 순서에 따라 의미가 있고 이 순서를 통해 연결되는 이전/다음 수열을 찾아낼 수 있는 경우를 계산할 수 있다.

만약 N개의 서로 다른 데이터가 있고 이를 순열로 나태낸다면, 전체 순열의 가지수는 **N!** 개가 된다.

(1,2,3)을 사전 순으로 나열하는 순열이 있다고 가정하자.

![Untitled](https://user-images.githubusercontent.com/75190035/154903089-89a74ab4-87ff-4e56-816d-d258a4083f56.png)

위 내용과 같이 순열을 나열할 수 있는데, 최초/최종 순열을 확인해보면 숫자가 오름/내림 차순인 것을 알 수 있다.(중복된 수가 있다면 비내림/비오름차순으로 된다.)

여기서 사전 순 순열의 규칙을 알아낼 수 있는데 **N개의 데이터가 있고 1~i번째 데이터를 설정했을 때, i번째 데이터 기준 최종 순열은 i+1 부터 N 까지가 모두 내림차순 이라는 것이다.(반대로 최초 순열이면 i+1부터 N이 오름차순)**

**로직**

```java
※ 순열을 구현하는 방법

현재 순열을 구성하는 배열을 A라고 하고 i,j는 그 배열의 index 값을 의미한다고 하자. 예를 들어 A={7, 2, 3, 6, 5, 4, 1}이고 i, j는 각각의 index 값이다.

아래에서는 현재의 다음 순열을 구하는 로직을 기반으로 설명한다.

1. A[i-1] <= A[i]를 만족하는 i 중 가장 큰 값을 찾는다.(혹은 뒤에서부터 찾는 경우 A[i-1] >= A[i] 중 가장 작은 i를 찾는다.)
  → 현재 i값을 기준으로 이후는 모두 내림차순으로 되는 경우를 찾는 다는 것이다. 현재 기준 최종 순열을 찾음
      A배열을 보면 A[i-1] < A[i]가 되는 가장 큰 i는 6인 3번째(0부터 시작)이다. 즉, i=3이 된다.

2. j >= i 중, A[j] > A[i-1]을 만족하는 가장 큰 j의 값을 찾는다.
  → 현재가 최종 순열 상태이므로 i-1번째 숫자를 변경하여 최초 순열을 찾아야 한다.
      A배열을 기준으로 i-1번째 숫자는 3으로 3보다 큰 경우는 6, 5, 4이나 그 중 j 값이 가장 큰 경우는 4이다.

3. A[i-1]과 A[j]를 Swap한다.
   → i-1인 2번째 숫자 3과 j인 5번째 숫자 4를 변경한다. A 배열은 다음과 같이 변경된다.
      A={7, 2, 4, 6, 5, 3, 1}

4. i이후의 순열을 모두 뒤집는다.
   → 최초 순열 상태로 만들어야 하므로 i번째부터는 오름차순으로 만들어야 한다. A 배열은 다음과 같이 변경된다.
      A={7, 2, 4, 1, 3, 5, 6}
```

위 로직은 전체 N개의 숫자에 대해 각각 순열을 구하는 문제가 된다.

제일 좌측에 N개의 숫자가 올 수 있고, (N-1)!개의 순열이 있기 때문에 시간복잡도는 O(N*(N-1)!) → O(N!)이 된다.

- 백준 - 차이를 최대로 문제(10819)를  구현

```java
import java.util.Arrays;
import java.util.Scanner;

public class Main{

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        int[] numbers = new int[N];
        for (int i = 0; i < N; i++) {
            numbers[i] = sc.nextInt();
        }
        sc.close();

        Arrays.sort(numbers);
        int answer = 0;
        int result = 0;

        while (permutation(numbers)) {
            for (int i = 1; i < N; i++) {
                result = result + Math.abs(numbers[i-1] - numbers[i]);
            }
            if (answer < result) {
                answer = result;
            }
            result = 0;
        }
        System.out.println(answer);
    }

    static boolean permutation(int[] numbers) {
        int i = numbers.length -1;

        while (i > 0 && numbers[i - 1] >= numbers[i]) i--;

        //최종 순열일 경우
        if (i<=0) return false;

        int j = i - 1;
        while (j < numbers.length - 1 && numbers[j+1] > numbers[i - 1]) j++;

        swap(numbers, i-1, j);

        j = numbers.length - 1;
        while (i < j) {
            swap(numbers, i, j);
            j--;
            i++;
        }
        return true;
    }

    private static void swap(int[] numbers, int i, int j) {
        int temp = numbers[i];
        numbers[i] = numbers[j];
        numbers[j] = temp;
    }
}
```

## 3. 재귀(Recursive)

재귀는 자기 자신을 호출한다는 의미이다. 

재귀 함수를 활용한다면, 주의할 점이 있다.

1. 재귀를 탈출하기 위한 조건이 필요
    - 이 조건이 없으면, 숫자를 저장하는 배열에 범위 초과오류, 무한 루프 등이 발생할 수 있다.
2. 현재 함수의 상태를 저장하는 Parameter가 필요
    - 이 조건이 없으면, 현재 함수의 상태를 전달할 수 없어 재귀 탈출 조건을 만들 수 없게 되거나 잘못된 결과를 출력할 수 있다.
3. return문을 신경써야함

**로직**

```java
public class Main{
    static int lim = 100; // 1~100까지의 제한
    static int n = 5; // 5개만 고른다.
    public static void main(String[] args){
        int[] chosen = new int[n]; // 선택된 숫자가 저장되는 배열
        
        // 시작은 0부터 시작하며 0개를 현재 선택했으니 아래와 같이 parameter 전달!
        solve(chosen, 0, 0);
    }
    
    // chosen은 선택된 숫자가 저장된 배열
    // curr은 현재 숫자를 선택하는 index
    // cnt는 몇 개의 숫자가 선택되었는지 확인
    private static void solve(int[] chosen, int curr, int cnt){
    
        // n개의 숫자를 다 선택했다면 출력 후 더 이상 재귀를 돌지 않아야 한다!
        // 탈출 조건의 정의!
        if(cnt == n){
            for(int i : chosen){
                System.out.print(i + " ");
            }
            System.out.println();
            return;
        }
        
        // 반복문을 통해 숫자를 계속 선택!
        for(int i=curr+1; i <= lim; i++){
            // 현재 선택된 숫자를 저장
            chosen[cnt] = i;
            
            // 다음 숫자를 선택하기 위해 재귀 호출
            solve(chosen, curr, cnt+1);
        }
    }
}
```

## 4. 비트마스크(Bitmask)

비트마스크란 비트연산을 통해서 부분 집합을 표현하는 방법을 의미한다.

비트마스크는 보통 처리할 전체 데이터가 정해져 있고, 그 안에서 특정 개수를 가지고 연산을 수행할 때 사용한다.

- AND 연산
- OR    연산
- NOT 연산
- XOR 연산
- Shift 연산 : A<<B 라고 한다면 A를 좌측으로 B 비트만큼 미는 것

| A | B | A&B | A\|B | ~A | A^B |
| --- | --- | --- | --- | --- | --- |
| 0 | 0 | 0 | 0 | 1 | 0 |
| 0 | 1 | 0 | 1 | 1 | 1 |
| 1 | 0 | 0 | 1 | 0 | 1 |
| 1 | 1 | 1 | 1 | 0 | 0 |

비트연산의 시간복잡도는 내부적으로 상수 시간 정도로 처리되어 O(1)이라고 보면 된다.

**NOT 연산 주의점**

대부분의 프로그래밍에서 숫자들을 저장할 수 있는 자료형은 1가지가 아니다. 

Java의 경우는 byte, short, int, long 형으로 정수의 형태를 저장할 수 있는데 각각은 8비트, 16비트, 32비트, 64비트로 저장할 수 있는 비트의 수가 다르고 이 때문에 같은 수를 NOT연산 시켰을 때 다른 결과가 출력될 수 있다.

- `byte b = 40` 의 NOT 연산 2진수 출력: 11010111
- `Short s = 40` 의 NOT 연산 2진수 출력: 1111111111010111

**Shift 연산**

A는 10, B는 2라고 가정하면, `A << B` 는 1010(2) 를 왼쪽으로 2칸씩 미는 것으로 이해하면 된다. 따라서 101000(2) == 40 이 된다.

`A >> B` 는 1010(2)를 오른쪽으로 2칸 미는 것으로 10(2) == 2 가 된다.

- `A << B` = `A * 2^B`
- `A >> B` = `A / 2^B`
- `(A+B)/2` = `(A+B) >> 1`

### 비트 연산으로 집합을 나타내는 법

비트마스크는 정수로 집합을 나타내는 것이 가능하다. 만약, 0~9까지의 숫자로만 이루어지는 정수 집합이 있다고 할 때, 집합 A={1,3,4,5,9} 를 하나의 숫자로 나타낼수 있다. → A = 570 = 1000111010(2)

| 숫자 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 비트  | 1 | 0 | 0 | 0 | 1 | 1 | 1 | 0 | 1 | 0 |

단순히 2진수를 해당 자릿수의 정수와 매칭 시킨다고 생각하면 편하다. 이렇게 정수로 사용하게 되면 전체 저장공간 또한 절약되고 정수이기 때문에 index로 활용할 수 있다.

비트마스크로 집합을 나타낼 때는 0~N-1까지 정수로 이루어진 집합을 나타낼 때 사용된다. (1~N 까지로 하면 전체 공간이 2배가 된다. 따라서 0~N-1까지로 활용)

1. **집합 포함 여부 검사**

0~9까지의 숫자 중 해당 숫자가 현재 집합에 포함되어 있는지를 알아보는 방법.

0이 포함된 여부를 검사하려면 0번째 비트만 1로 만들고 나머지를 0으로 한것과 570의 2진수를 `AND연산` 하면, 포함여부를 알 수 있다.

1. **숫자 추가하기**

특정 숫자를 추가하기 위해서는 해당 위치의 비트를 1로 만들어야 한다. 이를 위해서 `OR 연산` 을 사용한다.

추가하고자 하는 위치의 비트만 1로 만들고 나머지는 0으로 된 비트와 연산 시, 추가하고자 하는 위치가 1로 변경될 것이다.

1. **특정 숫자 제거하기**

특정 숫자 제거를 위해서 `NOT 연산` , `AND 연산` 을 함께 사용한다.

NOT 연산으로는 제거하고자 하는 위치의 비트만 0으로 하고, 이후 AND 연산을 하면 특정 위치만 0으로 바뀌고 나머지는 그대로 남게된다.

1. **토글 연산**

0이면 1로, 1이면 0으로 바꾸고자하는 연산을 할 때는 `XOR 연산` 을 사용한다.

**5. 전체 집합, 공집합 표현**

전체 집합은 모든 숫자가 1인 것으로, `(1<<N) - 1` 로 표현할 수 있다.

공집합은 모든 수가 0인 것으로 표현하면 끝이다.

```java
public class Main{
  static int[] set = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
  public static void main(String[] args){
	  // 1.현재 부분 집합에 1이 포함되었는지 검사
    // 570 & 2^1 이므로 570 & (1 << 1) = 2이라면 있는 것, 0이면 없는 것
    System.out.println((570 & (1 << 1)); //2

		//2.**숫자 추가하기**
		System.out.println(570 | (1 << 2)); //574

		//3.**특정 숫자 제거하기**
		System.out.println(570 & ~(1 << 4)); //554
    
		//4.토글 연산(1->0)
		System.out.println(570 ^ (1 << 4)); //554

		//5.전체집합
		System.out.println((1<<2) - 1); //3
	}
}
```

## 5. BFS, DFS 사용

그래프 자료 구조에서 모든 정점을 탐색하기 위한 방법들이다.

BFS는 너비 우선 탐색법으로 현재 정점과 인접한 정점을 우선으로 탐색하고, DFS는 깊이 우선 탐색으로 현재 인접한 정점을 탐색 후 그 다음 인접한 정점을 탐색하는 순서로 진행된다.
