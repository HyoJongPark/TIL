# CHAPTER 9 - 메인 메모리

## 1.  배경_Background

메인 메모리는 현대 컴퓨터 시스템의 운영에 중심적인 역할을 한다. 

메모리는 각각 주소가 할당된 일련의 바이트들로 구성된다.

### 1.1 기본 하드웨어_Basic Hardware

<img width="299" alt="Untitled" src="https://user-images.githubusercontent.com/75190035/176337381-a8c5fa01-82bf-4fa4-a7e1-bae4ef195245.png">

- 메인 메모리와 각 처리 코어에 내장된 레지스터들은 CPU가 직접 접근할 수 있는 유일한 범용 저장장치다.
    - 따라서 모든 실행되는 명령어와 데이터들은 CPU가 직접적으로 접근할 수 있는 메인 메모리와 레지스터에 있어야 한다.
    - 데이터가 메모리에 없다면, CPU가 그것들을 처리하기 전에 메모리로 이동시켜야 한다.
- 각 CPU 코어에 내장된 레지스터들은 일반적으로 CPU 클록(clock)의 1 사이클(cycle)내에 접근 가능하다.
- 메모리 버스를 통해 전송되는 메인 메모리는 메인 메모리에 대한 접근을 완료하기 위해서 많은 CPU 클록 틱 사이클이 소요된다.
    - 이 경우 CPU가 필요한 데이터가 없어서 명령어를 수행하지 못하고 지연되는(shell) 현상이 발생하게 된다.
    - CPU와 메인 메모리 사이에 빠른 속도의 메모리(캐시)를 추가해 해결 할 수 있다.
- 시스템이 올바르게 동작하기 위해서는 사용자 프로그램으로부터 운영체제 영역을 보호해야 할 뿐만 아니라 사용자 프로그램 사이도 서로 보호해야한다.
    - 운영체제가 CPU-메모리 간의 접근 중에 개입하게 되면 성능이 떨어지기 때문에 이러한 보호 기법은 하드웨어가 지원해야 한다.
    - 이 보호 기법을 위해 각각의 프로세스가 독립된 메모리 공간을 가지도록 보장해야 한다.
    - 기준 레지스터와 상한 레지스터라는 두 개의 레지스터를 사용해 보호 기법을 제공할 수 있다.
        - 기준 레지스터: 가장 작은 합법적인 물리 메모리 주소 값을 저장
        - 상한 레지스터: 주어진 영역의 크기를 저장
        - 예) 기준(300040), 상한(120900) 이라면, 프로그램은 300040 ~ 420940 까지의 모든 주소를 접근할 수 있다.

<img width="470" alt="Untitled 1" src="https://user-images.githubusercontent.com/75190035/176337390-ad980ac9-674f-42ac-ba45-f013580d0d5d.png">

### 1.2 주소의 할당_Address Binding

- 프로그램은 이진 실행 파일 형태로 디스크에 저장되어 있다. 실행하려면 프로그램을 메모리로 가져와서 프로세스 문맥 내에 배치해야 한다.
- 이 시점에서 가용한 CPU에서 실행할 수 있게 된다.
- 프로세스가 실행되면 메모리에서 명령 및 데이터에 엑세스한다. 이후 프로세스가 종료되고 다른 프로세스에서 사용하기 위해 메모리가 회수된다.
- 대부분의 시스템은 사용자 프로세스가 메모리 내 어느 부분으로도 올라올 수 있도록 지원하고 있다.
- 사용자 프로그램은 여러 단계를 거쳐 실행되기 떄문에 이들 단계를 거치는 동안 여러 가지 다른 표현 방식을 거치게 된다.

<img width="382" alt="Untitled 2" src="https://user-images.githubusercontent.com/75190035/176337397-6e3cb194-b67e-4778-ba6a-7e0286d9275a.png">

- 전통적으로 메모리 주소 공간에서 명령어와 데이터 바인딩은 그 바인딩이 이루어지는 시점에 따라 다음과 같이 구분된다.
    - **컴파일 시간**(compile time) 바인딩: 프로세스가 메모리 내에 들어갈 위치를 컴파일 시간에 미리 알 수 있으면 컴파일러는 **절대 코드**를 생성할 수 있다.
    - **적재 시간**(load time) 바인딩: 프로세스가 메모리 내 어디로 올라오게 될지를 컴파일 시점에 알지 못하면 컴파일러는 일단 **이진 코드를 재배치 가능 코드**로 만들어야 한다.
    - **실행 시간**(execution time) 바인딩: 프로세스가 실행하는 중간에 메모리 내의 한 세그먼트로 부터 다른 세그먼트로 옮겨질 수 있다면 우리는 바인딩이 실행 시간까지 허용되었다고 이야기한다.

### 1.3 논리 대 물리 주소 공간_Logical-Versus Physical-Address Space

<img width="425" alt="Untitled 3" src="https://user-images.githubusercontent.com/75190035/176337402-609eb0ce-25e2-4144-a76b-c1e31c7f90a1.png">

- CPU가 생성하는 주소를 일반적으로 **논리 주소**(logical address)라 하며, 반면에 메모리가 취급하게 되는 주소는 일반적으로 물리 주소(physical address)라 한다.
- 컴파일 또는 적재 시에 주소를 바인딩하면 논리 주소와 물리 주소가 같다.
- 실행 시간 바인딩 기법에서는 두 주소가 다른데 이때, 논리 주소를 **가상 주소**(virtual address)라 한다.
- 프로그램에 의해 생성된 모든 논리 주소 집합을 **논리 주소 공간**이라 하며, 이 논리 주소와 일치하는 모든 물리 주소 집합을 **물리 주소 공간**이라 한다.
- 프로그램 실행 중에는 이와 같은 가상 주소를 물리 주소로 바꿔줘야 하는데 이 변환 작업은 하드웨어 장치인 **메모리 관리 장치**(memory management unit, **MMU**)에 의해 실행된다.
    - 만약 재배치 레지스터(relocation register)가 14000 이라면, 논리 주소 346 번지에 엑세스할 때, 실제는 메인 메모리의 14346번지에 엑세스 하게 된다.

### 1.4 동적 적재_Dynamic Loading

- 지금까지는 프로세스가 실행되기 위해 그 프로세스 전체가 미리 메모리에 올라와 있어야 했다. 이 경우 프로세스의 크기는 모모리의 크기보다 커서는 안된다.
- 메모리 공간을 더 효율적으로 이용하기 위해서 **동적 적재(dynamic loading)**를 해야 한다**.**
- 동적 적재의 장점은 루틴/데이터가 필요한 경우에만 적재된다는 것이다.
- 이러한 구조는 오류 처리 루틴과 같이 아주 간혹 발생하면서도 실행할 코드가 많은 경우에 특히 유용하다.

### 1.5 동적 연결 및 공유 라이브러리_Dynamic Linking & Shared Libraries

- 공통 라이브러리 루틴을 메모리에 중복으로 올리는 것은 낭비다.
- **동적 연결 라이브러리(DLL)**는 사용자 프로그램이 실행될 때, 사용자 프로그램에 연결되는 시스템 라이브러리다.
- 동적 연결에서는 연결이 실행 시기까지 미루어지고, 라이브러리를 여러 프로세스간에 공유할 수 있어 메인 메모리에 DLL 인스턴스가 하나만 있을 수 있다.

---

> 참고
> 
> - 책
> 
> [⌜Operating System Concepts 10th - Abraham Silberschatz, Peter B. Galvin, Greg Gagne⌟](http://www.yes24.com/Product/Goods/78225791)
> 
> - 블로그
> 
> [https://will-behappy.tistory.com/24?category=808600](https://will-behappy.tistory.com/24?category=808600)
>
