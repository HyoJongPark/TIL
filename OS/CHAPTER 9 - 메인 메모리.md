# CHAPTER 9 - 메인 메모리

## 1.  배경_Background

메인 메모리는 현대 컴퓨터 시스템의 운영에 중심적인 역할을 한다. 

메모리는 각각 주소가 할당된 일련의 바이트들로 구성된다.

### 1.1 기본 하드웨어_Basic Hardware

<img width="299" alt="Untitled" src="https://user-images.githubusercontent.com/75190035/176337381-a8c5fa01-82bf-4fa4-a7e1-bae4ef195245.png">

- 메인 메모리와 각 처리 코어에 내장된 레지스터들은 CPU가 직접 접근할 수 있는 유일한 범용 저장장치다.
    - 따라서 모든 실행되는 명령어와 데이터들은 CPU가 직접적으로 접근할 수 있는 메인 메모리와 레지스터에 있어야 한다.
    - 데이터가 메모리에 없다면, CPU가 그것들을 처리하기 전에 메모리로 이동시켜야 한다.
- 각 CPU 코어에 내장된 레지스터들은 일반적으로 CPU 클록(clock)의 1 사이클(cycle)내에 접근 가능하다.
- 메모리 버스를 통해 전송되는 메인 메모리는 메인 메모리에 대한 접근을 완료하기 위해서 많은 CPU 클록 틱 사이클이 소요된다.
    - 이 경우 CPU가 필요한 데이터가 없어서 명령어를 수행하지 못하고 지연되는(shell) 현상이 발생하게 된다.
    - CPU와 메인 메모리 사이에 빠른 속도의 메모리(캐시)를 추가해 해결 할 수 있다.
- 시스템이 올바르게 동작하기 위해서는 사용자 프로그램으로부터 운영체제 영역을 보호해야 할 뿐만 아니라 사용자 프로그램 사이도 서로 보호해야한다.
    - 운영체제가 CPU-메모리 간의 접근 중에 개입하게 되면 성능이 떨어지기 때문에 이러한 보호 기법은 하드웨어가 지원해야 한다.
    - 이 보호 기법을 위해 각각의 프로세스가 독립된 메모리 공간을 가지도록 보장해야 한다.
    - 기준 레지스터와 상한 레지스터라는 두 개의 레지스터를 사용해 보호 기법을 제공할 수 있다.
        - 기준 레지스터: 가장 작은 합법적인 물리 메모리 주소 값을 저장
        - 상한 레지스터: 주어진 영역의 크기를 저장
        - 예) 기준(300040), 상한(120900) 이라면, 프로그램은 300040 ~ 420940 까지의 모든 주소를 접근할 수 있다.

<img width="470" alt="Untitled 1" src="https://user-images.githubusercontent.com/75190035/176337390-ad980ac9-674f-42ac-ba45-f013580d0d5d.png">

### 1.2 주소의 할당_Address Binding

- 프로그램은 이진 실행 파일 형태로 디스크에 저장되어 있다. 실행하려면 프로그램을 메모리로 가져와서 프로세스 문맥 내에 배치해야 한다.
- 이 시점에서 가용한 CPU에서 실행할 수 있게 된다.
- 프로세스가 실행되면 메모리에서 명령 및 데이터에 엑세스한다. 이후 프로세스가 종료되고 다른 프로세스에서 사용하기 위해 메모리가 회수된다.
- 대부분의 시스템은 사용자 프로세스가 메모리 내 어느 부분으로도 올라올 수 있도록 지원하고 있다.
- 사용자 프로그램은 여러 단계를 거쳐 실행되기 떄문에 이들 단계를 거치는 동안 여러 가지 다른 표현 방식을 거치게 된다.

<img width="382" alt="Untitled 2" src="https://user-images.githubusercontent.com/75190035/176337397-6e3cb194-b67e-4778-ba6a-7e0286d9275a.png">

- 전통적으로 메모리 주소 공간에서 명령어와 데이터 바인딩은 그 바인딩이 이루어지는 시점에 따라 다음과 같이 구분된다.
    - **컴파일 시간**(compile time) 바인딩: 프로세스가 메모리 내에 들어갈 위치를 컴파일 시간에 미리 알 수 있으면 컴파일러는 **절대 코드**를 생성할 수 있다.
    - **적재 시간**(load time) 바인딩: 프로세스가 메모리 내 어디로 올라오게 될지를 컴파일 시점에 알지 못하면 컴파일러는 일단 **이진 코드를 재배치 가능 코드**로 만들어야 한다.
    - **실행 시간**(execution time) 바인딩: 프로세스가 실행하는 중간에 메모리 내의 한 세그먼트로 부터 다른 세그먼트로 옮겨질 수 있다면 우리는 바인딩이 실행 시간까지 허용되었다고 이야기한다.

### 1.3 논리 대 물리 주소 공간_Logical-Versus Physical-Address Space

<img width="425" alt="Untitled 3" src="https://user-images.githubusercontent.com/75190035/176337402-609eb0ce-25e2-4144-a76b-c1e31c7f90a1.png">

- CPU가 생성하는 주소를 일반적으로 **논리 주소**(logical address)라 하며, 반면에 메모리가 취급하게 되는 주소는 일반적으로 물리 주소(physical address)라 한다.
- 컴파일 또는 적재 시에 주소를 바인딩하면 논리 주소와 물리 주소가 같다.
- 실행 시간 바인딩 기법에서는 두 주소가 다른데 이때, 논리 주소를 **가상 주소**(virtual address)라 한다.
- 프로그램에 의해 생성된 모든 논리 주소 집합을 **논리 주소 공간**이라 하며, 이 논리 주소와 일치하는 모든 물리 주소 집합을 **물리 주소 공간**이라 한다.
- 프로그램 실행 중에는 이와 같은 가상 주소를 물리 주소로 바꿔줘야 하는데 이 변환 작업은 하드웨어 장치인 **메모리 관리 장치**(memory management unit, **MMU**)에 의해 실행된다.
    - 만약 재배치 레지스터(relocation register)가 14000 이라면, 논리 주소 346 번지에 엑세스할 때, 실제는 메인 메모리의 14346번지에 엑세스 하게 된다.

### 1.4 동적 적재_Dynamic Loading

- 지금까지는 프로세스가 실행되기 위해 그 프로세스 전체가 미리 메모리에 올라와 있어야 했다. 이 경우 프로세스의 크기는 모모리의 크기보다 커서는 안된다.
- 메모리 공간을 더 효율적으로 이용하기 위해서 **동적 적재(dynamic loading)**를 해야 한다**.**
- 동적 적재의 장점은 루틴/데이터가 필요한 경우에만 적재된다는 것이다.
- 이러한 구조는 오류 처리 루틴과 같이 아주 간혹 발생하면서도 실행할 코드가 많은 경우에 특히 유용하다.

### 1.5 동적 연결 및 공유 라이브러리_Dynamic Linking & Shared Libraries

- 공통 라이브러리 루틴을 메모리에 중복으로 올리는 것은 낭비다.
- **동적 연결 라이브러리(DLL)**는 사용자 프로그램이 실행될 때, 사용자 프로그램에 연결되는 시스템 라이브러리다.
- 동적 연결에서는 연결이 실행 시기까지 미루어지고, 라이브러리를 여러 프로세스간에 공유할 수 있어 메인 메모리에 DLL 인스턴스가 하나만 있을 수 있다.

---

## 2. 연속 메모리 할당_Contiguous Memory Allocation

메모리는 일반적으로 두 개의 부분으로 나누어진다. 하나는 운영체제를 위한 메모리, 나머지는 사용자 프로세스를 위한 메모리다.

### 2.1 메모리 보호_Memory Protection

<img width="424" alt="Untitled 4" src="https://user-images.githubusercontent.com/75190035/176578819-65e9378d-04c1-4cad-8500-31910c4ec904.png">

- 시스템이 상한 레지스터와 재배치 레지스터를 가지고 있다면, 프로세스가 자신이 소유하지 않은 메모리를 접근할 수 없게 강제할 수 있다.
- CPU 스케줄러가 다음으로 수행할 프로세스를 선택할 때, 디스패처는 문맥 교환의 일환으로 재배치 레지스터와 상한 레지스터에 정확한 값을 적재한다.
- CPU에 의해서 생성되는 모든 주소는 이 레지스터들의 값을 참조해서 확인 작업을 거치기 때문에, 운영체제와 다른 사용자 프로그램을 현재 수행 중인 사용자 프로그램의 접근으로부터 보호할 수 있다.

### 2.2 메모리 할당_Memory Allocation

<img width="416" alt="Untitled 5" src="https://user-images.githubusercontent.com/75190035/176578823-bebe16fe-6d08-4c03-b86d-9333d30e4b9d.png">

- 메모리를 할당하는 가장 간단한 방법 중 하나는 프로세스 메모리를 가변 크기 파티션에 할당하는 것이다.
- 각 파티션에는 정확히 하나의 프로세스만 적재될 수 있다.
- 이 **가변 파티션 기법**에서 운영체제는 사용 가능한 메모리 부분과 사용 중인 부분을 나타내는 테이블을 유지한다.
- 처음에는 모든 메모리가 사용자 프로세스에서 사용 가능하며, 하나의 큰 사용 가능한 메모리 블록으로 구성되어 있다. 이때, 1 개의 hole이 있다고 한다.
- 일반적으로 메모리에는 다양한 크기의 hole이 여기저기 산재하게 된다.
- 이러한 메모리에서 **동적 메모리 할당 문제**가 있을 수 있다.
    - 가용 공간-리스트로부터 크기 n바이트 블록을 요구하는 것을 어떻게 만족시켜 줄 것인가를 결정하는 문제
- 해결책(연속 메모리 할당 방식)
    - **최초 적합**: **첫 번째 사용 가능한 가용 공간**을 할당한다.
        - 속도 면에서 이점이 있다.
    - **최적 적합**: 사용 가능한 공간들 중 **가장 작은 것(크기가 가장 비슷한 것)**을 할당한다.
        - 이용률 면에서 이점이 있다.
        - 리스트가 크기 순 정렬이 되어있지 않다면, 전체 리스트를 검색해야 한다.
    - **최악 적합**: **가장 큰 가용** 공간을 할당한다.
        - 리스트가 크기 순 정렬이 되어있지 않다면, 전체 리스트를 검색해야 한다.

### 2.3 단편화_Fragmentation

- **외부 단편화(external fragmentation)**: 유휴 공간들을 모두 합치면 충분한 공간이 되지만, 작은 조각들로 분산되어 있어 프로세스를 할당할 수 없는 경우
- 최초, 최적 적합 전략 모두 **외부 단편화**로 인해서 어려움을 겪는다.
- 최초 적합의 경우 통계적인 분석을 하면, N개의 블록이 할당되었을 때 0.5N개의 블록이 단편화 때문에 손실될 수 있다는 것을 알 수 있으며, 이를 50% 규칙이라고 한다.
- **내부 단편화(internal fragmentation)**: 유휴 공간이 충분하지 않아 프로세스를 할당할 수 없는 경우
    - 18464B 크기의 가용공간이 있을 때, 한 프로세스가 18462B 를 요구한다. 이때 남는 공간은 2B인데, 이 공간을 활용하기 위해 오히려 2B 보다 더 큰 부담을 시스템이 가지게 될 것이다.
- **압축(compaction)**: 외부 단편화 문제를 해결하는 방법이다. 이 방법은 메모리 모든 내용을 한군데로 몰고 모든 가용 공간을 다른 한 군데로 몰아서 큰 블록을 만드는 것이다.
    - 최적 알고리즘이 없어 부담이 큰 방법이다.
    - 압축은 프로세스들의 재배치가 실행 시간에 동적으로 이루어지는 경우에만 사용 가능하다.

---

> 참고
> 
> - 책
> 
> [⌜Operating System Concepts 10th - Abraham Silberschatz, Peter B. Galvin, Greg Gagne⌟](http://www.yes24.com/Product/Goods/78225791)
> 
> - 블로그
> 
> [https://will-behappy.tistory.com/24?category=808600](https://will-behappy.tistory.com/24?category=808600)
>
