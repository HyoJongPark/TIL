# CHAPTER 8 - 교착 상태

다중 프로그래밍 환경에서는 여러 스레드가 한정된 자원을 사용하려고 서로 경쟁할 수 있다.

한 스레드가 자원을 요청했을 때, 그 자원을 사용할 수 없는 상황이 발생할 수 있고, 그때는 스레드가 대기 상태로 들어간다. 이처럼 대기 중인 스레드들이 결코 다시는 그 상태를 변경시킬 수 없으면 이런 상황을 **교착 상태**라 부른다.

## 1. 시스템 모델_System Model

- **시스템**은 경쟁하는 스레드들 사이에 분배되어야 할 **유한한 수의 자원들로 구성**된다.
- 이 **자원**들은 다수의 유형 또는 클래스로 분할되며, 이들 각각은 **동등한 다수의 인스턴스들로 구성**된다.
    - 자원의 예: CPU 주기, 파일, 입/출력 장치 등
- 정상적인 작동 모드하에서, 프로세스는 다음 순서로만 자원을 사용할 수 있다.
    1. 요청
        - 스레드는 자원을 요청한다. 요청이 즉시 허용되지 않으면, 요청 스레드는 자원을 얻을 때 까지 대기해야 한다.
    2. 사용
        - 스레드는 자원에 대해 작업을 수행할 수 있다.
    3. 방출
        - 스레드가 자원을 방출한다.
    - 자원의 요청, 방출은 시스템 콜이다.(`request()`, `release()` 등)
- 한 스레드 집합 내의 모든 스레드가 그 집합 내의 다른 스레드에 의해서만 발생될 수 있는 이벤트를 기다린다면, 그 스레드 집합은 **교착 상태에 있다.**

---

## 2. 다중 스레드 응용에서의 교착 상태_Deadlock in Multithreaded Applications

### 2.1 라이브락_Livelock

- 라이브락(livelock)은 또 다른 형태의 라이브니스 장애다.
- 두개 이상의 스레드가 진행되는 것을 방해한다는 점에서 교착 상태와 유사하지만 진행할 수 없는 이유가 서로 다르다.
- 교착 상태는 어떤 스레드가 같은 집합에 속한 다른 스레드에 의해서만 발생할 수 있는 이벤트를 기다리면서 봉쇄되면 발생
- 라이브락은 스레드가 실패한 행동을 계속해서 시도할 때 발생한다.

---

## 3. 교착 상태 특성_Deadlock Characterization

### 3.1 필요조건들_Necessary Conditions

- 교착 상태는 한 시스템에 다음 네 가지 조건들이 동시에 성립될 때 발생할 수 있다.
1. 상호 배제(mutual exclusion)
    - 최소 하나의 자원이 비공유 모드로 점유되어야 한다.
    - 비공유 모드에서는 한 번에 한 스레드만이 그 자원을 사용할 수 있다.
    - 다른 스레드가 그 자원을 요청하면, 요청 스레드는 자원이 방출될 때까지 반드시 지연되어야 한다.
2. 점유하며 대기(hold-and-wait)
    - 스레드는 최소한 하나의 자원을 점유한 채, 현재 다른 스레드에 의해 점유된 자원을 추가로 얻기 위해 반드시 대기해야 한다.
3. 비선점(no preemption)
    - 자원들을 선점할 수 없어야 한다.
    - 자원이 강제적으로 방출될 수 없고, 점유하고 있는 스레드가 태스크를 종료한 후 그 스레드에 의해 자발적으로만 방출될 수 있다.
4. 순환 대기(circular wait)
    - 대기하고 있는 스레드 집합[T0, T1, … , Tn]에서는 T0는 T1이 점유한 자원을 대기하고, T1은 T2가 점유한 자원을 대기한다. (순환 대기)

### 3.2 자원 할당 그래프_Resource-Allocation Graph

![Untitled](https://user-images.githubusercontent.com/75190035/175801377-45c9cf1b-9679-4a98-93c0-10462404346e.png)

- 교착 상태는 시스템 자원 할당 그래프라고 하는 방향 그래프로 더욱 정확하게 기술될 수 있다.
- 이 그래프는 정점(vertex) V의 집합, 간선(edge) E의 집합으로 구성된다.
- 정점 V의 집합은 시스템 내 모든 활성 스레드 집합인 T = {T1, T2, …, Tn}과 시스템 내 모든 자원 유형의 집합인 R = {R1, R2, …, Rn}의 두 가지 유형으로 구별된다.
- **표현 방법**
    - **요청 간선(request edge)**
        - 스레드 Ti로부터 자원 유형 Rj로의 방향 간선은 Ti → Rj로 표현하며, 이것은 **스레드가 자원 유형의 인스턴스를 하나 요청**하는 것으로 현재 이 자원을 기다리는 상태다.
    - **할당 간선(request edge)**
        - 자원 유형 Rj부터 스레드 Ti로의 방향 간선은 Rj → Ti로 표현하며, 이것은 자원 유형의 한 인스턴스가 스레드에 할당된 것을 의미한다.
    - 각 스레드를 원으로 표현하고, 각 자원 유형을 사각형으로 표시한다.
    - 각 자원 유형이 가지는 인스턴스의 수를 사각형 안의 점으로 표시한다.

**자원 할당 그래프 예시 1**

![Untitled 1](https://user-images.githubusercontent.com/75190035/175801391-60746c15-482b-469c-90cb-2be915692b9f.png)

위 그림의 자원 할당 그래프는 다음 상황을 묘사한다.

- 집합 T, R, E
    - T = {T1, T2, T3}
    - R = {R1, R2, R3, R4}
    - E = {T1 → R1, T2 → R3, R1 → T2, R2 → T2, R3 → T3}
- 자원의 인스턴스
    - 자원 유형 R1의 인스턴스가 한 개
    - 자원 유형 R2의 인스턴스가 두 개
    - 자원 유형 R3의 인스턴스가 한 개
    - 자원 유형 R4의 인스턴스가 세 개
- 스레드 상태
    - 스레드 T1은 자원유형 R2의 인스턴스 한 개를 점유하고, 자원 유형 R1의 인스턴스 한 개를 기다리며 대기한다.
    - 스레드 T2는 R1, R2의 인스턴스를 각각 한 개씩 점유하고, 자원 유형 R3의 인스턴스를 한 개 기다린다.
    - 스레드 T3는 R3의 인스턴스 한 개를 점유하고 있다.
- 교착 상태 여부
    - 만약 각 자원 유형이 하나의 인스턴스만 가지면, 그래프 내의 한 사이클은 교착 상태가 존재하기 위한 필요 충분 조건이 된다.
    - 만약 각 자원 유형이 하나 이상의 인스턴스만 가지면, 그래프 내의 한 사이클은 교착 상태가 존재하기 위한 필요조건이지만, 충분 조건이 되지는 않는다.
    - 위 그래프에서는 스레드 T3가 어떠한 자원 유형도 점유하지 않기 때문에 **점유하며 대기**조건에 맞지 않는다. 따라서 교착 상태가 아니다.

**자원 할당 그래프 예시 2**

![Untitled 2](https://user-images.githubusercontent.com/75190035/175801395-4323ae10-b513-4120-8569-67796c9d8788.png)

예시1에서 T3 → R2 요청간선이 추가되어 이 시스템 내에 최소 2개의 사이클이 존재하게 되었다.

- T1 → R1 → T2 → R3 → T3 → R2 → T1 → T2 → R3 → T3 → R2 → T2
- 교착 상태 여부
    - 스레드 T1, T2, T3는 교착 상태다.
    - 스레드 T1는 스레드 T2가 점유하고 있는 자원 R1을 기다린다.
    - 스레드 T2는 스레드 T3가 점유하고 있는 자원 R3을 기다린다.
    - 스레드 T3는 스레드 T1, T3가 점유하고 있는 자원 R2을 기다린다.

**자원 할당 그래프 예시 3**

![Untitled 3](https://user-images.githubusercontent.com/75190035/175801397-dd3b29ef-bbab-4754-a58c-7767b370cfde.png)

예시 3도 사이클을 갖는다.

- T1 → R1 → T3 → R2 → T1
- 교착 상태 여부
    - 위 예시는 교착 상태가 없다.
    - 프로세스 T4가 자원유형 R2의 인스턴스를 방출할 수 있다.
    - 이어 T3가 할당될 수 있고 그 경우 사이클이 없어진다.

요약하면, **자원 할당 그래프에 사이클이 없다면, 시스템을 교착상태가 아니다.**

반면, **사이클이 있다면 시스템은 교착 상태일 수도, 아닐 수도 있다.**

---

## 4. 교착 상태 처리 방법_Methods for Handling Deadlocks

- 원칙적으로 교착 상태 문제를 처리하는 데는 세 가지 다른 방법이 있다.
    1. 문제를 **무시**하고, 교착 상태가 시스템에서 절대 발생하지 않는 척 한다.
        1. 4가지 조건을 만족해도 교착 상태가 반드시 일어나는 것이 아니기 때문에 무시한다.
        2. 교착 상태를 복구하는 데 드는 비용이 더 클 수도 있다.
    2. 시스템이 결코 교착 상태가 되지 않도록 보장하기 위해 교착 상태를 **예방**, **회피**하는 프로토콜을 사용한다.
        1. **교착 상태 예방**은 언급한 필요 조건 중 적어도 하나가 성립하지 않도록 보장하는 방법이다.
        2. **교착 상태 회피**는 스레드가 평생 요구하고 사용할 자원에 대한 부가적인 정보를 미리 제공할 것을 요구한다. 이런 추가적인 정보를 가지고, 운영체제는 각 요청을 위해 그 스레드가 기다려야 할지 않을지 결정할 수 있다.
    3. 시스템이 교착 상태가 되도록 허용한 다음에 **복구**시킨다.
        1. 교착 상태 예방, 회피 알고리즘을 사용하지 않으면 교착 상태가 발생할 수 있다. 이런 환경에서 교착 상태가 발생했는지 조사하는 알고리즘과 복구하기 위한 알고리즘을 제공할 수 있다.

---

## 5. 교착 상태 예방_Deadlock Prevention

교착 상태가 발생하기 위한 네 가지 필요조건 중 최소한 하나가 성립하지 않는 것을 보장함으로써, 교착 상태를 예방할 수 있다.

### 5.1 상호 배제_Mutual Exclusion

- 상호 배제 조건이 성립하지 않도록 하기위해 자원을 공유 가능하도록 할 수 있다.
- 하지만, 일반적으로 상호 배제 조건을 거부함으로써 교착 상태를 예방하는 것은 불가능하다. 어떤 자원들은 근본적으로 공유가 불가능하기 때문이다.
    - 예를 들어 mutex 락은 동시에 여러 스레드가 공유할 수 없다.

### 5.2 점유하며 대기_Hold and Wait

- 시스템에서 점유하며 대기 조건이 발생하지 않도록 하려면 스레드가 자원을 요청할 때마다 다른 자원을 보유하지 않도록 보장해야 한다.
- 첫 번째 대안은 각 스레드가 실행을 시작하기 전에 모든 자원을 요청하고 할당해야 한다.
- 두 번째 대안은 스레드가 자원을 전혀 가지고 있지 않을 때만 자원을 요청할 수 있도록 허용한다. 스레드가 추가 자원을 요청할 수 있으려면, 자신에게 할당된 모든 자원을 먼저 방출해야 한다.
- 단점
    - 자원이 할당되었지만 장기간 사용되지 않을 수 있기 때문에 **자원 이용률이 낮을 수 있다.**
    - 인기 있는 여러 개의 자원이 필요한 스레드는 필요한 자원 중 적어도 하나는 항상 다른 스레드에게 할당되므로 **무한정 대기해야할 수 있다.**

### 5.3 비선점_No Preemption

- 비선점 조건이 성립되지 않을 것을 보장하기 위해, 어떤 자원을 점유하고 있는 스레드가 즉시 할당할 수 없는 다른 자원을 요청하면 현재 점유하고 있는 모든 자원이 선점되도록 할 수 있다.
- 즉, 이들 자원들이 묵시적으로 방출되고, 선점된 자원들은 그 스레드가 기다리고 있는 자원들의 리스트에 추가된다.
- 스레드는 자신이 요청하고 있는 새로운 자원은 물론 이미 점유하였던 옛 자원들을 다시 획득할 수 있을 때만 다시 시작될 것이다.

### 5.4 순환 대기_Circular Wait

- 앞선 세 가지 옵션은 대부분의 상황에서 일반적으로 실용적이지 않다. 그러나 순환 대기 조건은 필요한 조건 중 하나를 무효화하여 실용적인 해결책을 제공할 수 있는 기회를 제공한다.
- 순환 대기 조건이 성립되지 않도록 하는 한 가지 방법은 모든 자원 유형에 전체적인 순서를 부여하여, 각 프로세스가 열거된 순서대로 오름차순으로 자원을 요청하도록 요구하는 것이다.

---

## 6. 교착 상태 회피_Deadlock Avoidance

교착 상태 예방을 할 때 가능한 부수적인 문제는 장치의 이용률이 저하되고 시스템 총처리율이 감소한다는 것이다.

교착 상태를 회피하는 다른 대안은 자원이 어떻게 요청될지에 대한 추가 정보를 제공하도록 요구하는 것이다.

이 정보를 사용하는 가장 간단하고 유용한 모델은 각 스레드가 자신이 필요로 하는 각 유형의 자원마다 최대 수를 선언하도록 요구하는 것이다. 각 스레드가 요청할 각 유형의 자원의 최대 수 정보를 미리 파악 가능하다면, 시스템이 교착 상태에 들어가지 않을 것을 보장하는 알고리즘을 만들 수 있다.

### 6.1 안전 상태_Safe Satate

- 시스템이 안전하다는 것은 시스템이 어떤 순서로든 스레드들이 요청하는 모든 자원을 교착 생타를 야기하지 않고 차례로 무두 할당해 줄 수 있다는 것을 뜻한다.
- 시스템이 **안전 순서(safe sequence)**를 찾을 수 있다면 시스템은 안전하다고 말한다.
- 시스템이 안전 순서를 찾을 수 없다면 시스템은 불안전하다고한다.
- 시스템의 상태가 안전하다는 것은 교착 상태가 발생하지 않는다는 것을 뜻한다.
- 반면, 시스템 상태가 불안전하다고 해서 반드시 교착 상태로 가는 것은 아니다. 갈 수도 있다는 뜻이다.
- 시스템이 안전 상태에 머무는 한 운영체제는 불안전 상태나 교착 상태를 모두 예방할 수 있다.
- 이 방법에서는 스레드가 요청한 자원보다 많은 양을 시스템이 보유하고 있다고 하더라도 그 프로세스를 기다리게 하는 상황이 발생할 수 있다. 따라서 자원의 이용률은 회피를 안 쓸 때에 비해 낮아질 수밖에 없다.

시스템에 12개의 자원이 있고, 다음과 같은 세 개의 프로세스가 있다고 가정하자. (시스템의 현재 보유량은 3개(12 - (5 + 2 + 2)))

| 스레드 | 최대 요구량 | 현재 보유량(t0 시점) |
| --- | --- | --- |
| T0 | 10 | 5 |
| T1 | 4 | 2 |
| T2 | 9 | 2 |
1. T1에 2개의 자원을 할당해 T1을 종료시키고, 4개의 자원을 반납받는다. (시스템 보유분 5개)
2. T0에 5개의 자원을 할당해 T0를 종료시키고, 10개의 자원을 반납받는다.(시스템 보유분 10개)
3. T2에 7개의 자원을 할당해 T2를 종료시키고, 7개의 자원을 반납받는다.(시스템 보유분 13개)

따라서, **t0 시점에서 시스템의 상태는 안전하다.** <T1, T0, T2> 순서가 있으므로 안전 상태이다.

하지만 시스템은 안전 상태에 있다가 불안전 상태로 전이할 수도 있다. 만약 t1 시점에 T2가 자원을 하나 더 요청하면, T1만이 원하는 자원을 다 할당받을 수 있고, 나머지는 자원을 계속 기다려야한다.

따라서 교착 상태다.

### 6.2 자원 할당 그래프 알고리즘_Resource-Allocation Graph Algorithm

![Untitled 4](https://user-images.githubusercontent.com/75190035/175850740-e0114db6-3320-47c3-8439-c91e752910d8.png)

- 각 자원 유형마다 하나의 인스턴스를 갖는 자원할당 시스템을 갖고있다면, 자원 할당 그래프의 변형을 사용할 수 있다.
- 요청 간선과 할당 간선에 **예약 간선**(claim edge)이라는 새로운 타입의 간선을 추가한다.
    - 예약 간선 Ti → Rj는 Ti가 미래에 Rj를 요청할 것이라는 의미다.
    - 요청 간선과 유사하지만 점선으로 표시한다.
    - 프로세스가 실제로 자원을 요청하면 예약 간선은 요청 간선으로 변환된다.
    - 프로세스가 자원을 방출하면 할당 간선 Rj → Ti는 예약 간선 Ti → Rj로 다시 변환된다.
- 우리는 스레드 Ti가 실행되기 전, 스레드의 모든 예약 간선이 자원 할당 그래프에 표시해야 하고, 스레드 Ti와 연관된 모든 간선들이 예약 간선일 때만 예약 간선 Ti -> Rj를 그래프에 추가하도록 허용하면 된다.
- 또한 이때 요청 간선 Ti -> Rj가 할당 간선으로 변환해도 자원 할당 그래프에 **사이클을 형성하지 않을 때만 요청을 허용**할 수 있다.
- 그래프에서 사이클이 없다면 시스템은 안전 상태가 되고, 사이클이 있다면 시스템은 불안전 상태가되 교착 상태를 회피할 수 없게 된다.

### 6.3 은행원 알고리즘_Banker’s Algorithm

- 자원 할당 그래프 알고리즘은 종류마다 자원이 여러 개씩 있다면 사용할 수 없다. 자원이 여러개 있는 상황에서는 은행원 알고리즘을 사용할 수 있다.
- 이 시스템에서는 스레드가 시작할 때 스레드가 가지고 있어야 할 자원의 최대 개수를 자원 종류마다 미리 신고하여야 한다. 이 숫자가 자원의 총 보유 수를 넘어서면 안된다.
- 스레드가 자원을 요청하면, 시스템은 요청을 들어 줬을 때도 계속 안전 상태에 머무르게 되는지 여부를 판단해야 한다.
- 안전하다고 판단되면 요청을 들어주고, 아니라면 스레드가 끝날 때까지 기다리게 된다.
- 은행원 알고리즘을 구현하는 데 필요한 자료구조
    - n 은 스레드의 수, m은 자원 종류의 수
    - **Available**: 각 종류별로 가용한 자원의 개수를 나타내는 벡터, 크기가 n이다.
        - `Available[j] = k` 라면, 현재 Rj를 k개 사요할 수 있다는 뜻이다.
    - **Max**: 각 스레드가 최대로 필요로 하는 자원의 개수를 나타내는 행렬, 크기가 n x m이다.
        - `Max[i][j] = k` 라면, 스레드 Ti가 Rj를 최대 k개 요청할 수 있다는 뜻이다.
    - **Allocation**: 각 스레드에 현재 할당된 자원의 개수를 나타내는 행렬, 크기가 n x m이다.
        - `Allocation[i][j] = k`라면, 현재 스레드 Ti가 Rj를 k개 사용하고 있다는 뜻이다.
    - **Need**: 각 스레드가 향후 요청할 수 있는 자원의 개수를 나타내는 행렬, 크기가 n x m이다.
        - `Need[i][j] = k` 라면, 스레드 Ti가 Rj를 k개 까지 더 요청할 수 있다는 뜻이다.
        - `Need[i][j] = Max[i][j] - Allocation[i][j]`
    - 이 자료구조들은 시간이 지남에 따라 그 값과 크기가 변할 수 있다.

**6.3.1 안전성 알고리즘_Safety Algorithm**

시스템이 안전한지 아닌지 알아낼 수 있는 알고리즘은 다음과 같다. 이 알고리즘으로 안전 여부를 알아내는 데에는 `m x n^2` 개의 연산이 필요하다.

1. **Work**와 **Finish**는 크기가 m과 n인 벡터다. 
    1. Work = Available로 초기 값은 준다.
    2. `Finish[i] = false`를 초기값으로 준다. (i = 0, 1, …, n-1)
2. 아래 두 조건을 만족하는 i 값을 찾는다.
    1. `Finish[i] == false`
    2. `Need(i) <= Work`
    3. 그러한 i 값이 없다면 4번으로 간다.
3. `Work = Work + Allocation(i)`, `Finish[i] = true`, 2번으로 간다.
4. 모든 i 값에 대해 `Finish[i] == true` 면 이 시스템은 안전 상태에 있다.

**6.3.2 자원 요청 알고리즘_Resource-Request Algorithm**

자원 요청이 안전하게 들어줄 수 있는지를 검사하는 알고리즘은 다음과 같다.

1. `Request(i) <= Need(i)` 이면 2번으로 간다. 아니라면 시스템에 있는 개수보다 더 많이 요청한 것이므로 오류로 처리한다.
2. `Request(i) <= Available` 이면 3번으로 간다. 아니라면 요청한 자원이 당장은 없으므로 프로세스 Pi는 기다려야 한다.
3. 마치 시스템이 Ti에게 자원을 할당해준 것처럼 시스템 상태 정보를 아래처럼 바꾸어본다.
    1. `Available = Available - Request(i)`
    2. `Allocation(i) = Allocation(i) + Request(i)`
    3. `Need(i) = Need(i) - Request(i)`
    4. 이 상태가 안전하다면, Ti에 여기에 반영된 정보대로 자원을 할당해준다.
    5. 불안전하다면, 위의 자원 할당 상태는 원상태로 복원되고, Ti는 Request(i)가 만족하기까지 기다려야 한다.

- 예시

다음고 같은 프로세스가 있다고 가정하자.

(시스템에는 자원이 각각 총 A: 10개, B: 5개, C: 7개가 있다.)

|  | Allocation | Max | Need( = Max - Allocation) | Available |
| --- | --- | --- | --- | --- |
|  | A B C | A B C | A B C | A B C |
| T0 | 0 1 0 | 7 5 3 | 7 4 3 | 3 3 2 |
| T1 | 2 0 0  | 3 2 2 | 1 2 2 |  |
| T2 | 3 0 2 | 9 0 2 | 6 0 0 |  |
| T3 | 2 1 1 | 2 2 2 | 0 1 1 |  |
| T4 | 0 0 2 | 4 3 3 | 4 3 1 |  |

이 시스템은 안전하다. <T1, T3, T4, T2, T0> 순서는 안전성 기준을 만족시키기 때문이다.

이 상태에서 T1이 A자원 한 개, C자원 두 개를 요청한다고 가정하자.(`Request(1) = (1, 0 ,2)`)

이 자원 요청을 안전하게 들어줄 수 있는지 검사하기 위해 다음을 수행해야 한다.

1. `Request(1) <= Need(1)`인지 검사 → `(1, 0 ,2) <= (1, 2, 2)` → True
2. `Request(1) <= Available` 인지 검사 → `(1, 0 ,2) <= (3, 3, 2)` → True
3. 위 두 조건을 만족하므로 시스템 정보를 바꿔 안전 상태를 검사한다.

|  | Allocation
(= Allocation(1) + Reuest(1) | Need
(= Need(1) - Request(1)) | Available
(= Available - Request(1) |
| --- | --- | --- | --- |
|  | A B C | A B C | A B C |
| T0 | 0 1 0 | 7 4 3 | 2 3 0 |
| T1 | 3 0 2  | 0 2 0 |  |
| T2 | 3 0 2 | 6 0 0 |  |
| T3 | 2 1 1 | 0 1 1 |  |
| T4 | 0 0 2 | 4 3 1 |  |

이 상태가 안전한지 판단하기 위해 안전성 알고리즘을 돌려보면 <T1, T3, T4, T0, T2>가 안전성 조건을 만족시킴을 알 수 있다. 따라서 T1의 요청을 즉시 들어줄 수 있다.

---

> 참고
> 
> - 책
> 
> [⌜Operating System Concepts 10th - Abraham Silberschatz, Peter B. Galvin, Greg Gagne⌟](http://www.yes24.com/Product/Goods/78225791)
> 
> - 블로그
> 
> [https://suhwanc.tistory.com/181?category=879656](https://suhwanc.tistory.com/181?category=879656)
> 
> [https://will-behappy.tistory.com/23?category=808600](https://will-behappy.tistory.com/23?category=808600)
>
