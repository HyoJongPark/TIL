# CHAPTER 10 - 가상 메모리

9장의 메모리 관리 전략들은 모두 다중 프로그래밍을 실현하기 위해 메모리에 많은 프로세스를 동시에 유지하는 것을 목적으로 했다. 

그러나 이 전략에서 접근 방식은 프로세스 전체가 실행되기 전에 메모리로 올라와야 한다는 것을 전제로 한다.

**가상 메모리(virtual memory)**라는 것은 프로세스 전체가 메모리 내에 올라오지 않더라도 실행이 가능하도록 하는 기법이다. 이 기법의 장점은 사용자 프로그램이 물리 메모리보다 커져도 된다는 점이다.

즉, 이 기법을 통해 프로그래머는 메모리의 크기에 제약으로부터 자유로워진다. 또한 가상 메모리는 파일과 라이브러리의 공유를 쉽게 해주고 공유 메모리 구현을 가능하게 해준다.

단점은 구현하기 어렵고, 잘못 사용하게 되면 성능이 현저히 저하될 수 있다.

## 1. 배경_Background

- 실행 중인 코드는 반드시 물리 메모리에 있어야 한다는 조건은 필요하고 타당한 요구조건으로 보이지만, 프로그램의 크기를 물리 메모리의 크기로 제한한다는 점 때문에 환영할만한 조건이 아니다.
- 다음 예시들을 생각해보면 프로그램 전체가 꼭 메모리에 올라와 있어야 하는 것은 아니라는 것을 알 수 있다.
    - 프로그램에는 잘 발생하지 않는 예외처리 코드가 종종 존재한다. 이런 오류들은 실질적으로 거의 발생하지 않으므로, 이 코드들은 잘 실행되지 않는다.
    - 배열, 리스트, 테이블 등은 필요 이상으로 많은 공간을 점유할 수 있다.
    - 프로그램 내의 어떤 옵션이나 기능들은 거의 사용되지 않는다.
- 만약 프로그램의 일부분만 올려놓고 실행할 수 있다면, 다음과 같은 이점을 얻을 수 있다.
    - **프로그램은 물리 메모리 크기에 제약을 받지 않게 된다.** 사용자들은 매우 큰 가상 주소 공간을 가정하고 프로그램을 만들 수 있으므로, 프로그래밍 작업이 간단해진다.
    - 각 프로그램이 더 작은 메모리를 차지해 **더 많은 프로그램이 동시에 실행될 수 있다.** 이에 따라 응답시간은 늘어나지 않으면서 CPU 이용률과 처리율이 높아진다.
    - 프로그램을 메모리에 올리고 스왑하는데 필요한 I/O 회수가 줄어들기 떄문에 **프로그램들이 보다 빨리 실행된다.**
- **가상 메모리**는 실제의 물리 메모리 개념과 개발자의 논리 메모리 개념을 분리한 것으로, 작은 메모리를 가지고도 얼마든지 큰 가상 주소 공간을 프로그래머에게 제공할 수 있다.

---

## 2. 요구 페이징_Demand Paging

프로그램을 보조저장장치에서 메모리로 적재하는 한 가지 방법은 프로그램 실행 시 프로그램의 전부를 메모리에 저장하는 것이다.

이 방법의 문제는 초기에는 프로그램의 전체가 메모리에 있을 필요는 없을지도 모른다는 점이다.

다른 전략은 필요한 페이지만 적재하는 것이다. 이것은 **요구 페이징(demand paging)**이라 하며, 가상 메모리 시스템에서 일반적으로 사용된다.

요구 페이징 가상 메모리를 사용하면, 프로그램 실행 중 필요할 때만 페이지가 적재된다.

### 2.1 기본 개념_Basic Concepts

![Untitled](https://user-images.githubusercontent.com/75190035/177072777-4754489c-010f-439d-a554-b852bd9ffcaf.png)

- 요구 페이징을 구현하기 위해 **유효-무효비트 기법**이 사용된다.
    - **비트가 유효**하다고 설정되면, 해당 페이지가 메모리에 있다는 것을 의미한다.
    - **비트가 무효**하다고 설정되면 해당 페이지가 유효하지 않거나, 유효하지만 보조저장장치에 존재한다는 것을 의미한다.
- 프로세스가 메모리에 올라와 있지 않은 페이지에 접근하려고 하면, 테이블 항목이 **무효**로 설정되어 있으므로 **페이지 폴트 트랩**을 발생시킨다.
- **순수 요구 페이징(pure demand paging)**
    - 극단적인 경우에 메모리에 페이지가 하나도 올라와있지 않은 상황에서 프로세스를 실행시킬 수 있다.
    - 운영체제에서 명령 포인터의 값을 프로세스의 첫 명령으로 설정하는 순간, 메모리에 존재하지 않는 페이지에 있으므로 페이지 폴트를 발생시킨다.
    - 페이지가 적재되고 난 후 실행을 계속하는데 프로세스가 사용하는 모든 페이지가 메모리에 올라올 때까지 필요할 때마다 페이지 폴트가 발생한다.
    - 이것이 **순수 요구 페이징**이고, **어떤 페이지가 필요해지기 전에는 결코 그 페이지를 적재하지 않는 방법이다.**
- 프로그램들은 한 명령어에서도 여러 개의 페이지 폴트가 발생할 수 있다. 이렇게 되면 시스템 성능의 저하를 초래한다.
- 다만, 모든 프로그램은 **참조의 지역성(locality of reference)**이라는 성질이 있어 어느 한 특정 작은 부분만 집중적으로 참조하는데, 이러한 성질 때문에 요구 페이징은 만족할 만한 성능을 보인다.
- 요구 페이징을 지원하기 위한 하드웨어
    - 페이지 테이블: 유효/무효 비트를 통해 특정 항목을 무효로 설정할 수 있어야 한다.
    - 보조저장장치: 메인 메모리에 없는 모든 페이지를 가지고 있다. 보통은 고성능의 디스크 또는 NVM 장치다.

### 2.2 요구 페이징의 성능_Performance of Demand Paging

- 요구 페이징은 컴퓨터 시스템의 성능에 큰 영향을 줄 수 있다.
- **실질 접근 시간**
    - 페이지 폴트가 없는 한 실질 접근 시간은 메모리 접근 시간과 같다. 그러나 페이지 폴트가 발생하면, 먼저 보조저장장치에서 해당 페이지를 읽은 다음 원하는 워드에 접근해야 한다.
    - 실질 접근시간 = (1-p) * ma + p * 페이지 폴트 시간
        - p = 페이지 폴트 확률, ma = 메모리 접근 시간
- **실질 접근 시간은 페이지 폴트율에 비례**하며, 페이지 폴트 처리 시간은 크게 3 가지로 이루어 진다.
    1. 인터럽트의 처리
    2. 페이지 읽기
    3. 프로세스 재시작
- 요구 페이징의 또 다른 특성 중 하나는 스왑 공간의 관리이다.
- 시스템이 더 나은 처리량을 얻는 옵션 중 첫번째는 프로세스 시작 시 전체 파일 이미지를 스왑 공간에 복사한 다음 스왑 공간에서 요구 페이징을 수행하는 것이다. 이 방법은 프로그램 시작 시 파일 이미지를 복사하는 단점이 있다.
- 시스템이 더 나은 처리량을 얻는 옵션 중 두 번째 방법은 프로그램을 처음 시작시킬 때에는 파일 시스템으로부터 요구 페이징을 처리하지만, 그 페이지들이 교체될 떄는 스왑 공간에 페이지를 기록하는 것이다.
- 두 번째 방법은 파일 시스템으로부터는 꼭 필요한 페이지들만 읽어 오면서, 그 페이지를 다시 읽어올 때는 스왑 공간에서 읽어온다는 것을 보장한다.

> 실질 접근 시간을 계산하기 위해 페이지 폴트를 처리하는 데 얼마나 많은 시간이 걸리는지 알아야 한다. 페이지 폴트는 다음 순서로 처리된다.
> 
> 1. 운영체제에 트랩을 요청한다.
> 2. 레지스터들과 프로세스 상태를 저장한다.
> 3. 인터럽트 원인이 페이지 폴트임을 알아낸다.
> 4. 페이지 참조가 유효한 것인지 확인하고, 보조저장장치에 있는 페이지의 위치를 알아낸다.
> 5. 저장장치에 가용 프레임으로의 읽기 요구를 낸다.
>     1. 읽기 차례가 돌아오기까지 대기 큐에서 기다린다.
>     2. 디스크에서 찾는 시간과 회전 지연 시간동안 기다린다.
>     3. 가용 프레임으로 페이지 전송을 시작한다.
> 6. 기다리는 동안 CPU 코어는 다른 사용자에게 할당된다.
> 7. 저장장치가 다 읽었다고 인터럽트를 건다.(I/O 완료)
> 8. 다른 프로세스의 레지스터들과 프로세스 상태를 저장한다.(6단계가 실행되었을 경우)
> 9. 인터럽트가 보조저장장치로부터 왔다는 것을 알아낸다.
> 10. 새 페이지가 메모리로 올라왔다는 것을 페이지 테이블과 다른 테이블들에 기록한다.
> 11. CPU 코어가 자기 차례로 오기까지 기다린다.
> 12. CPU 차례가 오면 위에서 저장시켜두었던 레지스터, 프로세스 상태, 새로운 페이지 테이블을 복원시키고 인터럽트되었던 명령어를 다시 실행한다.

---

## 3. 쓰기 시 복사_Copy-on-Write

![Untitled 1](https://user-images.githubusercontent.com/75190035/177072786-b16038bd-bead-4407-af09-8352fbeca509.png)

`fork()` 시스템 콜을 통해 프로세스를 생성할 때는 페이지 공유와 비슷한 기법으로 첫 요구 페이징조차 생략하는 것이 가능하다.

- `fork()` 를 하면 부모 프로세스의 페이지들을 실제로 자식 프로세스에 복사해 줌으로써 자식 프로세스의 주소 공간을 구성해 준다.
- 하지만 대부분의 자식은 이후 `exec()` 시스템 콜을 한다. 그러면 부모로부터 복사해온 페이지들은 다 쓸모없는 것들이 된다.
- 부모의 페이지들을 다 복사해오는 대신 **쓰기 시 복사(copy-on-write) 방식**을 사용할 수 있다.
- 이 방식에서는 자식 프로세스가 시작할 때 부모의 페이지를 당분간 함께 사용하도록 한다. 이때 공유되는 페이지를 쓰기 시 복사 페이지라고 표시한다.
- 둘 중 한 프로세스가 공유 중인 페이지에 쓸 때 그 페이지의 복사본이 만들어진다.
- 수정되지 않는 페이지들은 부모, 자식 간에 계속 공유될 수 있다.
- 쓰기 시 복사 시에는 자식이 부모 주소 공간의 페이지에 변경을 가하지 않도록 주의해야 한다.

---

## 4. 페이지 교체_Page Replacement

---

> 참고
> 
> - 책
> 
> [⌜Operating System Concepts 10th - Abraham Silberschatz, Peter B. Galvin, Greg Gagne⌟](http://www.yes24.com/Product/Goods/78225791)
> 
> - 블로그
> 
> [https://will-behappy.tistory.com/25?category=808600](https://will-behappy.tistory.com/25?category=808600)
>
