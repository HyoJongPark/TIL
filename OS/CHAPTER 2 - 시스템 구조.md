# CHAPTER 2 - 시스템 구조

## 1. 운영체제 서비스_OS Services

![Untitled](https://user-images.githubusercontent.com/75190035/173273973-c351b993-8463-469e-bd1f-d03d3d0ad632.png)

운영체제는 프로그램 실행 환경을 제공하며, 프로그램과 그 프로그램의 사용자에게 특정 서비스를 제공한다.

- 사용자 인터페이스(User Interface):
    - 거의 모든 운영체제는 사용자 인터페이스(UI)를 제공한다.
    - 그래픽 사용자 인터페이스(GUI)
        - 가장 일반적인 사용자 인터페이스
        - 그래픽 요소들을 통해 인터페이스를 제공
    - 배치
    - 명령어 라인 인터페이스(CLI)
        - 명령을 사용하며 이를 입력할 방법이 사용된다.
- 프로그램 수행(Program Execution)
    - 시스템은 프로그램을 메모리에 적재해 실행할 수 있어야 한다.
    - 프로그램은 정상적이든, 비정상적이든 실행을 끝낼 수 있어야 한다.
- 입출력 연산(I/O Operation)
    - 수행 중인 프로그램은 입/출력을 요구할 수 있다.
    - 사용자들은 통상 입출력 장치를 직접 제어할 수 없기 때문에 운영체제가 직접 입출력 수행의 수단을 제공해야 한다.
- 파일 시스템 조작(File System Manipulation)
    - 프로그램은 파일을 읽고 쓸 수 있어야 한다.
    - 프로그램은 이름에 대해 파일을 생성/삭제/열거 할 수 있어야 한다.
- 통신(Communication)
    - 서로 다른 프로세스가 정보를 교환해야하는 상황에 통신은 공유 메모리, 메시지 전달 기법을 사용해서 구현될 수 있다.
- 오류 탐지(Error Detection)
    - 운영체제는 모든 가능한 오류를 항상 의식하고 있어야 하며, 각 유형의 오류에 대해 적당한 조치를 해야 한다.
- 자원 할당(Resource Allocation)
    - 다수의 프로세스, 다수의 작업이 동시에 실행될 때 자원을 할당해 주어야 한다.
- 기록 작성(Logging)
    - 어떤 프로그램이 얼마나 많은 자원을 사용하는지 추적할 수 있어야 한다.
- 보호와 보안(Protection & Security)
    - 보호(Protection): 시스템 자원에 대한 모든 접근이 통제되도록 보장하는 것
    - 보안(Security): 사용자가 자원에 대한 접근을 원할 때, 시스템에게 자기 자신을 인증하는 것으로 부터 시작되고, 외부 입출력 장치들을 부적합한 접근 시도로 부터 지킨다.

---

## 2. 사용자 운영체제 인터페이스_User and OS Interface

사용자와 운영체제가 접촉하는 여러 방식이 있다. 여기서는 그 중 3가지 방식을 살펴본다.

그 중 한가지 방식은 명령 인터프리터를 제공하는 것이고, 나머지 두가지 방식은 사용자가 GUI 를 통해 운영체제와 접촉하게 하는 것이다. 

### 2.1 명령 인터프리터_Command-Interpreter

- 선택할 수 있는 명령 인터프리터를 제공하는 시스템에서 해석기를 셸(shell)이라고 부른다.
- 명령어 인터프리터의 중요한 기능은 사용자가 지정한 명령을 가져와서 그것을 수행하는 것이다.

### 2.2 그래픽 기반 사용자 인터페이스_Graphical User Interface

- 이 방식은 명령어 라인 인터페이스를 통해 사용자가 직접 명령을 입력하는 것이 아닌 데스크톱이라 특징지어지는 마우스를 기반으로 하는 윈도 메뉴 시스템을 사용한다.
- 간단히, 마우스 포인터를 통해 아이콘을  클릭함으로써 프로그램을 호출, 선택할 수 있다.

### 2.3 터치스크린 인터페이스_Touch-Screen Interface

- 대부분의 모바일 시스템(스마트폰 및 휴대용 태블릿)에서는 터치스크린 인터페이스를 사용한다.

---

## 3. 시스템 콜_System Calls

시스템 콜은 운영체제에 의해 사용 가능하게 된 서비스에 대한 인터페이스를 제공한다.

### 3.2 응용 프로그래밍 인터페이스_Application Programming Interface

간단한 프로그래밍이라도 운영체제의 기능을 아주 많이 사용하게 되고, 종종 초당 수천개의 시스템 콜을 수행하게 된다.

사용자의 대부분은 이러한 정도의 상세를 잘 알지 못하므로 응용 개발자들은 응용프로그래밍 인터페이스(API)에 따라 프로그래밍을 설계한다.

API는 각 함수에 전달되어야 할 매개변수들과 프로그래머가 기대할 수 있는 반환값을 포함해 응용 프로그래머가 사용 가능한 함수의 집합을 명시한다. API를 구성하는 함수들은 통상 응용 프로그래머를 대신해 실제 시스템 콜을 호출한다.

- 운영체제에 매개변수를 전달하는 방법
    1. 매개변수를 레지스터 내에 전달
    2. 매개변수를 메모리 내의 블록이나 테이블에 저장, 블록의 주소가 레지스터 내에 저장
    3. 매개변수를 블록이나 스택에 저장

### 3.3 시스템 콜의 유형_Types of System Calls

시스템 콜은 다섯 가지의 중요한 법주로 묶을 수 있다.

1. **프로세스 제어(Process Control)**
    - 끝내기(end), 중지(abort)
        - 실행 중인 프로그램은 수행을 정상적으로(`end()`) 또는 비정상적으로(`abort()`) 멈출 수 있어야 한다.
    - 적재(load), 수행(execute)
        - 한 프로그램을 실행하고 있는 프로세스가 다른 프로그램을 적재(`load()`)하고 실행(`execute()`) 하기를 원할 수 있다.
        - 프로그램 종료 시 제어가 기존 프로그램으로 돌아간다면, 반드시 기존 프로그램의 메모리 이미지를 보관해야 한다.
        - 만약 두 프로그램이 병행하게 수행된다면, 다중 프로그래밍 될 새로운 프로세스를 생성한 것이다.
    - 프로세스 생성, 프로세스 종료
        - 새로운 잡이나 프로세스 또는 그들의 집합을 생성한다면, 그들의 실행을 제어할 수 있어야 한다.
        - 새로 생성한 잡이나 프로세스가 잘못되었거나 더 이상 필요 없다면 종료 하기를 원할 수 있다.
    - 프로세스 속성 획득, 설정
        - 잡이나 프로세스 제어에는 잡의 우선순위, 최대 허용 실행 시간 등을 포함해 그들의 속성들을 결정하고 재설정(reset) 할 수 있는 능력이 필요하다.
    - 시간을 기다림(wait time), 이벤트를 기다림(wait event)
        - 새로운 프로세스를 생성한 후 이들의 실행이 끝나기를 기다려야 할 필요가 있을 수 있다.
            - 일정 시간만큼 기다리기(`wait_time()`)
            - 특정 이벤트가 일어날 때까지 기다리기(`wait_event()`), 이 경우 이벤트가 일어나면 신호를 보내야 한다.(`signal_event()`)
    - 메모리 할당 자유화
        - 둘 이상의 프로세스들은 빈번하게 데이터를 공유한다.
        - 공유되는 데이터의 일관성을 보장하기 위해 종종 프로세스가 공유 데이터를 잠글 수 있는 시스템 콜을 제공한다.
        
2. **파일 조작(File Manipulation)**
    - 파일 생성(create file), 삭제(delete file)
        - 파일을 생성(`create()`)하고 삭제(`delete()`) 할 수 있어야 한다.
        - 이 시스템 콜은 파일 이름이나 파일 속성의 일부를 요구한다.
    - 열기(open), 닫기(close)
        - 파일이 생성되면 그것을 열고(`open()`) 사용해야 한다.
    - 읽기, 쓰기, 위치 변경(reposition)
        - 파일이 열린 후 그것을 읽고(`read()`), 쓰고(`write()`), 위치 변경(`reposition()`) 할 수 있다.
    - 파일 속성 획득 및 설정
        - 파일 속성은 파일 이름, 파일 유형, 보호 코드, 회계 정보 등의 정보를 포함한다.
        - 이 기능을 이용하기 위해 최소한 파일 속성 획득(`get_file_attribute()`), 파일 속성 설정(`set_file_attribute()`)의 두 시스템 콜이 필요하다.
        - 파일이나 디렉터리에 대해 여러 속성의 값을 결정할 수 있어야 하고, 필요하다면 재설정 할 수 있어야 한다.
        
3. **장치 조작(Device Management)**
    - 장치 요구(request devices), 방출(release devices)
        - 프로세스는 작업을 계속 수행하기 위해서 추가 자원(주 기억장치, 디스크 드라이브, 파일)을 필요로 할 수 있다.
        - 다수의 사용자가 동시에 사용하는 시스템은 독점적인 장치 사용을 보장받기 위해 그 장치를 요청(`request()`) 해야한다.
        - 장치의 사용이 끝나면 반드시 방출(`release()`)해야 한다.
    - 읽기, 쓰기 위치 변경(reposition)
        - 장치를 요청하고 할당받으면, 읽고(`read()`), 쓰고(`write()`), 위치 변경(`reposition()`)할 수 있다.
        - 입출력 장치와 파일들 간에는 유사성이 매우 많기 때문에 많은 운영체제가 이들 둘을 통합된 **파일-장치 구조(file device structure)**로 결합하였다.
            - 통합된 경우 같은 시스템 콜이 파일과 장치에 대해 사용된다.
    - 장치 속성 획득, 설정
    - 장치의 논리적 부착(attach), 분리(detach)
    
4. **정보 유지 보수(Information Maintenance)**
    - 시간과 날짜의 설정, 획득
        - 시스템 대부분은 현재 시간(`time()`)과 날짜를 되돌려 주는(`date()`) 시스템 콜을 가지고 있다.
    - 시스템 데이터의 설정, 획득
    - 프로세스, 파일, 장치 속성의 획득과 설정
        - 운영체제는 현재 운영되고 있는 모든 프로세스에 관한 정보를 가지고 있고, 이 정보에 접근하기 위한 시스템 콜이 있다.(`get_process_attributes()`, `set_process_attributes()`)
        
5. **통신(Communication)**
- 통신 모델에는 메시지 전달과 공유 메모리의 두 가지 일반적인 모델이 있다.
    1. 메시지 전달 모델
        - 통신하는 두 프로세스가 정보를 교환하기 위해 서로 메시지를 주고받는다.
        - 메시지는 두 프로세스 간 직접 교환되거나 우편함을 통해 간접적으로 교환될 수 있다.
    2. 공유 메모리 모델
        - 프로세스는 다른 프로세스가 소유한 메모리 영역에 대한 접근을 위해 `shared_memory_create()`, `shared_memory_attach()` 시스템 콜을 사용한다.
        - 정상적으로, 운영체제는 한 프로세스가 다른 프로세스의 메모리에 접근하는 것을 막는다. 공유 메모리는 두 개 이상의 프로세스가 이러한 제한을 제거하는 데 동의할 것을 필요로 한다.
- 통신 연결 생성, 제거
- 메시지 송신, 수신
- 상태 정보 전달
- 원격 장치의 부착(attach) 및 분리(detach)

1. **보호(Protection)**
    - 보호는 컴퓨터 시스템이 제공하는 자원에 대한 접근을 제어하기 위한 기법을 지원한다.
    - get file permissions(`set_permission()`, `get_permission()`)
    - set file permissions(`allow_user()`, `deny_user()`)

---

## 4. 시스템 서비스_System Services

시스템 서비스는 시스템 유틸리티로도 알려진, 프로그램 개발과 실행을 위해 더 편리한 환경을 제공한다.

그들 중 몇몇은 단순히 시스템 콜에 대한 사용자 인터페이스(API)이며, 반면에 나머지는 훨씬 더 복잡하며, 다음 범주로 분류할 수 있다.

- 파일 관리
- 상태 정보
- 파일 변경
- 프로그래밍언어 지원
- 프로그램 적재와 수행
- 통신
- 백그라운드 서비스

---

## 5. 링크와 로더_Linkes and Loaders

일반적으로 프로그램은 디스크에 이진 실행 파일로 존재하며, CPU에서 실행 하려면 프로그램을 메모리로 가져와 프로세스 형태로 배치 되어야 한다.

- 소스 파일은 임의의 물리 메모리 위치에 적재되도록 설계된 오브젝트 파일로 컴파일 된다. 이러한 형식을 **재배치 가능 오브젝트** 파일 이라고 한다.
- **링커**는 재배치 가능 오브젝트 파일을 하나의 이진 실행파일로 결합한다.
- **로더**는 이진 실행 파일을 메모리에 적재하는 데 사용되며, CPU 코어에서 실행할 수 있는 상태가 된다.

---

## 8. 운영체제 구조_OS Structures

### 1. 모놀리식 구조_Monolithic Structure

- 운영체제를 구성하는 가장 간단한 구조는 구조가 아예 없는 것이다. 즉, 커널의 모든 기능을 단일 주소 공간에서 실행되는 단일 정적 이진파일에 넣는 것이다.
- 모놀리식 구조라고 하는 이 방법은 운영체제를 설계하는 일반적인 기술이다.
- 모놀리식 커널의 명백한 단순성에도 불구하고, 이 구조는 구현 및 확장하기 어렵다.
- 그러나 성능면에서 시스템 콜 인터페이스에는 오버헤드가 거의 없고 커널 안에서의 통신 속도가 빠르다는 장점이 있다.

### 2. 계층적 접근_Layered Approach

![Untitled 1](https://user-images.githubusercontent.com/75190035/173273997-13dc20c3-97ba-4414-b0a5-d53cda8fbb61.png)

- 시스템을 모듈화 시키는 방법 중 계층적 접근 방식에서 운영체제는 여러 개의 층으로 나누어 진다.
- 최하위 층은(Layer 0) 하드웨어, 최상위 층은 (Layer N)은 사용자 인터페이스다.
- 전형적인 운영체제 층(Layer M)은 자료구조와 상위층에서 호출할 수 있는 루틴의 집합으로 구성된다.
- Layer M은 다시 하위층에 대한 연산을 호출할 수 있다.
- 계층적 접근 방식의 주된 장점은 구현과 디버깅의 간단함에 있다.
    - Layer 들은 단지 자신의 하위층들의 서비스와 기능들만 사용하도록 선택되며, 이러한 접근 방법이 시스템의 **검증과 디버깅 작업을 단순화**한다.
    - 하위 층부터 구현을 시도하고, 완벽히 디버깅이 끝난 뒤에 상위 층의 구현을 시도한다.
    - 각 층은 자신보다 하위 수준의 층에 의해 제공된 연산들만 사용해 구현한다. 상위 층은 이러한 연산들의 구현을 알 필요가 없고, 기능만 알면 된다.
    - 그러므로 각 층은 특정 데이터 구조, 연산, 하드웨어의 존재를 상위층에 숨기게 된다.
- 계층적 접근 방식에서 각 계층의 기능을 적절히 정의해야 하는 문제는 어렵다.
    - 상위층은 하위층의 연산만 사용하기 때문에 설계 시 신중하게 고려해야 한다.

### 3. 마이크로커널_Microkernals

![Untitled 2](https://user-images.githubusercontent.com/75190035/173274017-608b06c7-47b5-4d8d-93aa-b0b3feae20b9.png)

- 마이크로커널 방법은 모든 중요치 않은 구성요소를 커널로 부터 제거하고, 그들을 별도의 주소 공간에 존재하는 사용자 수준 프로그램으로 구현해 운영체제를 구성하는 방법이다.
- 마이크로커널의 주 기능은 클라이언트 프로그램과 사용자 공간에서 수행하는 다양한 서비스 간에 통신을 제공하는 것이다. 이때 통신은 메시지 전달 방법으로 전달된다.
- 마이크로커널은 확장이 쉽다.
    - 모든 새로운 서비스는 사용자 공간에 추가되므로 커널을 변경할 필요가 없다.
    - 만약 변경되어야 한다면, 마이크로커널이 작은 커널이기 때문에 변경할 대상이 비교적 작다.
- 마이크로커널은 서비스 대부분이 커널이 아닌 사용자 프로세스로 수행되기 때문에 더욱 높은 보안성과 신뢰성을 보장한다.
    - 만일 한 서비스가 잘못되어도 운영체제의 다른 부분은 아무런 영향을 받지 않는다.
- 마이크로커널은 가중된 시스템 기능 오버헤드 때문에 성능이 나빠진다.

### 4. 모듈_Modules

- 운영체제를 설계하는 데 이용되는 기술 중 최선책은 적재가능 커널 모듈(loadable kernel modules,LKM)기법의 사용일 것이다.
- 여기서 커널은 핵심적인 구성요소의 집합을 가지고 있고 부팅 떄 또는 실행 주에 부가적인 서비스들을 모듈을 통해 링크할 수 있다.
- 설계의 주안점은 커널은 핵심 서비스를 제공, 다른 서비스들은 커널이 실행되는 동안 동적으로 구현하는 것이다.
- 전체적인 결과는 커널의 각 부분이 정의되고 보호된 인터페이스를 가진다는 점에서 계층 구조를 닮았다. 그러나 모듈에서 임의의 다른 모듈을 호출할 수 있다는 점에서 더 유연하다.
- 중심 모듈은 단지 핵심 기능만을 가지고 있고 다른 모듈의 적재 방법과 모듈들과 통신하는지 안다는 점에서 마이크로 커널과 유사하다. 그러나 통신을 위해 메시지 전달을 호출할 필요가 없기 때문에 더 효율적이다.

### 5. 하이브리드 시스템_Hibrid Systems

보통 운영체제는 하나의 구조만을 택하지 않고, 다양한 구조를 결합하여 성능, 보안 및 편리성 문제를 해결하려는 혼용 구조로 구성된다.

- **Linux**
    - 운영체제 전부가 하나의 주소 공간에 존재하여 효율적인 성능을 제공하므로 모놀리식 구조다.
    - 그러나 이 운영체제들은 모듈을 사용하기 떄문에 새로운 기능을 동적으로 커널에 추가할 수 있다.

---

> 참고
> 
> - 책
> 
> [⌜Operating System Concepts 10th - Abraham Silberschatz, Peter B. Galvin, Greg Gagne⌟](http://www.yes24.com/Product/Goods/78225791)
> 
> - 블로그
> 
> [https://parksb.github.io/article/6.html](https://parksb.github.io/article/6.html)
> 
> [https://blog.naver.com/bisu1532/221612466313](https://blog.naver.com/bisu1532/221612466313)
> 
> [https://suhwanc.tistory.com/176?category=879656](https://suhwanc.tistory.com/176?category=879656)
>
