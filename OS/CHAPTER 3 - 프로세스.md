# CHAPTER 3 - 프로세스

초기의 컴퓨터 시스템은 한 번에 하나의 프로그램만을 실행하도록 허용하였지만, 오늘날은 다수의 프로그램이 메모리에 적재되어 병행 실행 되는 것을 허용한다. 이런 발전은 프로그램을 보다 견고하게 제어하고 보다 구획화 할 것을 필요로 했고, 이 필요성이 프로세스의 개념을 낳았다.

프로세스란 실행 중인 프로그램을 말한다.

## 1. 프로세스 개념_Process Concept

### 1.1 프로세스_The Process

비공식적으로, 프로세스란 실행 중인 프로그램이다. 프로세스의 현재 활동의 상태는 프로그램 카운터(PC) 값과 프로세서 레지스터의 내용으로 나타낸다.

- 프로세스의 메모리 배치는 일반적으로 여러 섹션으로 구분된다.
    - 텍스트 섹션 - 실행 코드
    - 데이터 섹션 - 전역 변수
    - 힙 섹션 - 프로그램 실행 중에 동적으로 할당되는 메모리
    - 스택 섹션 - 함수를 호출할 때 임시 데이터 저장장소(예: 함수 매개변수, 복귀 주소 및 지역 변수)
    - 각 섹션 별 특징
        - 텍스트 및 데이터 섹션의 크기는 고정되기 때문에 프로그램 실행 시간 동안 크기가 변하지 않는다.
        - 스택 및 힙 섹션은 프로그램 실행 중에 동적으로 줄어들거나 커질 수 있다.
            - 함수가 호출될 때마다 함수 매개변수, 지역 변수 및 복귀 주소를 포함하는 활성화 레코드가 스택, 힙에 푸시(`push`)된다.
            - 함수에서 제어가 되돌아오면 스택, 힙에서 활성화 레코드가 팝(`pop`)된다.
            - 스택, 힙 섹션이 서로의 방향으로 커지더라도 운영체제는 서로 겹치지 않도록 해야 한다.
- 프로그램 그 자체는 프로세스가 아니다.
    - **프로그램**은 명령어 리스트를 내용으로 가진 디스크에 저장된 파일과 같은 **수동적인 존재**
    - **프로세스**는 다음에 실행할 명령어를 지정하는 프로그램 카운터와 관련 자원의 집합을 가진 **능동적인 존재**
    - 실행 파일이 메모리에 적재될 때(아이콘 클릭 등) 프로그램은 프로세스가 된다.

### 1.2 프로세스 상태_Process State

프로세스는 실행 되면서 그 상태가 변한다. 프로세스의 상태는 부분적으로 그 프로세스의 현재의 활동에 따라서 정의된다. 

- 프로세스는 다음 상태 중 하나에 있게 된다.
    - 새로운(new): 프로세스가 생성 중이다.
    - 실행(running): 명령어들이 실행되고 있다.
    - 대기(waiting): 프로세스가 어떤 이벤트가 일어나기를 기다린다.
    - 준비(ready): 프로세스가 처리기에 할당되기를 기다린다.
    - 종료(terminated): 프로세스의 실행이 종료되었다.
- 이들의 이름은 임의적이지만, 이들이 나타내는 상태는 모든 시스템에서 찾아볼 수 있다.
- 어느 한순간에 한 처리기 코어에서는 오직 하나의 프로세스만이 실행된다.

### 1.3 프로세스 제어 블록_Process Control Block

각 프로세스는 운영체제에서 프로세스 제어 블록(process Control block, PCB)에 의해 표현된다.

- 프로세스 제어 블록은 특정 프로세스와 연관된 여러 정보를 수록하며, 다음을 포함한다.
    - 프로세스 상태
        - 상태는 new, ready, running, wating, halted 등이다.
    - 프로그램 카운터
        - 해당 프로세스가 다음에 실행할 명령어의 주소를 가리킨다.
    - CPU 레지스터(들)
        - 컴퓨터 구조에 따라 다양한 수, 유형의 레지스터를 가진다.
            - 레지스터에는 누산기, 인덱스 레지스터, 스택 레지스터, 범용 레지스터들과 상태 코드 정보가 포함된다.
        - 프로세스가 다시 스케줄 될 때 계속 올바르게 실행되도록 하기 위해서 인터럽트 발생 시 저장되어야 한다.
    - CPU-스케줄링 정보
        - 프로세스 우선순위, 스케줄 큐에 대한 포인터와 다른 스케줄 매개변수를 포함한다.
    - 메모리 관리 정보
        - 운영 체제에 의해 사용되는 메모리 시스템에 따라 기준 레지스터와 한계 레지스터의 값, 페이지 테이블, 세그먼트 테이블 등과 같은 정보가 포함된다.
    - 회계 정보
        - CPU 사용 시간, 경과된 실시간, 시간 제한, 계정 번호, 잡 또는 프로세스 번호 등을 포함한다.
    - 입출력 상태 정보
        - 프로세스에 할당된 입출력 장치들과 열린 파일의 목록 등을 포함한다.

### 1.4 스레드_Threads

이전의 프로세스 모델은 프로세스가 단일 실행 스레드를 실행하는 프로그램이라 가정한다.

대부부느이 현대 운영체제는 프로세스 개념을 확장하여 한 프로세스가 다수의 실행 스레드를 가질 수 있도록 허용한다. 따라서 프로세스가 한 번에 하나 이상의 일을 수행할 수 있도록 허용한다.

---

## 2. 프로세스 스케줄링_Process Scheduling

다중 프로그래밍의 목적은 CPU 이용을 최대화 하기 위해 항상 어떤 프로세스가 실행되도록 하는 데 있다.

시분할의 목적은 각 프로그램이 실행되는 동안 사용자가 상호 작용할 수 있도록 프로세스들 사이에서 CPU 코어를 빈번하게 교체하는 것이다.

이 목적을 달성하기 위해 **프로세스 스케줄러**는 코어에서 실행 가능한 여러 프로세스 중에서 하나의 프로세스를 선택하며, 현재 메모리에 있는 프로세스 수를 다중 **프로그래밍 정도(degree of multiprogramming)**라고 한다.

### 2.1 스케줄링 큐_Scheduling Queue

![Untitled](https://user-images.githubusercontent.com/75190035/173561375-7b54ece2-51e8-4bf9-8300-3afeee975849.png)

- 잡 큐(job queue): 보조기억장치(하드디스크)에 있는 프로세스가 메모리로 올라가기 위해 대기하는 곳이다.
- 준비 큐(ready queue): 프로세스가 시스템에 들어가면 준비 큐에 들어가서 준비 상태가 되어 CPU 코어에서 실행되기를 기다린다.
    - 준비 큐(ready queue)는 일반적으로 연결 리스트로 저장된다.
- 대기 큐(waiting queue): 장치는 프로세서보다 매우 느리게 실행되므로 프로세스는 I/O가 사용 가능할 때까지 기다려야 한다. I/O 완료와 같은 특정 이벤트가 발생하기를 기다리는 프로세스는 대기 큐(waiting queue)에 삽입된다.
- 각 큐 내부에 저장된 실제 데이터는 각 프로세스의 **PCB**가 저장되어 있다. 그리고 이러한 순서를 기다리는 공간이 있다면 이 순서를 정해주는 알고리즘이 있어야 한다. 이러한 알고리즘을 **스케줄링(Scheduling)**이라 한다.

### 2.2 CPU 스케줄링_CPU Scheduling

---

> 참고
> 
> - 책
> 
> [⌜Operating System Concepts 10th - Abraham Silberschatz, Peter B. Galvin, Greg Gagne⌟](http://www.yes24.com/Product/Goods/78225791)
> 
> - 블로그
> 
> [https://blog.naver.com/bisu1532/221612466313](https://suhwanc.tistory.com/177?category=879656)
> 
> [https://suhwanc.tistory.com/176?category=879656](https://suhwanc.tistory.com/177?category=879656)
> 
> [https://velog.io/@codemcd/운영체제OS-5.-프로세스-관리](https://velog.io/@codemcd/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9COS-5.-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B4%80%EB%A6%AC)
>
