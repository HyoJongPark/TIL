# CHAPTER 5 - CPU 스케줄링

## 1. 기본 개념_Basic Concepts

다중 프로그래밍의 목적은 CPU 이용률을 최대화하기 위해 항상 실행 중인 프로세스를 가지게 하는 데 있다.

### 1.1 CPU-I/O 버스트 사이클_CPU-I/O Burst Cycle

<img width="296" alt="Untitled" src="https://user-images.githubusercontent.com/75190035/174577908-431a24bf-b64c-405e-8dbd-ca60b6d5b01e.png">

- 프로세스 실행은 CPU 실행과 I/O 대기의 사이클로 구성된다. 프로세스들은 이들 두 상태 사이를 교대로 왔다 갔다 한다.
- 프로세스 실행은 CPU 버스트로 시작되고, 뒤이어 I/O 버스트가 발생한다. 그 뒤로 이 사이클이 반복된다.
- 마지막 CPU 버스트는 I/O 버스트가 뒤따르는 대신, 실행을 종료하기 위한 시스템 요청과 함께 끝난다.

### 1.2 CPU 스케줄러_CPU Scheduler

- CPU가 유휴 상태가 될 때마다, 운영체제는 준비 큐에 있는 프로세스 중에서 하나를 선택해 실행해야 한다.
- 이때, 선택 절차가 CPU 스케줄러에 의해 실행된다.
- 스케줄러는 실행 준비 되어 있는 메모리 내의 프로세스 중 하나를 선택해 CPU를 할당한다.
    - 준비 큐는 FIFO 방식이 아니어도 된다.(선입선출 큐, 우선순위 큐 또는 단순히 순서가 없는 연결 리스트로 구현할 수 있다.)

### 1.3 선점 및 비선점 스케줄링_Preemptive and Nonpreemptive Scheduling

- CPU 스케줄링 결정은 다음 4 가지 상황에서 발생할 수 있다.
    1. 한 프로세스가 실행 상태에서 대기 상태로 전환될 때
    2. 프로세스가 실행 상태에서 준비 완료 상태로 전환될 때
    3. 프로세스가 대기 상태에서 준비 완료 상태로 전환될 때
    4. 프로세스가 종료할 때
- 상황 1과 4의 경우, 스케줄링 면에서는 선택의 여지가 없으며, 실행을 위해 새로운 프로세스가 반드시 선택되어야 한다. 상황 2와 3의 경우 선택의 여지가 있다.
- 상황 1, 4에서만 스케줄링이 발생할 경우, 우리는 이러한 스케줄링 방법을 비선점(nonpreemptive) 또는 협조적(cooperative)이라고 하고, 그렇지 않으면 선점(preemptive)이라고 한다.
- **비선점**
    - CPU가 한 프로세스에게 할당되면 프로세스가 종료하든지, 또는 대기 상태로 전환해 CPU를 방출할 때까지 점유한다.
- **선점**
    - 한 프로세스가 CPU를 할당받아 실행중이라도 다른 프로세스가 현재 프로세스를 중지 시키고 CPU를 강제적으로 뺏을 수 있다.
    - 데이터가 다수의 프로세스에 의해 공유될 때 경쟁 조건을 초래할 수 있다.

### 1.4 디스패처_DIspatcher

<img width="195" alt="Untitled 1" src="https://user-images.githubusercontent.com/75190035/174577930-0f4476f3-34c1-4e14-a859-c86a05f2aa9e.png">

- 디스패처는 CPU 코어의 제어를 CPU 스케줄러가 선택한 프로세스에 주는 모듈이며 다음과 같은 작업을 포함한다.
    - 한 프로세스에서 다른 프로세스로 문맥을 교환하는 일
    - 사용자 모드로 전환하는 일
    - 프로그램을 다시 시작하기 위해 사용자 프로그램의 적절한 위치로 이동(jump)하는 일
- 디스패처는 모든 프로세스의 문맥 교환 시 호출되므로, 가능한 최고로 빨리 수행되어야 한다.
- 디스패처가 하나의 프로세스를 정지하고 다른 프로세스의 수행을 시작하는 데까지 소요되는 시간을 디스패치 지연(dispatch latency)라고 한다.

---

## 2. 스케줄링 기준_Scheduling Criteria

CPU 스케줄링 알고리즘을 비교하기 위한 여러 기준

- CPU 이용률(utilization)
    - 가능한 한 CPU를 최대한 바쁘게 유지하기를 원한다.
    - 실제 시스템에서는 40%(부하가 적은 시스템의 경우)~90%(부하가 큰 시스템의 경우) 범위를 가져야 한다.
- 처리량(throughput)
    - 작업량 측정의 한 방법으로, 단위 시간당 완료된 프로세스의 개수를 처리량이라고 한다.
- 총 처리 시간(turnaround time)
    - 특정한 프로세스의 입장에서 중요한 기준은 그 프로세스를 실행하는 데 소요된 시간이다.
    - 프로세스의 제출 시간과 완료 시간의 간격을 총 처리 시간이라 한다.
    - 총 처리 시간은 준비 큐에서 대기한 시간, CPU에서 실행하는 시간, I/O 시간을 합한 시간이다.
- 대기 시간(waiting time)
    - CPU 스케줄링 알고리즘은 프로세스가 실행하거나 I/O을 하는 시간의 양에 영향을 미치지 않는다. 단지 프로세스가 준비 큐에서 대기하는 시간의 양에만 영향을 준다.
    - 준비 큐에서 대기하면서 보낸 시간의 합을 대기 시간이라 한다.
- 응답 시간(response time)
    - 대화식 시스템(interactive system)에서 총 처리 시간은 최선의 기준이 아닐 수 있다. 프로세스가 어떤 출력을 일찍 생성하고, 앞서의 결과가 출력되는 사이 새 결과를 얻으려고 연산을 계속하는 경우가 있다.
    - 하나의 요구를 제출한 후 첫 번째 응답이 나올 때까지의 시간을 응답 시간이라 한다.
    - 응답 시간은 응답이 시작되는 데까지 걸리는 시간이지, 그 응답을 출력하는 데 걸리는 시간은 아니다.

---

## 3. 스케줄링 알고리즘_Scheduling Algorithms

CPU 스케줄링은 준비 큐에 있는 프로세스 중 어느 프로세스에 CPU 코어를 할당할 것인지를 결정하는 문제를 다룬다.

### 3.1 선입 선처리 스케줄링_First-Served Scheduling

- 가장간단한 CPU 스케줄링 알고리즘(비선점)
- CPU를 가장 먼저 요청하는 프로세스가 CPU를 먼저 할당받는다.
- 선입 선처리 정책의 구현은 선입선출(FIFO) 큐로 쉽게 관리할 수 있고, 프로세스가 준비 큐에 진입하면 이 프로세스의 프로세스 제어 블록(PCB)을 큐의 끝에 연결한다.
- CPU가 가용 상태가 되면, 준비 큐의 앞부분에 있는 프로세스에 할당되고, 해당 프로세스는 준비 큐에서 제거된다.
- 장점
    - 선입 선처리를 위한 코드는 작성하기 쉽고 이해하기 쉽다.
- 단점
    - 선입 선처리 정책하에서 평균대기 시간은 일반적으로 최소가 아니며, 프로세스 CPU 버스트 시간이 크게 변할 경우에는 평균대기 시간도 상당히 변할 수 있다.

다음과 같은 프로세스들이 대기 큐에 있다고 가정해보자.

| 프로세스 | 버스트 시간(ms) |
| --- | --- |
| P1 | 24 |
| P2 | 3 |
| P3 | 3 |

선입 선처리 알고리즘은 들어온 순서대로 CPU를 할당하므로, 다음 그림과 같을 것이다.

<img width="463" alt="Untitled 2" src="https://user-images.githubusercontent.com/75190035/174577948-4b60e968-ad53-4da7-afb8-5f334923cea7.png">

이때, 평균 대기 시간은 17ms 정도로 최소가 아니다.

이렇게 모든 프로세스들이 하나의 긴 프로세스가 CPU를 양도하기를 기다리는 것을 **호위 효과(convoy effect)**라고 한다.

### 3.2 최단 작업 우선 스케줄링_Shortest-Job-First Scheduling(SJF)

- 이 알고리즘은 각 프로세스에 다음 CPU 버스트 길이를 연관시킨다.(선점형이거나 비선점형)
- CPU 이용이 가능해지면, 가장 작은 다음 CPU 버스트를 가진 프로세스에 할당한다. 만약 같은 길이를 가질 때는 선입 선처리 스케줄링을 적용한다.
- 장점
    - 최단 작업 우선 스케줄링은 주어진 프로세스 집합에 대해 최소의 평균 대기시간을 가진다는 점에서 최적임을 증명할 수 있다.
- 단점
    - 최단 작업 우선 스케줄링은 최적이긴 하지만, CPU 버스트 길이를 알 방법이 없기 때문에 CPU 스케줄링 수준에서는 구현할 수 없다. 즉, 비현실적이다.
- **도착 시간을 고려하지 않은** **최단 작업 우선 스케줄링(비선점형)**

다음과 같은 프로세스들이 준비 큐에 있다고 가정해 보자. 비선점형일 경우 결과는 다음과 같다.

| 프로세스 | 버스트 시간(ms) |
| --- | --- |
| P1 | 6 |
| P2 | 8 |
| P3 | 7 |
| P4 | 3 |

최단 작업 우선 스케줄링을 이용하면 가장 작은 버스트 시간을 기준으로 CPU 를 할당하기 때문에 다음의 그림과 같다.

<img width="471" alt="Untitled 3" src="https://user-images.githubusercontent.com/75190035/174577959-28bdf23c-590c-4496-9656-733508cf193d.png">

이때, 평균 대기시간은 9ms이고, 최소의 평균 대기시간을 가진다.

- **도착시간을 고려한** **최단 작업 우선 스케줄링(선점형)**

다음과 같은 프로세스들이 준비 큐에 있다고 가정해 보자. 선점형일 경우 결과는 다음과 같다.

| 프로세스 | 도착시간(ms) | 버스트 시간(ms) |
| --- | --- | --- |
| P1 | 0 | 6 |
| P2 | 1 | 8 |
| P3 | 2 | 7 |
| P4 | 3 | 3 |

프로세스가 도착할 때 새로운 선택이 발생한다. 새로운 프로세스가 현재 실행되고 있는 프로세스의 남은 시간보다도 더 짧은 CPU 버스트를 가진다면 새로운 프로세스에 CPU를 할당한다.

만약 비선점형이라면, 현재 실행하고 있는 프로세스가 끝날 때 까지 기다려야 하므로 동작 방식이 다르다.

<img width="467" alt="Untitled 4" src="https://user-images.githubusercontent.com/75190035/174577974-441b6ac4-dd70-44d1-a679-2d36af5fa957.png">

이때, 평균 대기시간은 6.5ms이다.

### 3.3 라운드 로빈 스케줄링_Round-Robin Scheduling

- 이 알고리즘은 선입 선처리 스케줄링과 유사하지만 시스템이 프로세스들 사이를 옮겨다닐 수 있도록 선점이 추가된다.(선점형)
    - 시간 할당량 또는 타임슬라이스라고 하는 작은 단위의 시간을 정의한다.
    - 시간 할당량은 일반적으로 10~100ms 동안이다.
- CPU 스케줄러는 준비 큐를 돌면서 한 번에 한 프로세스에 한 번의 시간 할당량 동안 CPU를 할당한다.
- 프로세스의 CPU 버스트가 시간 할당량보다 작을 경우, 프로세스 자신이 CPU를 자발적으로 방출할 것이다. 그 후 준비 큐에 있는 다음 프로세스가 CPU를 할당받는다.
- 프로세스의 CPU 버스트가 시간 할당량보다 긴 경우, 타이머가 끝나고 운영체제에 인터럽트를 발생한다. 문맥 교환이 일어나고, 실행하던 프로세스는 준비 큐의 꼬리에 넣어진다. 그 후 준비 큐에 다음 프로세스가 CPU를 할당받는다.
- 특징
    - 시간 할당량의 크기에 매우 많은 영향을 받는다. 시간 할당량이 매우 크다면 선입 선처리 정책과 같다.
    - 시간 할당량이 매우 작다면 매우 많은 문맥 교환을 야기하므로 프로세스의 실행이 느려진다.
    - 따라서 시간 할당량이 문맥 교환 시간과 비교해 더 클 것을 요구한다.

다음과 같은 프로세스들이 준비 큐에 있다고 가정해 보자. (할당 시간=4ms)

| 프로세스 | 버스트 시간(ms) |
| --- | --- |
| P1 | 24 |
| P2 | 3 |
| P3 | 3 |

라운드 로빈 알고리즘은 들어온 순서대로 CPU를 할당하고, 할당 시간이 끝나면 다음 프로세스에 CPU를 할당하므로 결과는 다음과 같다.

<img width="473" alt="Untitled 5" src="https://user-images.githubusercontent.com/75190035/174577989-26163ee2-6a09-4189-a3e4-90e7b809c2b5.png">

이때, 평균 대기시간은 5.66ms다.

---

### 3.4 우선순위 스케줄링_Priority Scheduling

- 최단시간 우선 스케줄링은 일반적인 우선순위 스케줄링 알고리즘의 특별한 경우다.(선점형 or 비선점형)
- 우선순위가 각 프로세스들에 연관되어 있으며, CPU는 가장 높은 우선순위를 가진 프로세스에 할당된다. 우선순위가 같은 프로세스들은 선입 선처리 순서로 스케줄링 된다.
- 우선순위는 내부적 또는 외부적으로 정의될 수 있다.
    - 내부적인 경우, 프로세스의 우선순위를 계산하기 위해 어떤 측정 가능한 양들을 사용한다.
        - 시간 제한, 메모리 요구, 열린 파일의 수, 평균 I/O 버스트의 평균 CPU 버스트에 대한 비율 등
    - 외부적인 경우 운영체제 외부적 기준에 의해 결정된다.
        - 프로세스의 중요성, 컴퓨터 사용을 위해 지불되는 비용의 유형과 양, 그 작업을 후원하는 부서 그리고 정치적 요인 등
- 문제점
    - 무한 봉쇄(indefinite blocking), 기아 상태(starvation)
        - 우선순위 스케줄링 알고리즘을 사용할 경우 낮은 우선순위 프로세스들이 CPU를 무한히 대기하는 경우가 발생한다.
        - 높은 우선순위의 프로세스들이 꾸준히 들어와서 낮은 우선순위의 프로세스들이 CPU를 얻지 못하게 될 수도 있다.
    - 프로세스가 결국 실행되거나 컴퓨터 시스템이 결국 크래시하여 아직 끝나지 않은 우선순위가 낮은 프로세스들을 잃어버린다.
- 해결책
    - 노화(aging)
        - 노화는 오랫동안 시스템에서 대기하는 프로세스들의 우선순위를 점진적으로 증가시킨다.
    - 라운드 로빈과 우선순위 스케줄링의 결합
        - 시스템이 우선순위가 가장 높은 순서대로 실행하되, 우선순위가 같은 프로세스들은 라운드 로빈 스케줄링을 사용한다.

다음과 같은 프로세스들이 준비 큐에 있다고 가정해 보자. (우선순위 숫자가 낮을 수록 우선순위가 높다고 가정)

| 프로세스 | 버스트 시간(ms) | 우선 순위 |
| --- | --- | --- |
| P1 | 10 | 3 |
| P2 | 1 | 1 |
| P3 | 2 | 4 |
| P4 | 1 | 5 |
| P5 | 5 | 2 |

우선순위 스케줄링은 우선순위에 따라 CPU를 할당하기 때문에 결과는 다음과 같다.

<img width="472" alt="Untitled 6" src="https://user-images.githubusercontent.com/75190035/174578003-de61316c-76b0-482c-9533-f1c41149222f.png">

이때, 평균 대기시간은 8.2ms다.

### 3.5 다단계 큐 스케줄링_Multilevel Queue Scheduling

- 우선순위와 라운드 로빈은 스케줄링을 사용할 때 모든 프로세스가 단일 큐에 배치되고 스케줄러는 우선순위가 가장 높은 프로세스를 선택하여 실행할 수 있다. 이때, 우선순위 검색을 위해 O(n) 검색이 필요할 수 있다.
- 다단계 큐 방식은 우선순위 혹은 프로세스 유형에 따라 별도의 큐를 갖게하는 방법이다.
- 각 큐에는 자체 스케줄링 알고리즘이 있을 수 있다.
- 큐와 큐 사이에 스케줄링도 반드시 있어야 한다. 일밙거으로 고정 우선순위의 선점형 스케줄링으로 구현된다.

### 3.6 다단계 피드백 큐 스케줄링_Multilevel Feedback Queue Scheduling

- 다단계 큐 스케줄링 알고리즘에서는 일반적으로 프로세스들이 시스템 진입 시에 영구적으로 하나의 큐에 할당된다.
- 다단계 피드백 큐 스케줄링에서는 프로세스가 큐들 사이를 이동하는 것을 허용한다.
- 예)
    - 어떤 큐가 CPU 시간을 너무 많이 사용하면, 우선순위가 낮은 큐로 이동한다.
    - 어떤 큐가 낮은 우선순위 큐에서 너무 오래 대기하는 프로세스는 높은 우선순위 큐로 이동할 수 있다.
    - 이런 형태로 기아 상태를 예방한다.

---

## 4. 스레드 스케줄링_Thread Scheduling

대부분 최신 운영체제에서 스케줄 되는 대상은 프로세스가 아닌 커널 수준 스레드다.

### 4.1 경쟁 범위_Contention Scope

- 동일한 프로세스에 속한 스레드들 사이에서 CPU를 경쟁하면, 프로세스-경쟁-범위(PCS)라 한다.
- CPU상에서 어느 커널 스레드를 스케줄 할 것인지 결정하기 위해서 커널은 시스템-경쟁-범위(SCS)를 사용한다.

---

## 5. 다중 처리기 스케줄링_Multiple-Processor Scheduling

만일 여러 CPU가 사용 가능하다면, 여러 스레드가 병렬로 실행될 수 있으므로 부하 공유(load sharing이 가능해지지만, 스케줄링 문제는 그에 상응해 더 복잡해진다.

### 5.1 다중 처리기 스케줄링에 대한 접근 방법

- 비대칭 다중 처리(asymmetric multiprocessing)
    - 다중 처리기 시스템의 CPU 스케줄링에 관한 한 가지 해결 방법은 마스터 서버라는 하나의 처리기가 모든 스케줄링 결정과 I/O 처리 그리고 다른 시스템의 활동을 취급하게 되는 것이다.
        
        다른 처리기들은 사용자 코드만을 수행한다. 이러한 비대칭 다중 처리는 오직 하나의 코어만 시스템 자료구조에 접근해 자료 공유의 필요성을 배제하기 때문에 간단하다.
        
    - 단점은 마스터 서버가 전체 시스템 성능을 저하할 수 있는 병목이 된다는 것이다.
- 대칭 다중 처리(symmetric multiprocessing)
    - 다중 처리기를 지원하기 위한 표준 접근 방식이다.
    - 각 프로세서는 스스로 스케줄링 할 수 있다. 각 프로세서의 스케줄러가 준비 큐를 검사하고 실행할 스레드를 선택하여 스케줄링이 진행된다.

### 5.2 다중 코어 프로세서_Multicore Processors

- 현대 컴퓨터 하드웨어는 동일한 물리적인 칩 안에 여러 개의 처리 코어를 장착하여 다중 코어 프로세서(multicore processor)가 된다.
- 각 코어는 구조적인 상태를 유지하고 있어서 운영체제 입장에서는 개별적인 논리적 CPU처럼 보이게 된다.
- 다중 코어 프로세서를 사용하는 SMP 시스템은 CPU가 자신의 물리 칩을 가지는 시스템에 비해 속도가 빠르고 적은 전력을 소모한다.
---

> 참고
> 
> - 책
> 
> [⌜Operating System Concepts 10th - Abraham Silberschatz, Peter B. Galvin, Greg Gagne⌟](http://www.yes24.com/Product/Goods/78225791)
> 
> - 블로그
> 
> [https://blog.naver.com/bisu1532/221617575362](https://blog.naver.com/bisu1532/221617575362)
> 
> [https://suhwanc.tistory.com/179?category=879656](https://suhwanc.tistory.com/179?category=879656)
>
