# CHAPTER 6 - 동기화 도구들

## 1. 배경_Background

- 동시에 여러 개의 프로세스가 동일한 자료를 접근해 조작하고, 그 실행 결과가 접근이 발생한 특정 순서에 의존하는 상황을 경쟁 상황(race condition)이라고 한다.
- 경쟁 상황으로부터 보호하기 위해, 한 순간에 하나의 프로세스만이 변수를 조작하도록 보장해야 한다. 따라서 협력하는 프로세스들 간의 프로세스 동기화는 중요하다.

---

## 2. 임계구역 문제_The Critical-Section Problem

- 두개 이상의 쓰레드에서 사용하는 공통 변수를 업데이트하는 구간을 **임계구역** 이라고 한다.
- 각 프로세스는 임계구역이라고 부르는 코드 부분을 포함하고 있고, 그 안에서는 적어도 하나 이상의 다른 프로세스와 공유하는 데이터에 접근하고 갱신할 수 있다.
- 이 시스템에서 두 프로세스는 동시에 그들의 임계구역 안에서 실행할 수 없다.
- **임계구역 문제**는 프로세스들이 데이터를 협력적으로 공유하기 위해 자신들의 활동을 동기화할 때 사용할 수 있는 프로토콜을 설계하는 것이다.
- 각 프로세스는 자신의 임계구역으로 진입하려면 진입 허가 요청을 해야한다. 이 요청을 구현하는 코드 부분을 **진입 구역**(entry section)이라고 하고, 그 뒤에는 **퇴출 구역**(exit section)이 있을 수 있다.
    - 코드의 나머지 부분을 통칭해 **나머지 구역**(remainder section)이라 부른다.
- 임계구역 문제에 대한 해결책
    1. **상호 배제**(mutual exclusion)
        - 한 프로세스가 자기의 임계구역에서 실행된다면 다른 프로세스들은 임계구역에서 실행될 수 없다.
    2. **진행**(progress)
        - 자신의 임계구역에서 실행되는 프로세스가 없고, 임계구역에 진입하려는 프로세스가 있다면, 나머지 구역에서 실행 중이지 않은 프로세스들만 다음에 어떤 프로세스가 임계구역으로 진입할 수 있는지 결정하는데 참여할 수 있다.
        - 이 선택은 무한정 연길될 수 없다.
    3. **한정된 대기**(bounded waiting)
        - 프로세스가 자신의 임계구역에 진입하려는 요청을 한 후부터 요청이 허용될 때까지 다른 프로세스들이 그들 자신의 임계구역에 진입하도록 허용되는 횟수에 한계가 있어야 한다.
        - 즉, 임계 영역에 대한 진입 요청 후 무한히 기다리지 않는다.
- 운영체제 내에서 임계구역을 다루기 위해서 두 가지 일반적인 접근법이 사용된다.
    - 선점형 커널
        - 프로세스가 커널 모드에서 수행되는 동안 선점되는 것을 허용한다.
        - 선점형 커널에서는 경쟁 조건이 발생하지 않도록 신중히 설계 되어야 한다.
        - 실시간 프로세스가 현재 커널에서 실행 중인 프로세스를 선점할 수 있기 때문에 실시간 프로그래밍에 더 적절하다.
    - 비선점형 커널
        - 커널 모드에서 수행되는 프로세스의 선점을 허용하지 않고, 커널 모드 프로세스는 커널을 빠져나갈 떄까지 또는 봉쇄될 때까지 또는 자발적으로 CPU의 제어를 양보될 떄까지 계속 수행된다.
        - 비선점형 커널에서는 경쟁조건에 대한 고려를 하지 않아도 된다.

---

## 3. Peterson의 해결안_Peterson’s Solution

- 임계구역에 대한 고전적인 소프트웨어 기반 해결책으로 Peterson의 해결안이 있다.
- 현대 컴퓨터 구조가 load, store 같은 기본적인 기계어를 수행하는 방식 때문에 Peterson의 해결안이 이러한 구조에서 올바르게 실행된다고 보장할 수 없다.
- Peterson의 해결안은 임계구역과 나머지 구역을 번갈아 가며 실행하는 두 개의 프로세스로 한정된다.

Peterson의 해결안은 두 프로세스가 아래 두 개의 데이터 항목을 공유하도록 하여 임계구역 문제를 해결한다.

```java
int turn;        //임계 구역으로 진입할 순번
boolean flag[2]; //프로세스가 임계 구역으로 진입할 준비가 되었다는 것을 나타낼때 사용
```

- `turn == i` 면 프로세스[P(i)]가 임계구역에서 실행될 수 있음을 나타낸다.
- `flag[i]` 가 참이라면 프로세스[P(i)]가 임계구역으로 진입할 준비가 되었다는 것을 나타낸다.

Peterson의 해결안에서 프로세스[P(i)]의 구조는 다음과 같다.

```java
while(true) {
	flag[i] = true;
	turn = j;
	
	while(flag[j] && turn == j)
	/* Critical Section */
	flag[i] = false;
	/* Remainder Section */
}
```

임계구역으로 진입하기 위해 P(i) 는 `flag[i]` 를 True 로 만들고, `turn` 을 j로 지정한다. 이렇게 함으로써 P(j)가 임계구역으로 진입하려고 하면 집입 가능하다는 것을 보장한다.

만일 두 프로세스가 동시에 진입하기를 원한다면 `turn` 은 곧바로 겹쳐 쓰이게 되므로 결국 한 배정만이 지속될 것이다.

이 해결안이 올바로 동작하는 것을 확인하기 위해 3가지를 만족해야 한다.

1. 상호 배제가 제대로 이루어 지는가
    - 이 조건을 만족하기 위해, 각 P(i)가 임계구역에 들어가기 위해서는 반드시 `flag[j] == false`거나 `turn == i` 여야 한다.
    - 만약 `flag[0] == flag[1] == true` 라고 하더라도, `turn` 은 동시에 두 값을 가질 수 없으므로 두 프로세스가 동시에 whlie 문을 통과할 수 없다.
    - 정해진 프로세스가 임계 구역에 있을 동안 `flag, turn` 의 값이 변경되지 않으므로 상호 배제 조건은 지켜지지 않는다.
2. 진행(progress)에 대한 요구조건을 만족하는가
3. 유효한 대기시간을 갖는가
    - 2,3 번은 동시에 증명한다.
    - P(j)가 임계구역에 들어갈 준비가 안되있을 때 `flag[j]==false` 고, P(i)는 임계구역에 진입할 수 있다.
    - P(j)의 `flag==true` 일 때는, `turn` 의 값에 따라 두 프로세스 중 하나가 임계구역에 진입하게 될 것이다.
    - while문을 수행하는동안 `turn` 의 값을 바꾸지 않기 때문에, P(i)는 P(j)가 지난번에 진입했다면, 이번에는 자신도 들어갈 수 있도록 보장(progress)한다.

---

## 4. 동기화를 위한 하드웨어 지원_Hardware Support for Synchronization

### 4.1 메모리 장벽_Memory Barriers

- 컴퓨터 아키텍처가 응용 프로그램에게 제공하는 메모리 접근 시 보장되는 사항을 결정한 방식을 메모리 모델이라고 한다.
- 일반적으로 메모리 모델은 두 가지 범주 중 하나에 속한다.
    - 강한 순서: 한 프로세서의 메모리 변경 결과가 다른 모든 프로세서에 즉시 보임.
    - 약한 순서: 한 프로세서의 메모리 변경 결과가 다른 프로세서에 즉시 보이지 않음.
- 하지만 메모리 모델은 프로세서 유형에 따라 다르므로 커널 개발자는 공유 메모리 다중 처리기에서 메모리 변경의 가시성에 대한 어떠한 가정도 할 수 없다.
- 이  문제를 해결하기 위해 컴퓨터 아키텍처는 메모리의 모든 변경 사항을 다른 프로세서로 전파하는 명령어를 제공하여 다른 프로세서에서 실행 중인 스레드에 메모리 변경 사항이 보이는 것을 보장한다.
- 이 명령어를 메모리 장벽 또는 메모리 펜스라고 한다.

### 4.2 하드웨어 명령어_Hardware instructions

- 현대 기계들은 인터럽트 되지 않는 하나의 단위로서, 특별한 하다웨어 명령어들을 제공한다. 이 특별한 명령어들을 사용해 임계구역 문제를 상대적으로 간단한 방식으로 해결할 수 있다.

**4.2.1 `test_and_set()` 명령어**

```java
boolean test_and_set(boolean *target){
	boolean rv = *target;
	*target = true;

	return rv;
}
```

- 이 명령어의 중요한 특징으로는 원자적(atomically)으로 실행된다는 점이다.
- 따라서 두 개의 명령어가 각각 다른 코어에서 실행되면(동시에), 이들은 어떤 임의의 순서로 순차적으로 실행될 것이다.
- 기계가 이 명령을 지원한다면, false로 초기화되는 lock이라는 boolean 타입 변수를 선언해 상호 배제를 구현할 수 있다.

```java
//test_and_set() 명령어를 사용한 상호 배제 구현
do {
	while(test_and_set(&lock))
	/* do nothing */
	
	/* critical section */

	lock = false

	/* remainder section */
} while (true);
```

**4.2.2 `compare_and_swap()` 명령어(CAS)**

```java
int compare_and_swap(int *value, int expected, int new_value){
	int temp = *value;

	if (*value == expected)
		*value = new_value;

	return tmp;
}
```

- 이 명령어는 `test_and_set()` 명령어와 마찬가지로 두 개의 워드에 대해 원자적인 연산을 하지만 두 워드의 내용 교환에 기반을 둔 다른 기법을 사용한다.
- CAS는 3개의 피연산자를 대상으로 연산을 한다.
- 피연산자 `value` 는 오직 `value == expected` 가 참일때만 `new_value` 로 지정된다. 또한 어떠한 경우에든 `value` 의 원래 값을 반환한다.

```java
//compare_and_swap() 명령어를 사용한 상호 배제 구현
while (true) {
	while(compare_and_swap(&lock, 0, 1) != 0)
	/* do nothing */

	/* critical section */

	lock = 0;

	/* remainder section */
}
```

**4.2.3 CAS를 사용한 한정된 대기 조건을 만족하는 상호 배제**

```java
while(true){
	waiting[i] = true;
  key = 1;
  while(waiting[i] && key == 1)
	  key = compare_and_swap(&lock, 0, 1);
  
	waiting[i] = false;
	/* critical section */
  j = (i + 1) % n;
  while((j != i) && !waiting[j])
	  j = (j + 1) % n;
    
  if(j == i) lock = 0;
  else waiting[j] = false;

	/* remainder section */
}
```

- 앞선 알고리즘들은 상호 배제는 만족하지만, 한정된 대기 조건은 만족하지 못한다. 위 코드에서는 두 조건을 모두 만족한다.
- 실행 조건
    - 임계구역을 떠나는 프로세스는 `lock`을 0으로 하든지 `wating[j]`를 false로 한다. 어느 쪽이든 둘 다 임계구역으로 들어가고자 하는 프로세스를 진입하게 만들어 준다.
- 한정된 대기
    - 프로세스가 임계 구역을 떠날 때, `waiting` 배열을 순환하며 검사한다. 자신 이후부터 차례로 보기 때문에 임계구역에 들어가고자 하는 프로세스는 최대 `n-1` 번만 기다리면 된다.

---

## 5. Mutex Locks

- 하드웨어 기반 해결책은 복잡하고 응용 프로그래머가 사용할 수 없다.
- 대신 운영체제 설계자들은 임계구역 문제를 해결하기 위한 상위 수준 소프트웨어 도구들을 개발하고, 그 중 하나가 Mutex Locks이다.
- 프로세스는 임계구역에 들어가기 전 반드시 락을 획득해야 하고, 임계구역을 빠져나올 때 락을 반환해야 한다.

**Mutex Locks 를 사용한 임계구역 문제 해결책**

```java
while(true) {
	acquire(); //락 획득
	/* critical section */
	release(); //락 반환
	/* remainder section */
}
```

`**aquire()` 함수 정의**

```java
acquire() {
	while(!available) {
		/* busy wait */
		available = false;
	}
}
```

`**release()` 함수 정의**

```java
release() {
	available = true;
}
```

Mutex Locks에서는 `acquire()` 함수가 락을 획득하고, `release()` 함수가 락을 반환한다.

여기서 `available` 이라는 변수를 가지는데 이 변수의 값이 락의 가용 여부를 표시한다.

- 이 구현 방식의 단점은 바쁜 대기(busy waiting)를 해야 한다는 것이다.
- 프로세스가 임계구역에 있는 동안 임계구역에 들어가길 원하는 다른 프로세스들은 `acquire()` 함수를 호출하는 반복문을 계속 실행해야 하고, 이러한 계속된 루틴은 다른 프로세스가 생산적으로 사용할 수 있는 CPU주기를 낭비시킨다.
- 이런 유형을 스핀락(spinlock)이라고도 한다.
- 프로세스들이 짧은 시간 동안만 락을 소유할 것이라 예상되면, 락을 기다리는 동안 문맥교환을 할 필요가 없기 때문에 스핀락이 좋을 수 있다. 따라서 멀티 프로세서 환경에서 많이 사용된다.

---

## 6. 세마포_Semaphores

- mutex는 일반적으로 동기화 도구의 가장 간단한 형태다.
- 세마포는 mutex와 동작은 유사하지만, 프로세스들이 자신들의 행동을 더 정교하게 동기화할 수 있는 방법을 제공한다.
- 세마포 S는 정수 변수로서, `wait()` 와 `signal()` 로 접근이 가능하다.
- 세마포는 가용한 자원의 개수로 초기화되며, 각 자원을 사용하려는 프로세스는 세마포에 `wait()` 연산을 수행하고, 세마포의 값은 감소한다.
- 자원을 방출할 때는 `signal()` 연산을 수행하고, 세마포는 증가하게 된다. 만약 세마포의 값이 0이라면 모든 자원이 사용 중임을 나타내는 것이다.
- 세마포의 값이 0이라면, 프로세스는 0 이상이 될 때까지 blocking 된다.

### 6.1 세마포 사용법_Semaphore Usage

- 운영체제는 세마포를 카운팅과 이진 세마포로 구분한다.
- 카운팅 세마포의 값은 제한 없는 영역을 갖고, 이진 세마포의 값은 0과 1 사이의 값만 가능하다.
- 이진 세마포는 mutex 락과 유사하게 동작하고, 몇몇 시스템에서는 mutex락 대신 상호 배제를 보장하기 위해서 이진 세마포를 사용한다.
- 카운팅 세마포는 유한한 개수를 가진 자원에 대한 접근을 제어하는 데 사용될 수 있다. 세마포는 가용한 자원의 개수로 초기화된다.

### 6.2 세마포 구현_Semaphore Implementation

- mutex 락 구현은 바쁜 대기를 해야 했고, 세마포 연산 `wait(), signal()` 의 정의 역시 같은 문제를 갖고 있다.
- 이를 극복하기 위해 다음과 같이 구현할 수 있다.

```cpp
typedef struct{
	int value;
    struct process *list;
}
 
void wait(semaphore *S){
	S->value--;
  if(S->value < 0){
	  add this process to S->list;
    sleep();
    }
}
 
void signal(semaphore *S){
	S->value++;
  if(S->value <= 0){
	  remove a process P from S->list;
    wakeup(P);
    }
}
```

---

## 7. 모니터_Monitors

세마포가 프로세스 간의 동기화를 위해서 편리하고 효과적으로 쓰일 수 있지만, 자칫 잘못 사용하면 발견하기 어려운 타이밍 오류를 야기할 수 있다.

현재에는 모니터라는 동기화 도구를 주로 사용하며, 이는 좀 더 고수준의 동기화 기능을 제공한다.

### 7.1 모니터의 특징

<img width="485" alt="Untitled" src="https://user-images.githubusercontent.com/75190035/175763060-f7cc0492-0b27-4d59-ae75-2df5a50c97e6.png">

- 조건변수 - `condition`
    - 모니터에 사용하는 특수한 데이터 타입
    - 모니터 내부에 포함되며, 모니터 내부에서만 접근 가능하다.
- 연산
    - `condition` 형 변수에 호출될 수 있는 연산은 오직 `wait()`, `signal()` 이다.
    - `x.wait()`를 호출한 프로세스는 다른 프로세스가 `x.signal()` 을 호출할 때까지 일시 중지 된다.
    - `x.signal()` 연산은 정확히 하나의 일시 중지 프로세스를 재개한다. 만약 없다면, 아무 효과가 없다.
- 만약 condition x와 연관된 일시 중지된 프로세스 Q가 있고, `x.signal()` 연산이 프로세스 P에 의해 호출될 때 두 가지 가능성이 존재한다.
    1. signal and wait: P는 Q가 모니터를 떠날 때까지 기다리거나 또는 다른 조건을 기다린다.
    2. signal and continue: Q는 P가 모니터를 떠날 때까지 기다리거나 또는 다른 조건을 기다린다.
    - 절충안: 스레드 P가 `signal()` 연산을 실행하면, 즉시 모니털ㄹ 떠난다. 따라서 Q가 즉시 재개된다.
    - 어느 것이든 옵션 채택을 정당화하는 근거가 있다.

### 7.2 모니터 내에서 프로세스 수행 재개_Resuming Processes within a Monitor

- 앞서 `signal()` 을 호출하면 일시정지된 프로세스 중 하나를 호출한다고 했다. 이 때 재개될 프로세스는 어떻게 선정할 것인가?
- **FCFS**
    - 가장 간단한 방법으로, 가장 오래 기다린 프로세스가 먼저 깨어단다.
    - 그러나 많은 경우 이런 간단한 스케줄링 기법은 충분하지 않다.
- **condition-wait 구조물**
    - 이 구조물은 정수 수식 c를 가지고, `x.wait()` 연산이 호출될 때 값이 계산된다.
    - c는 우선순위 번호(priority number)라고 불리며 일시 중지 되는 프로세스의 이름과 함께 저장된다.
    - `x.signal()` 이 호출되면 가장 작은 우선순위 번호를 가진 프로세스가 다음번에 수행 재개된다.

---

> 참고
> 
> - 책
> 
> [⌜Operating System Concepts 10th - Abraham Silberschatz, Peter B. Galvin, Greg Gagne⌟](http://www.yes24.com/Product/Goods/78225791)
> 
> - 블로그
> 
> [https://suhwanc.tistory.com/180?category=879656](https://suhwanc.tistory.com/180?category=879656)
> 
> [https://will-behappy.tistory.com/21?category=808600](https://will-behappy.tistory.com/21?category=808600)
> 
> [https://velog.io/@codemcd/운영체제OS-11.-모니터](https://velog.io/@codemcd/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9COS-11.-%EB%AA%A8%EB%8B%88%ED%84%B0)
> 
> [https://blog.naver.com/kgr2626/222118655167](https://blog.naver.com/kgr2626/222118655167)
>
