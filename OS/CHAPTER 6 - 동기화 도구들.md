# CHAPTER 6 - 동기화 도구들

## 1. 배경_Background

- 동시에 여러 개의 프로세스가 동일한 자료를 접근해 조작하고, 그 실행 결과가 접근이 발생한 특정 순서에 의존하는 상황을 경쟁 상황(race condition)이라고 한다.
- 경쟁 상황으로부터 보호하기 위해, 한 순간에 하나의 프로세스만이 변수를 조작하도록 보장해야 한다. 따라서 협력하는 프로세스들 간의 프로세스 동기화는 중요하다.

---

## 2. 임계구역 문제_The Critical-Section Problem

- 두개 이상의 쓰레드에서 사용하는 공통 변수를 업데이트하는 구간을 **임계구역** 이라고 한다.
- 각 프로세스는 임계구역이라고 부르는 코드 부분을 포함하고 있고, 그 안에서는 적어도 하나 이상의 다른 프로세스와 공유하는 데이터에 접근하고 갱신할 수 있다.
- 이 시스템에서 두 프로세스는 동시에 그들의 임계구역 안에서 실행할 수 없다.
- **임계구역 문제**는 프로세스들이 데이터를 협력적으로 공유하기 위해 자신들의 활동을 동기화할 때 사용할 수 있는 프로토콜을 설계하는 것이다.
- 각 프로세스는 자신의 임계구역으로 진입하려면 진입 허가 요청을 해야한다. 이 요청을 구현하는 코드 부분을 **진입 구역**(entry section)이라고 하고, 그 뒤에는 **퇴출 구역**(exit section)이 있을 수 있다.
    - 코드의 나머지 부분을 통칭해 **나머지 구역**(remainder section)이라 부른다.
- 임계구역 문제에 대한 해결책
    1. **상호 배제**(mutual exclusion)
        - 한 프로세스가 자기의 임계구역에서 실행된다면 다른 프로세스들은 임계구역에서 실행될 수 없다.
    2. **진행**(progress)
        - 자신의 임계구역에서 실행되는 프로세스가 없고, 임계구역에 진입하려는 프로세스가 있다면, 나머지 구역에서 실행 중이지 않은 프로세스들만 다음에 어떤 프로세스가 임계구역으로 진입할 수 있는지 결정하는데 참여할 수 있다.
        - 이 선택은 무한정 연길될 수 없다.
    3. **한정된 대기**(bounded waiting)
        - 프로세스가 자신의 임계구역에 진입하려는 요청을 한 후부터 요청이 허용될 때까지 다른 프로세스들이 그들 자신의 임계구역에 진입하도록 허용되는 횟수에 한계가 있어야 한다.
        - 즉, 임계 영역에 대한 진입 요청 후 무한히 기다리지 않는다.
- 운영체제 내에서 임계구역을 다루기 위해서 두 가지 일반적인 접근법이 사용된다.
    - 선점형 커널
        - 프로세스가 커널 모드에서 수행되는 동안 선점되는 것을 허용한다.
        - 선점형 커널에서는 경쟁 조건이 발생하지 않도록 신중히 설계 되어야 한다.
        - 실시간 프로세스가 현재 커널에서 실행 중인 프로세스를 선점할 수 있기 때문에 실시간 프로그래밍에 더 적절하다.
    - 비선점형 커널
        - 커널 모드에서 수행되는 프로세스의 선점을 허용하지 않고, 커널 모드 프로세스는 커널을 빠져나갈 떄까지 또는 봉쇄될 때까지 또는 자발적으로 CPU의 제어를 양보될 떄까지 계속 수행된다.
        - 비선점형 커널에서는 경쟁조건에 대한 고려를 하지 않아도 된다.

---

## 3. Peterson의 해결안_Peterson’s Solution

- 임계구역에 대한 고전적인 소프트웨어 기반 해결책으로 Peterson의 해결안이 있다.
- 현대 컴퓨터 구조가 load, store 같은 기본적인 기계어를 수행하는 방식 때문에 Peterson의 해결안이 이러한 구조에서 올바르게 실행된다고 보장할 수 없다.
- Peterson의 해결안은 임계구역과 나머지 구역을 번갈아 가며 실행하는 두 개의 프로세스로 한정된다.

Peterson의 해결안은 두 프로세스가 아래 두 개의 데이터 항목을 공유하도록 하여 임계구역 문제를 해결한다.

```java
int turn;        //임계 구역으로 진입할 순번
boolean flag[2]; //프로세스가 임계 구역으로 진입할 준비가 되었다는 것을 나타낼때 사용
```

- `turn == i` 면 프로세스[P(i)]가 임계구역에서 실행될 수 있음을 나타낸다.
- `flag[i]` 가 참이라면 프로세스[P(i)]가 임계구역으로 진입할 준비가 되었다는 것을 나타낸다.

Peterson의 해결안에서 프로세스[P(i)]의 구조는 다음과 같다.

```java
while(true) {
	flag[i] = true;
	turn = j;
	
	while(flag[j] && turn == j)
	/* Critical Section */
	flag[i] = false;
	/* Remainder Section */
}
```

임계구역으로 진입하기 위해 P(i) 는 `flag[i]` 를 True 로 만들고, `turn` 을 j로 지정한다. 이렇게 함으로써 P(j)가 임계구역으로 진입하려고 하면 집입 가능하다는 것을 보장한다.

만일 두 프로세스가 동시에 진입하기를 원한다면 `turn` 은 곧바로 겹쳐 쓰이게 되므로 결국 한 배정만이 지속될 것이다.

이 해결안이 올바로 동작하는 것을 확인하기 위해 3가지를 만족해야 한다.

1. 상호 배제가 제대로 이루어 지는가
    - 이 조건을 만족하기 위해, 각 P(i)가 임계구역에 들어가기 위해서는 반드시 `flag[j] == false`거나 `turn == i` 여야 한다.
    - 만약 `flag[0] == flag[1] == true` 라고 하더라도, `turn` 은 동시에 두 값을 가질 수 없으므로 두 프로세스가 동시에 whlie 문을 통과할 수 없다.
    - 정해진 프로세스가 임계 구역에 있을 동안 `flag, turn` 의 값이 변경되지 않으므로 상호 배제 조건은 지켜지지 않는다.
2. 진행(progress)에 대한 요구조건을 만족하는가
3. 유효한 대기시간을 갖는가
    - 2,3 번은 동시에 증명한다.
    - P(j)가 임계구역에 들어갈 준비가 안되있을 때 `flag[j]==false` 고, P(i)는 임계구역에 진입할 수 있다.
    - P(j)의 `flag==true` 일 때는, `turn` 의 값에 따라 두 프로세스 중 하나가 임계구역에 진입하게 될 것이다.
    - while문을 수행하는동안 `turn` 의 값을 바꾸지 않기 때문에, P(i)는 P(j)가 지난번에 진입했다면, 이번에는 자신도 들어갈 수 있도록 보장(progress)한다.

---

## 4. 동기화를 위한 하드웨어 지원_Hardware Support for Synchronization

### 4.1 메모리 장벽_Memory Barriers

- 컴퓨터 아키텍처가 응용 프로그램에게 제공하는 메모리 접근 시 보장되는 사항을 결정한 방식을 메모리 모델이라고 한다.
- 일반적으로 메모리 모델은 두 가지 범주 중 하나에 속한다.
    - 강한 순서: 한 프로세서의 메모리 변경 결과가 다른 모든 프로세서에 즉시 보임.
    - 약한 순서: 한 프로세서의 메모리 변경 결과가 다른 프로세서에 즉시 보이지 않음.
- 하지만 메모리 모델은 프로세서 유형에 따라 다르므로 커널 개발자는 공유 메모리 다중 처리기에서 메모리 변경의 가시성에 대한 어떠한 가정도 할 수 없다.
- 이  문제를 해결하기 위해 컴퓨터 아키텍처는 메모리의 모든 변경 사항을 다른 프로세서로 전파하는 명령어를 제공하여 다른 프로세서에서 실행 중인 스레드에 메모리 변경 사항이 보이는 것을 보장한다.
- 이 명령어를 메모리 장벽 또는 메모리 펜스라고 한다.

### 4.2 하드웨어 명령어_Hardware instructions

- 현대 기계들은 인터럽트 되지 않는 하나의 단위로서, 특별한 하다웨어 명령어들을 제공한다. 이 특별한 명령어들을 사용해 임계구역 문제를 상대적으로 간단한 방식으로 해결할 수 있다.

**4.2.1 `test_and_set()` 명령어**

```java
boolean test_and_set(boolean *target){
	boolean rv = *target;
	*target = true;

	return rv;
}
```

- 이 명령어의 중요한 특징으로는 원자적(atomically)으로 실행된다는 점이다.
- 따라서 두 개의 명령어가 각각 다른 코어에서 실행되면(동시에), 이들은 어떤 임의의 순서로 순차적으로 실행될 것이다.
- 기계가 이 명령을 지원한다면, false로 초기화되는 lock이라는 boolean 타입 변수를 선언해 상호 배제를 구현할 수 있다.

```java
//test_and_set() 명령어를 사용한 상호 배제 구현
do {
	while(test_and_set(&lock))
	/* do nothing */
	
	/* critical section */

	lock = false

	/* remainder section */
} while (true);
```

**4.2.2 `compare_and_swap()` 명령어(CAS)**

```java
int compare_and_swap(int *value, int expected, int new_value){
	int temp = *value;

	if (*value == expected)
		*value = new_value;

	return tmp;
}
```

- 이 명령어는 `test_and_set()` 명령어와 마찬가지로 두 개의 워드에 대해 원자적인 연산을 하지만 두 워드의 내용 교환에 기반을 둔 다른 기법을 사용한다.
- CAS는 3개의 피연산자를 대상으로 연산을 한다.
- 피연산자 `value` 는 오직 `value == expected` 가 참일때만 `new_value` 로 지정된다. 또한 어떠한 경우에든 `value` 의 원래 값을 반환한다.

```java
//compare_and_swap() 명령어를 사용한 상호 배제 구현
while (true) {
	while(compare_and_swap(&lock, 0, 1) != 0)
	/* do nothing */

	/* critical section */

	lock = 0;

	/* remainder section */
}
```

**4.2.3 CAS를 사용한 한정된 대기 조건을 만족하는 상호 배제**

```java
while(true){
	waiting[i] = true;
  key = 1;
  while(waiting[i] && key == 1)
	  key = compare_and_swap(&lock, 0, 1);
  
	waiting[i] = false;
	/* critical section */
  j = (i + 1) % n;
  while((j != i) && !waiting[j])
	  j = (j + 1) % n;
    
  if(j == i) lock = 0;
  else waiting[j] = false;

	/* remainder section */
}
```

- 앞선 알고리즘들은 상호 배제는 만족하지만, 한정된 대기 조건은 만족하지 못한다. 위 코드에서는 두 조건을 모두 만족한다.
- 실행 조건
    - 임계구역을 떠나는 프로세스는 `lock`을 0으로 하든지 `wating[j]`를 false로 한다. 어느 쪽이든 둘 다 임계구역으로 들어가고자 하는 프로세스를 진입하게 만들어 준다.
- 한정된 대기
    - 프로세스가 임계 구역을 떠날 때, `waiting` 배열을 순환하며 검사한다. 자신 이후부터 차례로 보기 때문에 임계구역에 들어가고자 하는 프로세스는 최대 `n-1` 번만 기다리면 된다.

---

> 참고
> 
> - 책
> 
> [⌜Operating System Concepts 10th - Abraham Silberschatz, Peter B. Galvin, Greg Gagne⌟](http://www.yes24.com/Product/Goods/78225791)
> 
> - 블로그
> 
> [https://suhwanc.tistory.com/180?category=879656](https://suhwanc.tistory.com/180?category=879656)
> 
> [https://will-behappy.tistory.com/21?category=808600](https://will-behappy.tistory.com/21?category=808600)
>
