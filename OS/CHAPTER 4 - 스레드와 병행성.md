# CHAPTER 4 - 스레드와 병행성

## 1. 개요

스레드는 CPU 이용의 기본 단위다.

<img width="484" alt="Untitled" src="https://user-images.githubusercontent.com/75190035/174429040-3ed81d01-2408-4527-8c36-217552225212.png">

- 구성: 스레드는 스레드 ID, 프로그램 카운터(PC), 레지스터 집합 그리고 스택으로 구성된다.
- 공유: 스레드는 같은 프로세스에 속한 다른 스레드와 메모리 공간(코드, 데이터 섹션)과 자원(열린 파일이나 신호와 같은 운영체제 자원)들을 공유한다.
- 비공유: 개별적인 프로그램 카운터, SP, 레지스터, 스택(특히  스택에 파라미터, 리턴 Address를 저장하기 때문에 공유하면 안된다.)

### 1.1 동기_Motivation

현대의 대부분의 컴퓨터, 모바일 기기에서 작동하는 소프트웨어 응용 프로그램들은 다중 스레드를 이용한다. 

하나의 응용 프로그램이 여러개의 비슷한 작업을 처리해야 할 상황에서, 단일 스레드 프로세스로 동작한다면, 클라이언트는 자신의 요구가 서비스되기까지 매우 긴 시간을 기다려야 한다.

이를 위한 해결책으로, 서버에게 서비스 요청이 들어오면 프로세스는 그 요청을 수행할 별도의 프로세스를 생성할 수 있지만 비용과 시간이 많이든다.

따라서 대부분은 프로세스 안에 여러 스레드를 만들어 해당 문제를 해결한다.

### 1.2 장점_Benefits

- 응답성(reponsiveness): 응용 프로그램의 일부분이 봉쇄되거나, 응용 프로그램이 긴 작업을 수행 하더라도 프로그램의 수행이 계속되는 것을 허용함으로써, 사용자에 대한 응답성을 증가시킨다.
- 자원 공유(resource sharing): 프로세스는 공유 메모리와 메시지 전달 기법을 통해 자원을 공유할 수 있다. 그러나 스레드는 자동으로 그들이 속한 프로세스의 자원들과 메모리를 공유한다.
- 경제성(economy): 프로세스 생성을 위해 메모리, 자원을 할당하는 것은 비용이 많이 드는 작업이다. 스레드는 자신이 속한 프로세스의 자원들을 공유하기 때문에 스레드를 생성하고 문맥 교환하는 것이 더욱 경제적이다.
- 규모 적응성(scalability): 다중 처리기 구조에서 각각의 스레드가 다른 처리기에서 병렬로 수행될 수 있기 때문에 해당 구조에서 이점을 갖는다.

---

## 2. 다중 코어 프로그래밍_Multicore Programming

컴퓨터 설계의 역사에서 단일 CPU 시스템은 다중 CPU 시스템(단일 컴퓨팅 칩에 여러 컴퓨팅 코어를 배치)으로 발전했다.

각 코어는 윤영체제에 별도의 CPU로 보이게 되는데 이것을 다중 코어라고 하며, 다중 스레드 프로그래밍은 이러한 여러 컴퓨팅 코어를 보다 효율적으로 사용하고 병행성을 향상시키는 기법을 제공한다.

<img width="436" alt="Untitled 1" src="https://user-images.githubusercontent.com/75190035/174429047-f06a1aa3-82bf-4a8e-9423-644204505e26.png">

<img width="436" alt="Untitled 2" src="https://user-images.githubusercontent.com/75190035/174429053-1a719a3c-a85a-4f5e-8848-95f7ad7ecfac.png">

### 2.1 프로그래밍 도전과제_Programming Challenges

일반적으로 다중 코어 시스템을 위해 프로그래밍하기 위해서는 극복해야 할 과제가 있다.

- 태스크 인식(identifying tasks)
    - Application을 분석해 독립된 병행 가능 태스크로 나눌 수 있는 영역을 찾는 작업이 필요
    - 이상적으로는 태스크는 서로 독립적이고 따라서 개별 코어에서 병렬 실행될 수 있어야 한다.
- 균형(balance):
    - 찾아진 부분들이 전체 작업에 균등한 기여도를 가지도록 태스크로 나누는 것이 중요하다.
- 데이터 분리(data spliting)
    - 태스크가 접근하고 조작하는 데이터 또한 개별 코어에서 사용할 수 있도록 나누어져야 한다.
- 데이터 종속성(data dependency)
    - 태스크가 접근하는 데이터는 둘 이상의 태스크 사이에 종속성이 없는지 검토되어야 한다.
    - 종속적인 경우 프로그래머가 데이터 종속성을 수용할 수 있도록 태스크의 수행을 잘 동기화해야 한다.
- 시험 및 디버깅(testing and debugging)
    - 병행 프로그램을 시험하고 디버깅하는 것은 단일 스레드 응용을 시험하고 디버깅하는 것보다 근본적으로 훨씬 어렵다.

### 2.2 병렬 실행의 유형_Types of Parallelism

<img width="344" alt="Untitled 3" src="https://user-images.githubusercontent.com/75190035/174429055-dd5e0e84-a5e0-4b95-9a2b-7e673a4a3da8.png">

- 일반적으로 데이터 병렬 실행과 태스크 병렬 실행의 두 가지 유형이 존재한다.
    - **데이터 병렬 실행(Data Parallelism)**: 동일한 데이터의 부분집합을 다수의 계산 코어에 분배한 후 각 코어에서 동일한 연산을 실행하는 데 초점을 맞춘다.
    - **태스크 병렬 실행(Task Parallelism)**: 태스크(스레드)를 다수의 코어에 분배한다. 각 스레드는 고유의 연산을 실행한다. 따라서 다른 스레드들이 동일한 데이터에 대해 연산을 실행할 수도 있다.
- 기본적으로 데이터 병렬 처리에는 여러 코어에 데이터를 분배하는 것이 포함되고, 태스크 병렬 처리에는 여러 코어에 태스크를 분배하는 것이 포함된다.

---

## 3. 다중 스레드 모델_Multithreading Models

스레드를 위한 지원은 사용자 스레드를 위해서는 사용자 수준에서, 커널 스레드를 위해서는 커널 수준에서 제공된다.

- 사용자 스레드는 커널 위에서 지원되며 커널의 지원 없이 관리된다.
- 커널 스레드는 운영체제에 의해 직접 지원되고 관리된다.
- 사용자 스레드와 커널 스레드는 어떤 연관관계가 존재해야 한다.
    - ex) 다대일, 일대일, 일대다

### 3.1 다대일 모델_Many-to_One Model

<img width="298" alt="Untitled 4" src="https://user-images.githubusercontent.com/75190035/174429058-efe0972c-856f-4cff-bd63-b1f223ea15da.png">

- 다대일 모델은 많은 사용자 수준 스레드를 하나의 커널 스레드로 사상(mapping)한다.
    - 장점
        - 스레드 관리는 사용자 공간의 스레드 라이브러리에 의해 행해지기 때문에 효율적이다.
    - 단점
        - 한 스레드가 봉쇄형 시스템 콜을 할 경우 저네 프로세스가 봉쇄된다.
        - 한 번에 하나의 스레드만이 커널에 접근할 수 있기 때문에, 다중 스레드가 다중 코어 시스템에서 병렬로 실행될 수 없다.
        - 이런 단점 때문에 이 모델을 사용 중인 시스템은 거의 존재하지 않는다.

### 3.2 일대일 모델_One-to-One Model

<img width="289" alt="Untitled 5" src="https://user-images.githubusercontent.com/75190035/174429062-21c93215-5f1c-48d4-897c-fe0bfd6066f2.png">

- 일대일 모델은 각 사용자 스레드를 각각 하나의 커널 스레드로 사상(mapping)한다.
    - 장점
        - 하나의 스레드가 봉쇄적 시스템 콜을 호출하더라도 다른 스레드가 실행될 수 있기 때문에 다대일 모델보다 더 많은 병렬성을 제공한다.
        - 다중 처리기에서 다중 스레드가 병렬로 수행되는 것을 허용한다.
    - 단점
        - 사용자 스레드를 만들려면 해당 커널 스레드를 만들어야 하며 많은 수의 커널 스레드가 시스템 성능에 부담을 줄 수 있다.

### 3.3 다대다 모델_Many-to-Many Model

<img width="282" alt="Untitled 6" src="https://user-images.githubusercontent.com/75190035/174429065-ccabe356-15e5-4e32-848b-561b63a47fe3.png">

- 다대다 모델은 여러 개의 사용자 수준 스레드를 그 보다 작거나 같은 수의 커널 스레드로 멀티 플렉스한다.
- 커널 스레드의 수는 응용 프로그램이나 특정 기계에 따라 결정된다.
- 다대다 모델은 앞선 두 모델의 단점을 어느정도 해결했다.(스레드 수가 맞지 않아도 되고, 진정한 병렬성을 제공한다.)
- 실제로는 구현이 어렵고, 처리 코어 수가 증가함에 따라 커널 스레드 수를 제한하는 것의 중요성이 줄어들었기 때문에 일대일 모델을 더 많이 사용한다.

---

## 4. 스레드 라이브러리_Threads Library

스레드 라이브러리는 프로그래머에게 스레드를 생성하고 관리하기 위한 API를 제공한다. 현재는 POSIX, Windows, Java 세 종류의 스레드 라이브러리가 주로 사용된다.

스레드 라이브러리를 구현하는 데에는 주된 두 가지 방법이 있다.

1. 커널의 지원 없이 완전히 사용자 공간에서만 라이브러리를 제공하는 것
    - 라이브러리의 모든 코드와 자료구조는 사용자 공간에 존재한다. 라이브러리 함수를 호출하는 것은 시스템 콜이 아닌 사용자 공간의 지역 함수를 호출하게 된다는 것을 의미한다.
2. 운영체제에 의해 지원되는 커널 수준 라이브러리를 구현하는 것
    - 라이브러리를 위한 코드와 자료구조는 커널 공간에 존재한다. 라이브러리 API를 호출하는 것은 커널 시스템 콜을 부르는 결과를 낳는다.

- 쓰레딩에는 2가지 종류가 있다.
    - 비동기 스레딩(Asynchronous threading)
        - 부모 스레드가 자식 스레드를 생성한 후 부모는 자신의 실행을 재개하여 부모와 자식 스레드가 서로 독립적으로 병행하게 실행된다.
        - 스레드가 독립적이기 때문에 스레드 사이의 데이터 공유는 거의 없다.
    - 동기 tm레딩(Synchronous threading)
        - 부모 스레드가 하나 이상의 자식 스레드를 생성하고 자식 스레드 모두가 종료할 때까지 기다렸다가 자신의 실행을 재개하는 방식을 말한다.
        - 부모가 생성한 스레드는 병행하게 실행되지만 부모는 자식들의 작업이 끝날 때까지 실행을 계속할 수 없다. 모든 자식 스레드가 조인한 후에야 실행을 재개 할 수 있다.
        - 통상 동기 스레딩은 스레드 사이의 상당한 양의 데이터 공유를 수반한다.

---

## 5. 암묵적 스레딩_Implicit Threading

다중 코어 처리의 성장에 따라, 수백 또는 수천 개의 스레드를 가진 응용 프로그램이 등장 하였다.

그러한 응용 프로그램을 설계하는 것은 사소한 일이 아니며 프로그래머는 여러 어려움을 극복해야 한다.

이 방법 중 하나는 스레딩의 생성과 관리 책임을 응용 프로그램 개발자로부터 컴파일러와 실행시간 라이브러리에게 넘겨주는 것이다. 이것을 암묵적 스레딩이라 한다.

### 5.1 스레드 풀_Thread Pool

- 웹 서버는 요청을 받을 때마다 그 요청을 위해 새로운 스레드를 만들어 준다. 새로운 스레드를 매 요청마다 만들어 주는 것은, 프로세스를 만드는 것 보다 더 나은 방법이지만 여러 문제를 가지고 있다.
- 스레드 풀 사용 이전의 문제점
    - 서비스를 할 때마다 스레드를 생성하는 데 시간이 소요된다.
    - 모든 요청마다 새 스레드를 만들어서 서비스 해 준다면 시스템에서 동시에 실행할 수 있는 최대 스레드 수가 몇 개인지 한계를 정의해야 한다.
    - 스레드를 무한정 만들면 결국 CPU 시간, 메모리 공간 같은 시스템 자원이 고갈된다.
- **위 문제점을 해결하는 방법이 스레드 풀이다.**
- 스레드 풀의 기본 아이디어는 프로세스를 시작할 때 일정한 수의 스레드를 풀(pool)로 만들어두는 것이다. pool에 만들어진 스레드들은 일이 없으면 대기한다.
- 서버는 요청을 받으면 스레드를 생성하는 것 대신, 스레드 풀에 스레드를 요청한다.
- 스레드 풀에 사용 가능한 스레드가 있으면 스레드를 할당하고, 사용 가능 스레드가 없다면 사용 가능한 스레드가 생길 때 까지 작업이 대기된다.
- 장점
    - 새 스레드를 만드는 것 보다 기존 스레드로 서비스해 주는 것이 종종 더 빠르다.
    - 스레드 풀은 임의 시각에 존재할 스레드 개수에 제한을 둔다. 이 제한은 많은 수의 스레드를 병렬 처리할 수 없는 시스템에 도움이 도니다.
    - 태스크를 생성하는 방법을 태스크로부터 분리하면 태스크 실행을 다르게 할 수 있다.

### 5.2 Fork Join

- Fork Join 메서드를 사용하면 메인 부모 스레드가 하나 이상의 자식 스레드를 생성(`fork`)한 다음 자식의 종료를 기다린 후 `join` 하고 그 시점부터 자식의 결과를 확인하고 결합할 수 있다

---

> 참고
> 
> - 책
> 
> [⌜Operating System Concepts 10th - Abraham Silberschatz, Peter B. Galvin, Greg Gagne⌟](http://www.yes24.com/Product/Goods/78225791)
> 
> - 블로그
> 
> [https://blog.naver.com/bisu1532/221615645622](https://blog.naver.com/bisu1532/221615645622)
> 
> [https://suhwanc.tistory.com/178?category=879656](https://suhwanc.tistory.com/178?category=879656)
>
