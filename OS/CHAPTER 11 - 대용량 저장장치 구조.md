# CHAPTER 11 - 대용량 저장장치 구조

## 1. 대용량 저장장치 구조

최신 컴퓨터를 위한 대량의 보조저장장치는 하드 디스크 드라이브(HDD) 및 비휘발성 메모리(NVM) 장치에 의해 제공된다.

### 1.1 하드 디스크 드라이브_Hard Disk Drives

<img width="440" alt="Untitled" src="https://user-images.githubusercontent.com/75190035/178135217-eb3d0266-c3bc-4ba4-99f1-a742de6ed0cb.png">

- 각 디스크의 **플래터(platter)**는 CD 처럼 생긴 원형 평판 모양이다. 플래터의 양쪽 표면은 자기  테이프와 유사하게 자기 물질로 덮여 있다.
- 정보를 플래터 상에 자기적으로 기록하여 저장하고 플래터의 자기 패턴을 감지하여 정보를 읽는다.
- **읽기-쓰기 헤드**는 모든 플래터의 각 표면 위에서 움직인다. 헤드는 모든 헤드를 한꺼번에 이동시키는 **디스크 암(disk arm)**에 부착되어 있다.
- 플래터의 표면은 원형인 **트랙(track)**으로 논리적으로 나누어져 있고, 이것은 다시 **섹터(sector)**로 나누어져 있다.
    - **각 섹터는 크기가 고정되어 있으며, 가장 작은 전송 단위다.**
- 동일한 암 위치에 있는 트랙의 집합은 하나의 **실린더(cylinder)**를 형성한다. 하나의 디스크 드라이브에는 수천 개의 동심원 실린더가 존재할 수 있고, 각 트랙은 수백 개의 섹터를 포함할 수 있다.
- 디스크 드라이브 모터는 고속으로 회전한다. 회전 속도는 전송 속도와 관련이 있다.
    - 전송 속도는 드라이브와 컴퓨터 간의 데이터 흐름의 속도다.
- 디스크 암을 원하는 실린더로 이동하는데 필요한 시간을 **탐색 시간**이라 하고**,** 원하는 섹터가 디스크 헤드 위치까지 회전하는 데 걸리는 시간을 **회전 지연시간**이라 한다.

---

## 2. 디스크 스케줄링_Disk Scheduling

운영체제의 책임 중 하나는 효율적인 하드웨어 사용이다. HDD의 경우 이 책임은 접근 시간을 최소화하고 전송 대역폭을 최대화하는 것을 수반한다.

- HDD 또는 플래터를 사용하는 기계식 저장장치의 경우, **접근 시간**은 두 가지 요소로 이루어진다.
    - **탐색 시간(seek time)**: 장치 암이 헤드를 해당 실린더로 움직이는 데 걸리는 시간
    - **회전 지연 시간(rotational latency)**: 플래터가 원하는 섹터를 헤드 위치까지 회전시키는 데 소요되는 추가적인 시간
- 장치 **대역폭**은 전송된 총 바이트 수를 첫 번째 서비스 요청과 마지막 전송 완료 사이의 전체 시간으로 나눈 값
- 저장장치 I/O 요청이 처리되는 순서를 관리해 접근 시간과 대역폭을 모두 향상할 수 있다.

### 2.1 선입 선처리 스케줄링_FCFS Scheduling

- 디스크 스케줄링의 가장 간단한 형태는 선입 선처리(first-come-first-served) 스케줄링이다.
- 본질적으로는 공평해 보이지만 빠른 서비스를 제공하지는 못한다.

다음과 같은 입/출력 요청이 디스크 큐에 와 있다고 가정해 보자. (현재 헤드는 53에 위치)

```java
98, 183, 37, 122, 14, 124, 65, 67
```

![Untitled 1](https://user-images.githubusercontent.com/75190035/178135218-0163f892-39dd-489e-8a38-225bb95c18c7.png)

헤드는 53 → 183 → 37 → … → 67 순서로 이동하여 모두 640 실린더를 헤드가 가로지르게 된다.

**이 스케줄링의 문제는 헤드의 총 이동 거리를 줄일 수 없다는 점이다.**

만약 53 → 183 이 아닌, 53 → 67 로 이동했다면, 헤드의 이동 거리를 많이 줄이고 성능도 향상될 수 있었을 것이다.

### 2.2 SCAN 스케줄링_SCAN Scheduling

- SCAN 알고리즘에서는 디스크 암이 디스크의 한끝에서 시작해 다른 끝으로 이동하며, 가능 길에 있는  요청을 모두 처리한다.
- 다른 한쪽 끝에 도달(혹은 그쪽 방향으로 더는 대기하고 있는 요청이 없으면)하면, 역방향으로 이동하며 가는 길에 있는 모든 요청을 처리한다.
- 따라서 헤드는 디스크 양쪽을 계속해서 가로지르며 왕복한다.

다음과 같은 입/출력 요청이 디스크 큐에 와 있다고 가정해 보자. 

```java
98, 183, 37, 122, 14, 124, 65, 67
```

SCAN 스케줄링을 적용하기 전에 우리는 헤드의 현재 위치와 헤드의 진행 방향을 알아야 한다.

디스크 암의 현재 위치는 53, 0 방향으로 이동한다고 가정하면, 다음과 같은 결과를 나타낼 것이다.

![Untitled 2](https://user-images.githubusercontent.com/75190035/178135221-55b56d57-bd80-418d-a3be-7f6fd87870c4.png)

SCAN 스케줄링은 첫 0방향으로의 이동 때 37, 14 요청을 처리할 것이다.

이후 반대 방향으로 이동하며 나머지(65, 67, 98, 122, 124, 183) 요청을 순서대로 처리할 것이다. 결과적으로 236 실린더를 헤드가 가로지르게 된다.

### 2.3 C-SCAN 스케줄링_C-SCAN Scheduling

- 모든 실린더에 요청이 균일하게 도착한다고 가정하면, 헤드가 한쪽 끝에 도달했을 때 헤드 바로 근처에는 대기 중인 요청이 거의 없고 반대쪽 끝으로 가장 많은 요청이 몰려 있을 것이다.
- **C-SCAN(circular-SCAN)** 스케줄링은 각 요청에 걸리는 시간을 좀 더 균등하게 하기 위한 SCAN의 변형이다.
- C-SCAN은 한쪽으로 헤드를 이동해 가면서 요청을 처리하지만, 한쪽 끝에 다다르면 반대 방향으로 헤드를 이동하며 서비스하는 것이 아닌 **처음 시작했던 자리로 돌아가 서비스를 시작한다.**

다음과 같은 입/출력 요청이 디스크 큐에 와 있다고 가정해 보자. 

```java
98, 183, 37, 122, 14, 124, 65, 67
```

C-SCAN 스케줄링을 적용하기 전에 우리는 헤드의 현재 위치와 헤드의 진행 방향을 알아야 한다.

디스크 암의 초기 위치가 53이고, 0에서 199 방향으로 이동한다고 가정하면, 다음과 같은 결과를 나타낼 것이다.

![Untitled 3](https://user-images.githubusercontent.com/75190035/178135223-7d3e2fc0-7293-4635-a629-7288da7b24f1.png)

199 까지 이동이 끝난 이후에는 처음 위치였던 0으로 다시 이동해 탐색을 계속할 것이다.

---

> 참고
> 
> - 책
> 
> [⌜Operating System Concepts 10th - Abraham Silberschatz, Peter B. Galvin, Greg Gagne⌟](http://www.yes24.com/Product/Goods/78225791)
> 
> - 강의
> 
> [운영체제 - 경성대학교, 양희재](http://www.kocw.net/home/cview.do?cid=5c3c30382c7bbcf6)
>
