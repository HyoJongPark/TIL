# 테스트

> [백기선 - 더 자바, 애플리케이션을 테스트하는 다양한 방법](https://www.inflearn.com/course/the-java-application-test#reviews)
> 

# 1. JUnit 5

<img width="599" alt="Untitled" src="https://user-images.githubusercontent.com/75190035/184288504-6e0ed0a5-b78b-4a68-bc4f-e97382b568f8.png">

- Platform:  테스트를 실행해주는 런처 제공. TestEngine API 제공.
- Jupiter: TestEngine API 구현체로 JUnit 5를 제공.
    - `org.junit.jupiter.api...`
- Vintage: JUnit 4와 3을 지원하는 TestEngine 구현체.

## JUnit 5: 시작하기

```html
<!--gradle 의존성-->
<dependency>
    <groupId>org.junit.jupiter</groupId>
    <artifactId>junit-jupiter-engine</artifactId>
    <version>5.5.2</version>
    <scope>test</scope>
</dependency>
```

- 스프링 부트 2.2 이상의 프로젝트를 만든다면, 기본으로 JUnit5 의존성이 추가된다.
- 기본 애노테이션
    - `@Test`
    - `@BeforeAll` / `@AfterAll`
        - `static void` 형식으로 사용해야 한다.
        - 모든 테스트가 시작되기 전/후 한 번만 실행된다.
    - `@BeforeEach` / `@AfterEach`
        - 각각의 테스트가 시작되기 전/후 실행된다.
    - `@Disabled`
        - 작성한 테스트 중 실행시키지 않을 테스트에 사용한다.

## JUnit 5: 테스트  이름 표시하기

```java
@DisplayNameGeneration(value = DisplayNameGenerator.ReplaceUnderscores.class)
class JUnitTest {
	
	@Test
	@DisplayName("회원 가입 테스트")
	void member_register() {
		Member member = new Member("memberA");
	}
}

```

- `@DisplayNameGeneration`
    - Method와 Class 래퍼런스를 사용해 테스트 이름을 표시하는 방법
    - 클래스 레벨에 사용한다.
    - 기본 구현체로 `ReplaceUnderscores` 가 제공된다.
- `@DisplayName`
    - `@DisplayNameGeneration` 보다 우선 순위가 높다.
    - 클래스, 메서드 레벨 모두 사용가능하다.

## JUnit 5: Assertion

```java
import static org.junit.jupiter.api.Assertions.*;

class JUnitTest {
	
	@Test
	@DisplayName("회원 가입 테스트")
	void member_register() {
		Member member = new Member("memberA");
		assertNotNull(member);
		assertEquals(MemberStatus.NOMAL, member.getStatus(),
			() -> "회원은 최초" + MemberStatus.NOMAL + "상태다.");
	}

	@Test
	@DisplayName("회원 가입 테스트-통합")
	void member_register_all() {
		Member member = new Member("memberA");
		assertAll(
			() ->assertNotNull(member),
			() ->	assertEquals(MemberStatus.NOMAL, member.getStatus(), () -> "회원은 최초" + MemberStatus.NOMAL + "상태다.");
	}
}
```

- 테스트에서 검증하고자 하는 내용을 확인한다.
- AssertJ, Hemcret, Truth 등의 라이브러리도 사용 가능하다.
- 마지막 매개변수로 `Supplier<String>` 타입의 인스턴스를 람다 형태로 제공할 수 있다.
    - 람다식으로 제공하면 테스트가 실패했을 때만 선택적으로 해당 문자열 연산을 실행한다.

## JUnit 5: 조건에 따라 테스트 실행

```java
import static org.junit.jupiter.api.Assertions.*;
import static org.junit.jupiter.api.Assumptions.*;

class JUnitTest {
	
	@Test
	@DisplayName("조건에 따라 테스트 수행-코드")
	void test_with_code() {
		String test_env = System.getenv("TEST_ENV");
		assumTrue("LOCAL".equalsIgnoreCase(test_env));
	
		//--- 조건을 만족하지 않으면 실행되지 않음
	}

	@Test
	@DisplayName("조건에 따라 테스트 수행-애노테이션")
	@EnabledIfEnvironmentVariable(named = "TEST_ENV", matches = "LOCAL")
	void test_with_annotation() {
		//--- 조건을 만족하지 않으면 실행되지 않음
	}	
}
```

- 조건을 확인하고, 조건을 만족하지 않으면 해당 테스트를 **생략**한다.
    - 생략하는 것이지 실패하는 것은 아니다.
- `@Disabled__` , `@Enabled__` 애노테이션을 사용해 조건을 테스트 할 수 있다.
    - OnOS
    - OnJre
    - IfSystemProperty
    - IfEnvironmentVariable
    - If

## JUnit 5: 테스트 반복하기

```java
@DisplayName("회원 생성")
@RepeatedTest(value = 10, name = "{displayName}, {currentRepetition}/{totalRepetitions})
void repeatedTest(RepetitionInfo repetitionInfo) {
	...
}

@ParameterizedTest(name = "{index} {displayName} message={0}")
@ValueSource(stringss = {"memberA", "memberB", "memberC"})
void parameterizedTest(String message) {
	...
}
```

- `@RepeatedTest`
    - 반복 횟수와 테스트 이름을 설정할 수 있다.
    - RepetitionInfo 타입의 인자를 받아 현재 반복 횟수, 총 반복 횟수를 얻을 수 있다.
- `@ParameterizedTest`
    - 테스트에 여러 다른 매개를 대입해가며 반복할 수 있다.
    

## JUnit 5: 테스트 인자 값

```java
class Test {
	@DisplayName("하나의 인자는 Converter로 변환")
	@ParameterizedTest(name = "{index} {displayName} message={0}")
	@ValueSource(ints = {10, 20, 30})
	void converterTest(@ConvertWith(MemberConverter.class) Member member) {
		...
	}

	@DisplayName("여러 개의 인자는 Aggregator로 변환")
	@ParameterizedTest(name = "{index} {displayName} message={0}")
	@CsvSource({"10, memberA", "20, memberB"})
	void aggregatorTest(@AggregateWith(MemberAggregator.class) Member member) {
		...
	}	

	//컨버터
	static class MemberConverter extends SimpleArgumentConverter {
		@Override
		protected Object convert(Object source, Class<?> targetType) throws ArgumentConversionException {
			assertEquals(Member.class, targetType, "회원 클래스만 변환 가능합니다.");
			return new Member(Integer.parseInt(source.toString()));
		}

	//Accessor
	static class MemberAggregator implements ArgumentsAggregator {
		@Override
    public Object aggregateArguments(ArgumentsAccessor accessor, ParameterContext context) throws ArgumentsAggregationException {
	    Member member = new Member(accessor.getInteger(0), accessor.getString(1));
			return member;
    }
}
```

- 인자 값들의 소스를 넘겨줄 때는 해당 애노테이션들을 사용할 수 있다.
    - @ValueSource, @NullSource, @EmptySource, @NullAndEmptySource 등
- 인자 값 타입 변환
    - 암묵적인 타입변환
    - 명시적인 타입변환
        - `SimpleArgumentConverter` 을 상속받아 컨버터를 구현할 수 있다.
        - `@ConvertWith` 애노테이션에 구현한 클래스를 명시해 해당 컨버터를 사용해 타입변환을 수행한다.
        - 단, 하나의 인자 값일 때만 사용 가능하다.
- 인자 값 조합
    - 여러개의 인자 값을 받을 경우 `ArgumentsAccessor` 를 사용해 각각의 인자 값을 불러올 수 있다.
    - 커스텀 Accessor
        - `ArgumentsAggregator` 인터페이스를 구현해 각각의 인자 값을 원하는 타입으로 커스텀하게 변환할 수 있다.
        - `@AggregateWith` 애노테이션에 구현한 클래스를 명시해 타입 변환을 수행한다.

> [https://junit.org/junit5/docs/current/user-guide/#writing-tests-parameterized-tests](https://junit.org/junit5/docs/current/user-guide/#writing-tests-parameterized-tests)
> 

## JUnit 5: 테스트 인스턴스

- JUnit은 테스트를 메서드마다 테스트 인스턴스를 새로 만든다.
    - 기본 전략
    - 테스트 메서드를 독립적으로 실행해 예상치 못한 부작용을 방지하기 위함이다.
- `@TestInstance(Lifecycle.PER_CLASS)`
    - 테스트 클래스마다 인스턴스를 하나만 만들어 사용하도록 변경한다.
    - 하나의 인스턴스를 공유하기 때문에 `@BeforeEach, @AfterEach` 에서 테스트 간 공유하는 모든 상태를 초기화 해야할 필요가 있다.

## JUnit 5: 테스트 순서

```java
@TestInstance(Lifecycle.PER_CLASS)
@TestMethodOrder(MethodOrdered.OrderAnnotation.class)
class Test {
	@Order(2)
	@DisplayName("두 번째 실행")
	void seconde(){
		...
	}

	@Order(1)
	@DisplayName("첫 번째 실행")
	void first(){
		...
	}
}
```

- 실행할 테스트 메서드는 특정한 순서에 의해 실행되지만 어떻게 그 순서를 정하는 지는 의도적으로 분명히 하지 않는다.
    - 테스트 순서에 의존하지 않고 독립적으로 동일한 결과를 유지해야 하기 때문에 순서를 분명히하지 않는다.
- 경우에 따라 의도적으로 순차적으로 테스트를 수행할 때 `@TestInstance(Lifecycle.PER_CLASS)` 와 함께 `@TestMethodOrder` 를 사용할 수 있다.
    - `@TestMethodOrder` 는 `MethodOrderer` 구현체를 설정해야 한다.
    - 기본 구현체
        - `Alphanumeric`
        - `OrderAnnoation`
        - `Random`

## JUnit 5: 설정 파일

- `src/test/resources/` 에 `junit-platform.properties` 를 생성해 JUnit 설정 파일을 생성할 수 있다.
- 해당 설정 파일에서 JUnit과 관련된 설정을 변경할 수 있다.
    - 테스트 인스턴스 라이프사이클 설정
        - `junit.jupiter.testinstance.lifecycle.default = per_class`
    - 테스트 이름 표기 전략 설정
        - `junit.jupiter.displayname.generator.default = org.junit.jupiter.api.DisplayNameGenerator$ReplaceUnderscores`

## JUnit 5: 확장 모델

- JUnit 5의 확장 모델은 `Extension` 하나다. (JUnit4에 비해 단순화됨)
- 확장팩 등록 방법
    - 선언적인 등록: `@ExtendWith`
    - 프로그래밍 등록: `@RegisterExtension`
    - 자동 등록 자바 `ServiceLoader` 이용

> [https://junit.org/junit5/docs/current/user-guide/#extensions](https://junit.org/junit5/docs/current/user-guide/#extensions)
> 

## JUnit 5: 마이그레이션

- `junit-vintage-engine`을 의존성으로 추가하면, JUnit 5의 junit-platform으로 JUnit 3과 4로 작성된 테스트를 실행할 수 있다.
    - `@Rule` 은 지원하지 않지만 `@EnableRuleMigrationSupport` 를 다음 타입의 Rule을 지원할 수 있다.
        - ExternalResource
        - Verifier
        - ExpectedException
