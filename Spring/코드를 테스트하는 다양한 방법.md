# 테스트

> [백기선 - 더 자바, 애플리케이션을 테스트하는 다양한 방법](https://www.inflearn.com/course/the-java-application-test#reviews)
> 

# 1. JUnit 5

<img width="599" alt="Untitled" src="https://user-images.githubusercontent.com/75190035/184526384-cac95670-3e43-41d1-8414-552791362242.png">

- Platform:  테스트를 실행해주는 런처 제공. TestEngine API 제공.
- Jupiter: TestEngine API 구현체로 JUnit 5를 제공.
    - `org.junit.jupiter.api...`
- Vintage: JUnit 4와 3을 지원하는 TestEngine 구현체.

## JUnit 5: 시작하기

```html
<!--gradle 의존성-->
<dependency>
    <groupId>org.junit.jupiter</groupId>
    <artifactId>junit-jupiter-engine</artifactId>
    <version>5.5.2</version>
    <scope>test</scope>
</dependency>
```

- 스프링 부트 2.2 이상의 프로젝트를 만든다면, 기본으로 JUnit5 의존성이 추가된다.
- 기본 애노테이션
    - `@Test`
    - `@BeforeAll` / `@AfterAll`
        - `static void` 형식으로 사용해야 한다.
        - 모든 테스트가 시작되기 전/후 한 번만 실행된다.
    - `@BeforeEach` / `@AfterEach`
        - 각각의 테스트가 시작되기 전/후 실행된다.
    - `@Disabled`
        - 작성한 테스트 중 실행시키지 않을 테스트에 사용한다.

## JUnit 5: 테스트  이름 표시하기

```java
@DisplayNameGeneration(value = DisplayNameGenerator.ReplaceUnderscores.class)
class JUnitTest {
	
	@Test
	@DisplayName("회원 가입 테스트")
	void member_register() {
		Member member = new Member("memberA");
	}
}

```

- `@DisplayNameGeneration`
    - Method와 Class 래퍼런스를 사용해 테스트 이름을 표시하는 방법
    - 클래스 레벨에 사용한다.
    - 기본 구현체로 `ReplaceUnderscores` 가 제공된다.
- `@DisplayName`
    - `@DisplayNameGeneration` 보다 우선 순위가 높다.
    - 클래스, 메서드 레벨 모두 사용가능하다.

## JUnit 5: Assertion

```java
import static org.junit.jupiter.api.Assertions.*;

class JUnitTest {
	
	@Test
	@DisplayName("회원 가입 테스트")
	void member_register() {
		Member member = new Member("memberA");
		assertNotNull(member);
		assertEquals(MemberStatus.NOMAL, member.getStatus(),
			() -> "회원은 최초" + MemberStatus.NOMAL + "상태다.");
	}

	@Test
	@DisplayName("회원 가입 테스트-통합")
	void member_register_all() {
		Member member = new Member("memberA");
		assertAll(
			() ->assertNotNull(member),
			() ->	assertEquals(MemberStatus.NOMAL, member.getStatus(), () -> "회원은 최초" + MemberStatus.NOMAL + "상태다.");
	}
}
```

- 테스트에서 검증하고자 하는 내용을 확인한다.
- AssertJ, Hemcret, Truth 등의 라이브러리도 사용 가능하다.
- 마지막 매개변수로 `Supplier<String>` 타입의 인스턴스를 람다 형태로 제공할 수 있다.
    - 람다식으로 제공하면 테스트가 실패했을 때만 선택적으로 해당 문자열 연산을 실행한다.

## JUnit 5: 조건에 따라 테스트 실행

```java
import static org.junit.jupiter.api.Assertions.*;
import static org.junit.jupiter.api.Assumptions.*;

class JUnitTest {
	
	@Test
	@DisplayName("조건에 따라 테스트 수행-코드")
	void test_with_code() {
		String test_env = System.getenv("TEST_ENV");
		assumTrue("LOCAL".equalsIgnoreCase(test_env));
	
		//--- 조건을 만족하지 않으면 실행되지 않음
	}

	@Test
	@DisplayName("조건에 따라 테스트 수행-애노테이션")
	@EnabledIfEnvironmentVariable(named = "TEST_ENV", matches = "LOCAL")
	void test_with_annotation() {
		//--- 조건을 만족하지 않으면 실행되지 않음
	}	
}
```

- 조건을 확인하고, 조건을 만족하지 않으면 해당 테스트를 **생략**한다.
    - 생략하는 것이지 실패하는 것은 아니다.
- `@Disabled__` , `@Enabled__` 애노테이션을 사용해 조건을 테스트 할 수 있다.
    - OnOS
    - OnJre
    - IfSystemProperty
    - IfEnvironmentVariable
    - If

## JUnit 5: 테스트 반복하기

```java
@DisplayName("회원 생성")
@RepeatedTest(value = 10, name = "{displayName}, {currentRepetition}/{totalRepetitions})
void repeatedTest(RepetitionInfo repetitionInfo) {
	...
}

@ParameterizedTest(name = "{index} {displayName} message={0}")
@ValueSource(stringss = {"memberA", "memberB", "memberC"})
void parameterizedTest(String message) {
	...
}
```

- `@RepeatedTest`
    - 반복 횟수와 테스트 이름을 설정할 수 있다.
    - RepetitionInfo 타입의 인자를 받아 현재 반복 횟수, 총 반복 횟수를 얻을 수 있다.
- `@ParameterizedTest`
    - 테스트에 여러 다른 매개를 대입해가며 반복할 수 있다.
    

## JUnit 5: 테스트 인자 값

```java
class Test {
	@DisplayName("하나의 인자는 Converter로 변환")
	@ParameterizedTest(name = "{index} {displayName} message={0}")
	@ValueSource(ints = {10, 20, 30})
	void converterTest(@ConvertWith(MemberConverter.class) Member member) {
		...
	}

	@DisplayName("여러 개의 인자는 Aggregator로 변환")
	@ParameterizedTest(name = "{index} {displayName} message={0}")
	@CsvSource({"10, memberA", "20, memberB"})
	void aggregatorTest(@AggregateWith(MemberAggregator.class) Member member) {
		...
	}	

	//컨버터
	static class MemberConverter extends SimpleArgumentConverter {
		@Override
		protected Object convert(Object source, Class<?> targetType) throws ArgumentConversionException {
			assertEquals(Member.class, targetType, "회원 클래스만 변환 가능합니다.");
			return new Member(Integer.parseInt(source.toString()));
		}

	//Accessor
	static class MemberAggregator implements ArgumentsAggregator {
		@Override
    public Object aggregateArguments(ArgumentsAccessor accessor, ParameterContext context) throws ArgumentsAggregationException {
	    Member member = new Member(accessor.getInteger(0), accessor.getString(1));
			return member;
    }
}
```

- 인자 값들의 소스를 넘겨줄 때는 해당 애노테이션들을 사용할 수 있다.
    - @ValueSource, @NullSource, @EmptySource, @NullAndEmptySource 등
- 인자 값 타입 변환
    - 암묵적인 타입변환
    - 명시적인 타입변환
        - `SimpleArgumentConverter` 을 상속받아 컨버터를 구현할 수 있다.
        - `@ConvertWith` 애노테이션에 구현한 클래스를 명시해 해당 컨버터를 사용해 타입변환을 수행한다.
        - 단, 하나의 인자 값일 때만 사용 가능하다.
- 인자 값 조합
    - 여러개의 인자 값을 받을 경우 `ArgumentsAccessor` 를 사용해 각각의 인자 값을 불러올 수 있다.
    - 커스텀 Accessor
        - `ArgumentsAggregator` 인터페이스를 구현해 각각의 인자 값을 원하는 타입으로 커스텀하게 변환할 수 있다.
        - `@AggregateWith` 애노테이션에 구현한 클래스를 명시해 타입 변환을 수행한다.

> [https://junit.org/junit5/docs/current/user-guide/#writing-tests-parameterized-tests](https://junit.org/junit5/docs/current/user-guide/#writing-tests-parameterized-tests)
> 

## JUnit 5: 테스트 인스턴스

- JUnit은 테스트를 메서드마다 테스트 인스턴스를 새로 만든다.
    - 기본 전략
    - 테스트 메서드를 독립적으로 실행해 예상치 못한 부작용을 방지하기 위함이다.
- `@TestInstance(Lifecycle.PER_CLASS)`
    - 테스트 클래스마다 인스턴스를 하나만 만들어 사용하도록 변경한다.
    - 하나의 인스턴스를 공유하기 때문에 `@BeforeEach, @AfterEach` 에서 테스트 간 공유하는 모든 상태를 초기화 해야할 필요가 있다.

## JUnit 5: 테스트 순서

```java
@TestInstance(Lifecycle.PER_CLASS)
@TestMethodOrder(MethodOrdered.OrderAnnotation.class)
class Test {
	@Order(2)
	@DisplayName("두 번째 실행")
	void seconde(){
		...
	}

	@Order(1)
	@DisplayName("첫 번째 실행")
	void first(){
		...
	}
}
```

- 실행할 테스트 메서드는 특정한 순서에 의해 실행되지만 어떻게 그 순서를 정하는 지는 의도적으로 분명히 하지 않는다.
    - 테스트 순서에 의존하지 않고 독립적으로 동일한 결과를 유지해야 하기 때문에 순서를 분명히하지 않는다.
- 경우에 따라 의도적으로 순차적으로 테스트를 수행할 때 `@TestInstance(Lifecycle.PER_CLASS)` 와 함께 `@TestMethodOrder` 를 사용할 수 있다.
    - `@TestMethodOrder` 는 `MethodOrderer` 구현체를 설정해야 한다.
    - 기본 구현체
        - `Alphanumeric`
        - `OrderAnnoation`
        - `Random`

## JUnit 5: 설정 파일

- `src/test/resources/` 에 `junit-platform.properties` 를 생성해 JUnit 설정 파일을 생성할 수 있다.
- 해당 설정 파일에서 JUnit과 관련된 설정을 변경할 수 있다.
    - 테스트 인스턴스 라이프사이클 설정
        - `junit.jupiter.testinstance.lifecycle.default = per_class`
    - 테스트 이름 표기 전략 설정
        - `junit.jupiter.displayname.generator.default = org.junit.jupiter.api.DisplayNameGenerator$ReplaceUnderscores`

## JUnit 5: 확장 모델

- JUnit 5의 확장 모델은 `Extension` 하나다. (JUnit4에 비해 단순화됨)
- 확장팩 등록 방법
    - 선언적인 등록: `@ExtendWith`
    - 프로그래밍 등록: `@RegisterExtension`
    - 자동 등록 자바 `ServiceLoader` 이용

> [https://junit.org/junit5/docs/current/user-guide/#extensions](https://junit.org/junit5/docs/current/user-guide/#extensions)
> 

## JUnit 5: 마이그레이션

- `junit-vintage-engine`을 의존성으로 추가하면, JUnit 5의 junit-platform으로 JUnit 3과 4로 작성된 테스트를 실행할 수 있다.
    - `@Rule` 은 지원하지 않지만 `@EnableRuleMigrationSupport` 를 다음 타입의 Rule을 지원할 수 있다.
        - ExternalResource
        - Verifier
        - ExpectedException

---

# 2. Mockito

Mockito는 Mock 객체를 쉽게 만들고, 관리하고 검증할 수 있는 방법을 제공한다.

- Mock: 진짜 객체와 비슷하게 동작하지만 프로그래머가 직접 그 객체의 행동을 관리하는 객체

## Mockito: 시작하기

```html
<dependency>
    <groupId>org.mockito</groupId>
    <artifactId>mockito-core</artifactId>
    <version>3.1.0</version>
    <scope>test</scope>
</dependency>

<dependency>
    <groupId>org.mockito</groupId>
    <artifactId>mockito-junit-jupiter</artifactId>
    <version>3.1.0</version>
    <scope>test</scope>
</dependency>
```

- 스프링 부트 2.2 이상의 프로젝트를 만든다면, spring-boot-starter-test에서 Mockito 를 추가해준다.

## Mockito: Mock 객체 만들기

```java
@ExtendWith(MockitoExtension.class)
class Test {
	//애노테이션 방식
	@Mock MemberService memberService;
	@Mock MemberRepository memberRepository;

	@Test
	void memberTest() {
		//mock() 방식
		MemberService memberService = Mock.mock(MemberService.class);
    StudyRepository studyRepository = Mock.mock(StudyRepository.class);
	}
}
```

- `@Mock` 애노테이션을 사용해 Mock 객체를 만들 수 있다.
    - 애노테이션으로 Mock 객체를 생성할 때는 JUnit 5 extension으로 `MockitoExtension`을 사용해야 한다.
    - 필드, 메서드 매개변수에 모두 사용 가능하다.
- 애노테이션이 아닌 `mock()` 메서드를 사용해서 Mock 객체를 생성할 수도 있다.
    - 이 방식은 `MockitoExtension` 을 사용할 필요가 없다.

## Mockito: Mock 객체 Stubbing

- 모든 Mock 객체의 행동
    - Null을 리턴(Optional 타입은 Optional.empty)
    - Primitive 타입은 기본 Primitive 값
    - 컬렉션은 빈 컬렉션
    - void 메서드는 예외를 던지지 않고, 아무 일도 발생하지 않는다.
- Mock 객체를 조작해서 위 행동과 다른 행동을 수행하도록 Mock 객체를 조작할 수 있다.
    
    이것을 Stubbing 이라 한다.
    

### Stubbing 예시

- 특정한 매개변수를 받은 경우 특정한 값을 리턴 혹은 예외를 던지도록 만들 수 있다.

```java
//1. 특정한 매개변수를 받은 경우 특정한 값을 리턴 혹은 예외를 던지도록 만들 수 있다.
@Test
void memberTest_with_returnType() {
	Member member = new Member(1L, "memberA");
	when(memberService.findById(any())).thenReturn(Optional.of(member));

	Optional<Member> findMember = memberService.findById(1L);
	assertEquals("memberA", findMember.get().getUsername()); //True
}

//2. void 메서드가 호출된 경우 예외를 발생 시킬 수 있다.
@Test
void memberTest_with_void() {
	Member member = new Member(1L, "memberA");
	
	doThrow(new IllegalArgumentException()).when(memberService).registerMember(1L);

	assertThrows(IllegalArgumentException.class, () -> {
            memberService.registerMember(1L);
  });
}

//3. 메서드가 동일한 매개변수로 여러번 호출될 때 각기 다르게 행동하도록 조작할 수 있다.
@Test
void memberTest_repeat() {
	Member member = new Member(1L, "memberA");
	
	when(memberService.findById(any())
		.thenReturn(Optional.of(member)) //첫 번째 호출
		.thenTrow(new RuntimeException())//두 번째 호출
		.thenReturn(Optional.empty());   //그 이후(3~...)

	Optional<Member> findMember = memberService.findById(1L);
	assertEquals("memberA", findMember.get().getUsername()); //True

	assertThrows(RuntimeException.class, () ->
						memberService.findById(2L)); //True

	assertEquals(Optional.empty, memberService.findById(3L)); //True
}

when(memberService.findById(1L)).thenReturn(member);
when(studyRepository.save(study)).thenReturn(study);
```

- `when(), doThrow()` 등의 메서드를 사용하면, Mock 객체를 조작할 수 있다.
- Mock 객체에 전달할 임의의 값을 `ArgumentMatcher` 를 사용해 넘겨줄 수 있다.
    - `any(), anyChar()` 등

> [Argument matchers](https://javadoc.io/doc/org.mockito/mockito-core/latest/org/mockito/Mockito.html#3)
> 

## Mockito: Mock 객체 정보 확인

```java
@Test
void memberTest() {
	Member member = new Member(1L, "memberA");

	memberService.registerMember(member);

	//호출 정보
	verify(memberService, never()).findByUsername(any());
	verify(memberService, times(1)).save(member);
}
```

- `verify()` 메서드를 사용하면 Mock 객체가 어떻게 사용되었는지 여러 정보를 확인할 수 있다.
    - 특정 메서드가 특정 매개변수로 몇번 호출 되었는지, 전혀 호출되지 않았는지
    - 어떤 순서대로
    - 특정 시간이내에
    - 특정 시간 이후에

## Mockito: BDD 스타일 Mockito API

- BDD: **애플리케이션이 어떻게 행동해야 하는지**에 대한 공통된 이해를 구성하는 방법, TDD에서 창안됨
- Mockito BDD 스타일 API를 사용하면 BDD 스타일에 맞지 않는 메서드 이름을 BDD 스타일에 맞게 변경해준다.
    - When → Given
        
        `given(memberService.findById(1L)).willReturn(Optional.of(member));`
        
    - Verify → Then
        
        `then(memberService).should(times(1)).notify(study);`
        

---

# 3. 도커와 테스트

- Testcontainers는 테스트에서 도커 컨테이너를 실행할 수 있는 라이브러리다.
    - 테스트 실행시 DB를 설정하거나 별도의 프로그램 또는 스크립트를 실행할 필요가 없다.
    - 보다 Production에 가까운 테스트를 만들 수 있다.
    - 테스트가 느려진다.

## Testcontainers: 시작하기

```html
<!--JUnit5 를 지원하는 tesetConainers-->
<dependency>
    <groupId>org.testcontainers</groupId>
    <artifactId>junit-jupiter</artifactId>
    <version>1.15.1</version>
    <scope>test</scope>
</dependency>
<!--DB 관련 모듈-->
<dependency>
    <groupId>org.testcontainers</groupId>
    <artifactId>mysql</artifactId>
    <version>1.17.3</version>
    <scope>test</scope>
</dependency>
```

- 두 의존성을 추가해 Testcontainer와 사용하는 DB 모듈을 설치한다.

**MemberTest.java**

```java
@SpringBootTest
@Testcontainers
public class MemberTest {
	@Autowired MemberRepository memberRepository;

  @Container
  static PostgreSQLContainer postgreSQLContainer = new PostgreSQLContainer("dockerImageName")
          .withDatabaseName("testDB");

	@BeforeEach
	void beforeEach() {
		memberRepository.deleteAll();
	}
}
	
```

- `@Testcontainers`
    - JUnit 5 확장팩으로 테스트 클래스에 `@Container`를 사용한 필드를 찾아서 컨테이너 라이프 사이클 관련 메서드를 실행해준다.
- `@Container`
    - 인스턴스 필드에 사용하면 모든 테스트 마다 컨테이너를 재시작
    - 스태틱 필드에 사용하면 클래스 내부 모든 테스트에서 동일한 컨테이너를 재사용한다.
        - 모든 테스트에서 같은 컨테이너를 사용하기 때문에 독립적인 테스트를 위해, 테스트 실행 전 혹은 후에 DB 상태를 초기화해 줄 필요가 있다.
- `withDatabaseName()`
    - `Testcontainers` 를 사용하면 포트 정보와 호스트 정보는 중요하지 않다.
    - 데이터베이스 이름을 설정하면, 그에 맞는 JdbcUrl에 매핑된다.

**application-test.properties**

```html
spring.datasource.url=jdbc:tc:postgresql:9.6.8:///databasename
spring.datasource.driver-class-name=org.testcontainers.jdbc.ContainerDatabaseDriver
```

- Testcontainers를 사용하면, 원하는 JdbcUrl 에 DB를 생성하지 않고 임의의 포트에 생성한다.
- 따라서 별도로 매핑하는 과정이 필요하다.
    - 호스트 정보(host)와 포트 정보(port)는 중요하지 않다.

## Testcontainers: 기능

- `New GenericContainer(String imageName)`: 컨테이너 생성
- 네트워크
    - `withExposedPorts(int...)`
    - `getMappedPort(int)`
- 환경 변수 설정
    - `withEnv(key, value)`
- 명령어 실행
    - `withCommand(String cmd...)`
- 사용할 준비가 됐는지 확인하기
    - `waitingFor(Wait)`
    - `Wait.forHttp(String url)`
    - `Wait.forLogMessage(String message)`
- 로그 살펴보기
    - `getLogs()`
    - `followOutput()`

## Testcontainers: 스프링 테스트에서 참조하기

```java
@SpringBootTest
@Testcontainers
@ContextConfiguration(initializers = MemberTest.ContainerPropertyInitializer.class)
public class MemberTest {

    @Container
    static PostgreSQLContainer postgreSQLContainer = new PostgreSQLContainer("dockerImageName")
            .withDatabaseName("testDB");

    @Autowired Environment environment;

    @BeforeEach
    void beforeEach() {
        System.out.println(environment.getProperty("container.port"));
    }

    static class ContainerPropertyInitializer implements ApplicationContextInitializer<ConfigurableApplicationContext> {
        @Override
        public void initialize(ConfigurableApplicationContext context) {
            TestPropertyValues.of("container.port=" + postgreSQLContainer.getMappedPort(5432))
                    .applyTo(context.getEnvironment());
        }
    }
}
```

- 전체 흐름
    1. Testcontainer를 사용해서 컨테이너 생성
    2. `ApplicationContextInitializer`를 구현하여 생선된 컨테이너에서 정보를 축출하여 `Environment`에 넣어준다.
    3. `@ContextConfiguration`을 사용해서 `ApplicationContextInitializer` 구현체를 등록한다.
    4. 테스트 코드에서 Environment, @Value, @ConfigurationProperties 등 다양한 방법으로 해당 프로퍼티를 사용한다.
- `@ContextConfiguration`
    - 스프링이 제공하는 애노테이션
    - 스프링 테스트 컨텍스트가 사용할 설정 파일 또는 컨텍스트를 커스터마이징할 수 있는 방법을 제공한다.
- `ApplicationContextInitializer`
    - 스프링 `ApplicationContext`를 프로그래밍으로 초기화 할 때 사용할 수 있는 콜백 인터페이스
    - 특정 프로파일을 활성화 하거나, 프로퍼티 소스를 추가하는 등의 작업을 할 수 있다.
- `Environment`
    - 스프링 핵심 API
    - 프로퍼티와 프로파일을 담당한다.
- `TestPropertyValues`
    - 테스트용 프로퍼티 소스를 정의할 때 사용한다.

## Testcontainers: 도커 Compose 사용하기

```java
@SpringBootTest
@Testcontainers
public class MemberTest {

    @Container
    static DockerComposeContainer dockerComposeContainer
								= new DockerComposeContainer(new File("src/test/resouces/docker-compose.yml"));
}
```

- Docker Compose
    - 여러 컨테이너를 한번에 띄우고 서로 간의 의존성 및 네트워크 등을 설정할 수 있는 방법
    - docker-compose up / down
- Testcontainser의 docker compose 모듈을 사용해 적용할 수 있다.
    - `DockerComposeContainer`
