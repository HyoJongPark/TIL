# 토비의 스프링
![image](https://user-images.githubusercontent.com/75190035/153540041-2a9030b4-724b-4d9f-be6b-e44c0df69728.png)

# 2. 테스트

스프링이  개발자에게 제공하는 가장 중요한 가치 중 하나가 테스트다.

테스트는 코드를 확신할 수 있게 만들어주고, 변화에 유연하게 대처할 수 있는 자신감을 준다.

### 작은 단위의 테스트

테스트하고자 하는 대상이 명확하다면 그 대상에만 집중해 테스트하는 것이 바람직하다.

한꺼번에 많은 기능을 몰아서 테스트하면 과정도 복잡해지고, 테스트 실패의 원인을 찾는게 힘들어진다.

따라서 테스트는 가능한 작은 단위로 쪼개서 집중할 수 있어야 한다. (관심사의 분리라는 원리가 여기에도 적용된다) 테스트의 관심이 다르다면 테스트할 대상을 분리하고 집중해서 접근해야한다. 이런 작은 단위의 코드에 대해서 테스트를 수행한 것을 **단위 테스트**라고 한다.

이렇게 작은 단위로 나눠서 테스트하는 단위 테스트가 필요한 이유는 개발자가 설계하고 많든 코드가 원래의 의도대로 동작하는지를 개발자 스스로 빨리 확인받기 위해서다.

### **단위테스트와 DB사용**

어떤 개발자는 테스트 중에 DB를 사용하면 단위 테스트가 아니라고한다. 그러나 사용할 DB의 상테를 테스트가 관장하고 있다면 단위 테스트라고 해도 된다.

하지만, DB의 상태가 매번 달라지고, 테스트를 위해 DB를 특정 상태로 만들어 줄 수 없다면 그때는 단위 테스트라고 할 수 없다.

이런 차원에서 통제할 수 없는 외부 리소스에 의존하는 테스트는 단위 테스트가 아니라고 보기도 하는 것이다.

### **자동 수행 테스트 코드**

코드의 기능을 확인하기 위해서 매번 웹 폼을 띄우고, 스스로 값을 입력하는 등의 과정을 매번 반복하는것은 번거로울 뿐만아니라 시간도 오래걸린다.

그러나 main메소드 등의 방법을 사용해 자동적으로 수행되는 테스트코드를 작성하면 이런 과정없이 빠른 시간에 테스트를 끝내고 수정할 수 있다.

자동적으로 수행되는 테스트의 장점은 자주 반복할 수 있다는 것 뿐만아니라 간단한 코드 수정 이후에 발생할 수 있는 심각한 문제를 테스트를 수행함으로써 기능에 문제가 발생하는지 확인하고, 성공한다면 코드에 대한 확신을 얻을 수 있는 것이다.

---

## JUnit 테스트 전환

기존에 main 메소드로 작성한 코드는 간단해 보일지 몰라도, 단위 테스트가 많아질수록 일일이 하나의 main메소드를 실행하는 과정을 번거로울 수밖에 없고, 테스트의 결과를 `System.out.println()` 등의 출력코드로 일일이 확인하는 과정 또한 많은 테스트가 수행된다면 어려울 것이다.

이런 번거로움을 JUnit 등의 테스트 프레임워크로 해결할 수 있다.

### **테스트 메소드 전환**

JUnit은 프레임워크다. 프레임워크의 기본 동작원리가 **제어의 역전**이다.

프레임워크는 개발자가 만든 클래스에 대한 제어 권한을 넘겨받아 주도적으로 애플리케이션의 흐름을 제어한다. 개발자가 만든 클래스의 오브젝트를 생성하고 실행하는 일은 프레임워크에 의해 진행된다. 따라서 프레임워크에서 동작하는 코드는 main 메소드도 필요없고 오브젝트를 만들어 실행시키는 코드또한 필요없다.

새로만들 테스트 메소드는 JUnit 프레임워크가 요구하는 조건 2가지를 따라야 한다.

1. ~~메소드가 public 으로 선언돼야 한다.~~ → JUnit5 이후 public선언을 하지않아도 동일하게 동작함
2. 메소드에 @Test 애노테이션을 붙혀준다.

또한, main메소드를 사용하지 않음으로 메소드 이름으로 테스트의 의도를 드러낼 수 있는 이름을 사용한다.

### **검증 코드 전환**

테스트의 검증을 위해 일반 코드에서는 `if/else` 문으로 결과를 검증하지만, JUnit에서는 `assertThat`, `assertThrows` 등의 메소드를 사용해 예외, 결과 검증을 수행한다.

```java
if (a==b) //일반적인 검증

assertThat(a).isEqualTo(b) //JUnit 검증

assertThrows(Exception.class, () -> 예외 발생 코드) //JUnit 예외 검증
```

### **JUnit 테스트 실행**

JUnit 프레임워크도 자바 코드로 만들어진 프로그램이므로 어디선가 실행시켜 줘야한다.

어디서든 main() 메소드를 하나 추가하고, 그 안에 `JUnitCore` 클래스의 main 메소드를 호출해주는 간단한 코드를 넣어주면 된다. 메소드 파라미터에는 `@Test` 를 가진 메소드를 가진 클래스의 이름을 넣어준다.

```java
import org.junit.runner.JUnitCore;

public static void main(String[] args){
	JUnitCore.main("springbook.user.dao.UserDaoTest");
}
```

대부분의 자바IDE는 JUnit 테스트를 손쉽게 실행할 수 있는 JUnit 테스트 지원 기능을 내장하고 있어서 더욱 편리하게 JUnit 테스트를 만들고 활용할 수 있게 해준다.

---

## JUnit 프레임워크

JUnit프레임워크는 사실상 자바의 표준 테스팅 프레임워크로 불릴 만큼 폭넓게 사용되고 있다.

JUnit 테스트는 main() 메소드와 `System.out.println()`으로 작성된 테스트만큼 단순하기 때문에 빠르게 작성 가능하며, 테스트 작성시 자주 필요한 여러 부가기능도 제공한다.

### JUnit 테스트 실행 방법

이전에 `JUnitCore`를 사용해 등록하는 방법은 테스트 수가 늘어남에 따라 관리하기 힘들어 질 수 있다. 자바 IDE에 내장된 JUnit 테스트 지원도구를 활용하면 번거로운 등록과정 없이 테스트를 실행할 수 있다.

### JUnit의 순서

JUnit은 테스트 실행 순서를 보장해주지 않는다. 만약 테스트 실행 순서에 의해 영향을 받는 테스트를 작성했다면, 테스트를 잘못 작성한 것이다.

### 빌드 툴

빌드 툴에서 제공하는 JUnit 플러그인이나 테스크를 이용해 JUnit 테스트를 실행할 수 있다. 옵션에 따라서 HTML이나 텍스트 파일의 형태로 보기 좋게 만들어 진다.

개발자 개인별로는 IDE에서 JUnit 도구를 활용해 테스트를 실행하는게 가장 편리하다. 그런데 여러 개발자가 만든 코드를 모두 통합해 테스트를 수행해야할 경우에는 서버에서 모든 코드를 가져와 통합하고 빌드한 뒤에 테스트를 수행하는 것이 좋다. 이때는 빌드 스크립트를 이용해 JUnit 테스트를 실행하고, 결과를 메일등으로 통보받는 방법을 사용하면 된다.

### 동일한 결과를 보장하는 테스트

단위 테스트는 코드가 바뀌지 않는다면 매번 실행할 때마다 동일한 테스트 결과를 얻을 수 있어야 한다. DB에 남아있는 데이터와 같은 외부 환경에 영향을 받지 말아야 하는 것은 물론이고, 테스트를 실행하는 순서를 바꿔도 동일한 결과를 보장하도록 만들어야한다.

### 포괄적인 테스트

**꼼꼼한 테스트를 작성하자**

만약 getCount() 라는 DB에 값을 추가할 때마다 카운트를 세주는 메소드를 테스트한다고 가정하자.

이때 테이블이 비어있는 경우와 값을 1개 추가했을 경우를 테스트를 정상적으로 수행해도 나머지 결과에 대한 결과를 막연히 잘되겠다고 생각하는건 좋은 자세가 아니다.

미처 생각하지 못한 문제가 숨어 있을지도 모르니 더 꼼꼼한 테스트를 해보는 것이 좋은 자세다. 성의없이 테스트를 만드는 바람에 문제가 있는 코드인데도 테스트가 성공하게 만드는 것이 더 위험하다. 특히 한기지 결과만 검증하고 마는 것은 상당히 위험하다.

**실패 케이스의 테스트를 먼저 작성하자**

또한 개발자가 자주하는 실수는 성공하는 테스트만 골라서 작성하는 것이다. 개발자는 머릿속으로 이 코드가 잘돌아가는 케이스를 상상하면서 코드를 만드는 경우가 일반적이다. 그래서 테스트를 만들때 문제가 될만한 상황이나, 값등을 교묘히 잘 피해서 코드를 만드는 습성이 있다. 

또한 개발자는 빨리 테스트를 만들어 성공하는 것을 보고 다음 기능으로 나아가고 싶어하기 때문에 긍적적인 경우를 골라 성공할 만한 테스트를 먼저 작성하게 되기가 쉽다. 그래서 테스트를 작성할 때, 부정적인 케이스를 먼저 만드는 습관을 들이는게 좋다. 

### TDD (테스트가 이끄는 개발)

**테스트 주도 개발**

만들고자 하는 기능의 내용을 담고 있으면서 만들어진 코드를 검증도 해줄 수 있도록 테스트 코드를 먼저 만들고, 테스트를 성공하게 해주는 코드를 작성하는 방식의 개발 방법이 있다.

이것을 **테스트 주도 개발 (TDD) 혹은** 테스트를 먼저 작성한다고 해서 **테스트 우선 개발** 이라고도 한다, TDD는 개발자가 테스트틀 만들어가며 개발하는 방법이 주는 장점을 극대화한 방법이라고 볼 수 있다.

TDD는 테스트를 먼저 만들고 테스트가 성공하도록 하는 코드만 만드는 식의 작업을 진행하기 때문에 테스트를 빼먹지 않고 꼼꼼하게 만들어 낼 수 있다.

또한 코드 작성과 테스트 수행까지 걸리는 시간이 0에 가깝다. 그 덕분에 코드에 대한 피드백을 매우 빠르게 받을 수 있게 된다. 빨리 발견된 오류는 쉽게 대응이 가능해 이 또한 큰 장점이 된다.

TDD에서는 테스트를 작성하고 성공시키는 코드를 만드는 작업의 주기를 가능한 짧게 가져가는 것을 권장한다. 테스트를 반나절 동안 만들고 코드를 만드는 식의 개발은 좋은 방법이 아니다.

### 테스트 코드 개선

JUnit의 기능을 이용하면 더 좋은 테스트 코드로 개선이 가능하다.

예를들어 만약 모든 테스트 케이스를 수행하기 전에 공통으로 수행해야할 작업이 있다면, `@BeforeEach` 같은 애노테이션으로 중복을 제거해 주고, 그로인해 가독성이 좋은 코드를 작성할 수 있다.

**JUnit 테스트 수행 방식**

1. 테스트 클래스에서 @Test가 붙은 void 형이며 파라미터가 없는 테스트 메소드를 모두 찾는다.
2. 테스트 클래스의 오브젝트를 하나 만든다.
3. `@BeforeEach` 등이 붙은 메소드가 있으면 먼저 실행한다.
4. `@Test`가 붙은 메소드를 하나 호출하고, 테스트 결과를 저장해둔다.
5. `@After`가 붙은 메소드가 있으면 실행한다.
6. 나머지 테스트에 대해 2~5번 반복
7. 모든 테스트의 결과를 종합해서 돌려준다.

실제로는 이보다 복잡하며, 여기서 사용하지 않은 애노테이션은 제외했다.

여기서 기억해야할 점은 **테스트 메소드를 실행할 때마다 테스트 클래스의 오브젝트를 새로 생성한다는 점이다.** 한번 만들어진 테스트 클래스의 오브젝트는 한번 사용하고 나면 버려진다. 

이것은 JUnit 개발자는 각 테스트가 서로 영향을 주지 않고 독립적으로 실행됨을 확실히 보장하기 위해서 매번 새로운 오브젝트를 만들게 한 것이다.

### 픽스처

테스트를 수행하는데 필요한 정보나 오브젝트를 픽스처라고 한다. 일반적으로 픽스처는 여러 테스트에서 반복적으로 사용되기 때문에 **`@BeforeEach`**를 사용해 생성해 두는 편이 편리하다.

```java
public class UserDaoTest{
	private UserDao dao;
	private User user1;
	private User user2;
	private User user3;

	@BeforeEach
	void setUp(){
		...
		this.user1=new User("userA", "Hong", "password1");
		this.user1=new User("userB", "Choi", "password2");
		this.user1=new User("userC", "Park", "password3");
	}
```

---

## 스프링 테스트 적용

### 테스트를 위한 컨텍스트 관리

스프링은 JUnit을 이용하는 테스트 컨텍스트 프레임워크를 제공한다. 이것을 사용하면 간단한 설정만으로 모든 테스트가 애플리케이션 컨텍스트를 공유하게 할 수 있다.

```java
@ExtendWith(SpringExtension.class)
@ContextConfiguration(locations = "/test-applicationContext.xml")
class UserDaoTest {
	@Autowired
	private ApplicationContext context;
	...
}
```

여기서 `@ExtendsWith` 는 JUnit프레임워크의 테스트 실행 방법을 확장할 떄 사용하는 애노테이션이다. `~~SpringExtension.class`를 지정해주면 JUnit이 테스트를 진행하는 중에 테스트가 사용할 애플리케이션 컨텍스트를 만들고 관리하는 작업을 진행해준다.~~ (JUnit5에서는 위와같은 애노테이션을 지원함-TODO)

`@ContextConfiguraion` 은 자동으로 만들어줄 애플리케이션 컨텍스트 설정파일의 위치를 지정한 것이다. 이것으로 인해 실행할 때에만 컨텍스트 생성으로 가장 많은 시간이 소요되고 이후부터는 짧아진다. 다른 테스트 클래스에서도 같은 설정파일을 사용한다면 이미 생성되어 있는 컨텍스트를 공유한다.

```java
@ExtendWith(SpringExtension.class)
@ContextConfiguration(locations = "/test-applicationContext.xml")
class UserDaoTest {
	@Autowired
	private UserDao dao;
	...
}
```

이미 `applicationContext.xml`에는 `UserDao` 타입의 빈이 존재함으로 위와같은 방식으로 주입하는 것 또한 가능하다.

테스트 컨텍스트 프레임워크는 `applicationContext.xml` 에 정의된 빈 뿐만아니라 본인도 빈으로 등록한다.

빈을 주입하는 과정은 먼저 같은 타입의 빈을 찾고, 이후에는 같은 이름의 빈을 찾는다. 둘다 찾을 수 없는 경우 예외가 발생한다.

### 테스트 코드에 의한 DI

`@DirtiesContext` 를 사용하면 테스트 메소드에서 애플리케이션 컨텍스트의 구성이나 상태를 변경한다는 것을 테스트 컨텍스트 프레임워크에 알려준다. 이 애노테이션이 붙은 테스트 클래스에는 컨텍스트 공유를 허용하지 않는다. 테스트 메소드를 수행한 뒤 새로운 애플리케이션 컨텍스트를 생성해 뒤의 테스트가 사용하도록 해준다.

이 방식을 사용함으로써 XML 파일을 사용하지 않고도 테스트 코드를 통해 오브젝트 관계를 재구성할 수 있다. 다만, 단점이 많음으로 새로운 설정파일을 생성해 테스트에서 사용하도록 하는 방식도 고려해야한다.

> 메소드레벨에 `@DirtiesContext`를 사용할 수 있다. 메소드레벨에 붙히면 해당 메소드가 끝난후 새로운 애플리케이션 컨텍스트를 생성한다.
> 

### 컨테이너 없는 DI 테스트

```java
public class UserDaoTest{
	UserDao dao;
	...
	
	@BeforeEach
	void setUp(){
		...
		dao = new UserDao();
		DataSource dataSource = new SingleConnectionDataSource(
			"jdbc:mysql://localhost/tobi_spring", "tobi_spring", "test", true);
		dao.setDataSource(dataSource);
	}
	...
}
```

위 코드처럼 스프링 컨테이너 없이 DI를 진행시키는 방식도 있다. 이 방식은 스프링을 모르는 사람도 이해할 수 있다는 장점, 애플리케이션 컨텍스트가 만들어 지지않아 시간이 절약된다는 장점이 있다.

다만, UserDao가 가벼운 오브젝트가 아니라면 계속해서 새로운 오브젝트를 생성하는건 부담일 수 있다.

> 침투적 기술과 비침투적 기술
> 
> 
> 침투적 기술은 기술을 적용했을 때 애플리케이션 코드에 기술 관련 API가 등장하거나 특정 인터페이스나 클래스를 사용하도록 강제하는 기술을 말한다. 침투적 기술을 사용하면 애플리케이션 코드가 해당 기술에 종속되는 결과를 가져온다.
> 
> 반면에 비침투적 기술은 애플리케이션 로직을 담은 코드에 아무런 영향을 주지 않고 적용이 가능하다. 따라서 기술에 종속적이지 않은 순수한 코드를 유지할 수 있게 해준다. 스프링은 이런 비침투적인 기술의 대표적인 예다. 그래서 스프링 컨테이너 없는 DI또한 가능한 것이다.
> 

### DI를 이용한 테스트 방법 선택

- 가장 우선적으로 스프링 컨테이너 없이 테스트하는 방법 고려
    - 테스트 수행 속도가 가장 빠르고 테스트가 간결하다.
    - 테스트를 위해 필요한 오브젝트의 생성과 초기화가 단순하다면 이 방식을 고려해 사용
- 스프링 컨테이너를 이용한 DI
    - 여러 오브젝트와 복잡한 의존관계를 갖고있는 오브젝트를 테스트해야할 경우 사용
    - 테스트에서 애플리케이션 컨텍스트를 사용할 경우 테스트용 설정파일을 별도로 사용
        - 테스트, 개발, 운영환경의 차이가 있기 때문
- `@DirtiesContext` 를 사용한 수동 DI
    - 예외적인 의존관계를 강제로 구성해야할 경우 사용

---

## 학습 테스트

때로 자신이 만들지 않은 프레임워크나 다른 개발팀에서 만들어서 제공한 라이브러리 등에 대해서도 테스트를 작성해야한다. 이런 테스트를 **학습 테스트**라고한다.

학습 테스트의 목적을 자신이 사용할 API나 프레임워크의 기능을 테스트로 보며 사용법을 익히는 것이다. 

- 장점
    - 다양한 조건에 따른 기능을 손쉽게 확인해 볼 수 있다.
    - 학습 테스트 코드를 개발 중에 참고할 수 있다.
    - 프레임워크나 제품을 업그레이드할 때 호환성 검증을 도와준다.
    - 테스트 작성에대한 좋은 훈련이 된다.
    - 새로운 기술을 공부하는 과정이 즐거워진다.

### 버그 테스트

버그 테스트란 코드에 오류가 있을 때 그 오류를 가장 잘 드러내줄 수 있는 테스트를 말한다.

버그 테스트는 일단 실패하도록 만들어야 한다. 버그가 원인이 되어서 테스트가 실패하는 코드를 만드는 것이다. 그러고 나서 코드를 수정 → 테스트가 성공한다면 버그는 해결된 것이다.

- 장점
    - 테스트의 완성도를 높혀준다.
    - 버그의 내용을 명확하게 분석해 준다.
    - 기술적인 문제를 해결하는데 도움이 된다.

> **동등분할**
> 
> 
> 같은 결과를 내는 값의 범위를 구분해서 각 대표 값으로 테스트하는 방법을 말한다. 어떤 작업 결과의 종류가 true, false 또는 예외발생 3가지라면, 각 결과를 내는 입력 값이나 상황의 조합을 만들어 모든 경우에 대한 테스트를 해보는 것이 좋다.
> 
> **경계값 분석**
> 
> 에러는 동등분할 범위의 경계에서 주로 많이 발생한다는 특징을 이용해서 경계의 근처에 있는 값을 이용해 테스트하는 방법이다. 보통 숫자의 입력 값인 경우 0이나 그 주변 값 또는 정수의 최대값, 최소값 등으로 테스트해보면 도움이 될 때가 많다.
>
