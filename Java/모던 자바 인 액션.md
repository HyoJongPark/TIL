# 모던 자바 인 액션

<img src="https://user-images.githubusercontent.com/75190035/155264476-7167c8c1-7447-4235-8163-8400017ba9e0.png" width="500" width="500">

- [2. 동작 파라미터화 코드 전달하기](https://github.com/HyoJongPark/TIL/new/main/Java#2-%EB%8F%99%EC%9E%91-%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0%ED%99%94-%EC%BD%94%EB%93%9C-%EC%A0%84%EB%8B%AC%ED%95%98%EA%B8%B0)
- [3. 람다 표현식](https://github.com/HyoJongPark/TIL/edit/main/Java/%EB%AA%A8%EB%8D%98%20%EC%9E%90%EB%B0%94%20%EC%9D%B8%20%EC%95%A1%EC%85%98.md#3-%EB%9E%8C%EB%8B%A4-%ED%91%9C%ED%98%84%EC%8B%9D)

---

# 2. 동작 파라미터화 코드 전달하기

### 동작 파라미터화란?

아직은 어떻게 실행할 것인지 결정하지 않은 코드 블록을 의미한다. 이 코드 블록은 나중에 프로그램에서 호출한다.(즉, 코드 블록의 실행은 나중으로 미뤄진다.)

동작 파라미터화를 이용하면 자주 바뀌는 요구사항에 효과적으로 대응할 수 있다.

### 1. 녹색 사과 필터링

```java
public static List<Apple> filterGreenApples(List<Apple> inventory){
	List<Apple> result = new ArrayList<>();
	for (Apple apple : inventory){
		if (GREEN.equals(apple.getColor()) result.add(apple);
	}
	return result;
}
```

만약 위 코드에서 필터링 할 색을 변경해야할 경우 if문의 조건을 변경하는 방법을 사용할 수도 있지만, 나중에 더 다양한 색으로 필터링하는 등의 변화에는 적절하게 대응할 수 없을 것이다.

이런 상황에서는 다음과 같은 규칙이 있다.

**거의 비슷한 코드가 반복 존재한다면, 그 코드를 추상화한다.**

### 2. 색을 파라미터화

 색을 파라미터화 할 수 있도록 메서드에 파라미터를 추가하면, `filterGreenApples` 의 코드를 반복 사용하지 않고 `filterRedApples` 를 구현할 수 있고, 결과적으로 변화하는 요구사항에 좀 더 유연하게 대응하는 코드를 만들 수 있다.

```java
public static List<Apple> filterApplesByColor(List<Apple> inventory, Color color){
	List<Apple> result = new ArrayList<>();
	for (Apple apple : inventory){
		if (apple.getColor().equals(color)) result.add(apple);
	}
	return result;
}
```

위와같이 변경하면, 모든 색에 대해 필터링 가능한 메서드가 만들어진다. 그런데 무게에 따른 필터링이 요구사항으로 발생한다면 어떨까?

```java
public static List<Apple> filterApplesByWeight(List<Apple> inventory, int weight){
	List<Apple> result = new ArrayList<>();
	for (Apple apple : inventory){
		if (apple.getWeight() > weight) result.add(apple);
	}
	return result;
}
```

위 코드로 해결할 수 있겠지만 색 필터링의 코드와 대부분 중복되는 코드다. 이는 DRY(같은 것을 반복하지 말 것)라는 소프트웨어 원칙을 어기는 것이다.

### 3. 가능한 모든 속성으로 필터링

플래그라는 파라미터를 추가해 어떤 것을 기준으로 필터링 할지 구분할 수 있다.(실전에서 사용권장 x)

```java
public static List<Apple> filterApples(List<Apple> inventory, Color color, 
																			 int weight, boolean flag){
	List<Apple> result = new ArrayList<>();
	if ((flag && apple.getColor().equals(color)) ||
			(!flag && apple.getWeigt > weight)){
		result.add(apple);
	}
	return result;
}
```

위 코드에서 true와 false가 무엇을 의미하는지 불분명하고, 요구사항이 바뀌었을 때 유연하게 대응할 수도 없다.

## 동작 파라미터화

```java
public interface ApplePredicate{
	boolean test(Apple apple);
}
```

```java
public class AppleHeavyWightPredicate implements ApplePredicate{
	public boolean test(Apple apple){
		return apple.getWeight() > 150;
	}
}
```

```java
public class AppleGreenColorPredicate implements ApplePredicate{
	public boolean test(Apple apple){
		return GREEN.equals(apple.getColor());
	}
}
```

위 조건에 따라 filter메서드가 다르게 동작할 것이라고 예상할 수 있다. 이를 전략 디자인 패턴이라고 부른다.

전략 디자인 패턴은 각 알고리즘(`AppleHeavyWieghtPredicate, AppleGreenColorPredicate`)을 캡슐화 하는 알고리즘 패밀리(`ApplePredicate`)를 정의해둔 다음에 런타임에 알고리즘을 선택하는 기법이다.

`ApplePredicate` 객체를 `FilterApples` 에서 받아 검사하도록 변경하면, 메서드가 다양한 동작을 받아서 내부적으로 다양한 동작을 수행할 수 있게된 것이다.(**동작 파라미터화**)

### 4. 추상적 조건으로 필터링

```java
public static List<Apple> filterApples(List<Apple> inventory, ApplePredicate p){
	List<Apple> result = new ArrayList<>();
	for(Apple apple : inventory){
		if(p.test(apple)) result.add(apple);
	}
	return result;
}
```

가장 처음의 코드보다 가독성, 유연성, 사용성 면에서 우수한 코드가 만들어 졌다. 이제 변경된 요구사항은 구현된 알고리즘의 수정혹은 또다른 전략의 구현으로 적절히 대응할 수 있다. 

실제 사용에서 적용할 때 구현한 알고리즘을 파라미터로 전달해 원하는 결과를 얻을 수 있다.

```java
List<Apple> greenApples = filterApples(inventory, new AppleGreenColorPredicate());
```

### 5. 익명 클래스 사용

```java
List<Apple> greenApples = filterApples(inventory, new ApplePredicate(){
	public boolean test(Apple apple){
		return RED.equals(apple.getColor());
	}
});
```

익명 클래스로 구현된 객체를 사용하면 2가지 단점이 있다.

1. 여전히 많은 공간을 차지한다.
    - 여러 클래스를 정의할 코드를 줄이기 위해서 사용했지만, 여전히 많은 공간을 차지한다.
2. 많은 프로그래머가 익명 클래스 사용에 익숙하지 않다.

코드의 장황함은 나쁜 특성이다. 장황한 코드는 구현, 유지보수하는데 시간이 많이 걸리고 가독성도 좋지않다. 익명 클래스로 인터페이스를 구현하는 클래스를 선언하는 과정을 줄일 수 있지만 만족스럽지 않다.

자바 8에서는 동작 파라미터화의 다음과 같은 문제를 람다 표현식이라는 간단한 코드 전달 기법을 도입해 해결했다.

### 6. 람다 표현식 사용

```java
List<Apple> result = filterApples(inventory, (Apple apple) -> RED.equals(apple.getColor()));
```

익명 클래스에 비해 람다 표현식을 사용했을 때 더 간결한 코드를 만들 수 있다.

### 7. 리스트 형식으로 추상화

```java
public interface Predicate<T>{
	boolean test(T t);
}
```

```java
public static <T> List<T> filter(List<T> list, Predicate<T> p){
	List<T> result = new ArrayList<>();
	for (T e : list){
		if(p.test(e)) return result.add(e);
	}
	return result;
}
```

이제 사과 뿐만 아니라 다른 요소들도 해당 기능을 사용해 구분할 수 있게 됐다.

### 정리

- 동작 파라미터화에서는 메서드 내부적으로 다양한 동작을 수행할 수 있도록 코드를 메서드 인수로 전달한다.
- 동작 파라미터화를 이용하면 변화하는 요구사항에 더 잘 대응할 수 있는 코드를 구현할 수 있으며, 나중에 엔지니어링 비용을 줄일 수 있다.
- 코드 전달 기법을 이용하면 동작을 메서드 인수로 전달할 수 있다.
    - 자바 8 이전에는 지저분한 코드
    - 익명 클래스를 사용해 1차 개선
    - 람다 표현식을 사용해 인터페이스를 상속받아 여러 클래스를 구현해야하는 수고를 없앨 수 있게됨.
- 자바 API의 많은 메서드는 정렬, 스레드, GUI 처리 등을 포함한 다양한 동작으로 파라미터화 할 수 있다.

---

# 3. 람다 표현식

## 람다란?

람다 표현식은 메서드로 전달할 수 있는 익명 함수를 단순화 한 것이다. 람다 표현식에는 이름은 없지만, 파라미터 리스트, 바디, 반환 형식, 발생할 수 있는 예외 리스트는 가질 수 있다.

### 람다의 특징

- 익명
    - 보통의 메서드와 달리 이름이 없으므로 익명이라 표현한다. 구현해야 할 코드에 대한 걱정거리가 줄어든다.
- 함수
    - 람다는 메서드처럼 특정 클래스에 종속되지 않으므로 함수라고 부른다. 하지만 메서드처럼 파라미터 리스트, 바디, 반환 형식, 예외 리스트를 포함한다.
- 전달
    - 람다 표현식을 메서드 인수로 전달하거나 변수로 저장할 수 있다.
- 간결성
    - 익명 클래스처럼 많은 자질구레한 코드를 구현할 필요가 없다.

람다는 기술적으로 자바 8 이전에 할 수 없었던 일을 지원하는 것이 아니다. 다만 동작 파라미터를 이용할 때 익명 클래스 등 판에 박힌 코드를 구현할 필요가 없다. 결과적으로 간결하고 유연한 코드작성을 가능하게 해준다.

### 람다의 구성

```java
//람다 사용전
Comparator<Apple> byWeight = new Comparator<Apple>(){
	public int compare(Apple a1, Apple a2){
		return a1.getWeight().compareTo(a2.getWeight());
	}
}

//람다 사용
Comparator<Apple> byWeight = 
	(Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWieght());
```

람다를 사용한 코드에서 람다는 3부분으로 나뉜다.

- 파라미터 리스트 : `(Apple a1, Apple a2)`
- 화살표 : `->`
- 람다 바디 : `a1.getWeight().compareTo(a2.getWieght());`

### 람다 문법

다음은 람다의 기본 문법이다.

- **표현식 스타일** :`(parameters) -> expression`
- **블록 스타일** :`(parameters) -> {statements;}`

```java
() -> {} //OK
() -> "Raoul" //OK
() -> {return "Mario";} //OK
(Integer i) -> return "Alan" + i; //Error. return은 흐름제어문 {}로 감싸야한다.
(String s) -> {"Iron Man";} //Error. "Iron Man"은 표현식이다. {}를 없애거나, return을 붙혀야 한다.
```

### 람다 예제

| 사용 사례 | 람다 예제 |
| --- | --- |
| 불리언 표현식 | (List<String> list) → list.isEmpty() |
| 객체 생성 | () → new Apple(10) |
| 객체에서 소비 | (Apple a) → {System.out.println(a.getWeight());} |
| 객체에서 선택/추출 | (String s) → s.length() |
| 두 값을 조합 | (int a, int b) → a * b |
| 두 객체 비교 | (Apple a1, Apple a2) → a1.getWeight().compareTo(a2.getWeight()) |

## 람다의 사용

### 1. 함수형 인터페이스

간단히 말해 함수형 인터페이스는 정확히 하나의 추상 메서드를 지정하는 인터페이스다.

```java
//함수형 인터페이스
public interface Adder{
	int add(int a, int b);
}

//Adder를 상속해 두 추상 add메서드를 가짐으로 함수형 인터페이스가 아니다.
public interface SmartAdder{
	int add(double a, double b);
}

//람다 표현식으로 구현
Adder adder = (int a, int b) -> a+b;
```

람다 표현식으로 함수형 인터페이스의 추상 메서드 구현을 직접 할 수 있으므로 **전체 표현식을 함수형 인터페이스의 인스턴스로 취급**할 수 있다.

> @FunctionallInterface
> 
> 
> 함수형 인터페이스에 @FucntionalInterface를 확인할 수 있다. 이것은 함수형 인터페이스를 가리키는 애노테이션으로 만약 해당 애노테이션이 붙은 인터페이스가 함수형 인터페이스가 아니라면, 컴파일러가 에러를 발생시킨다.
> 

### 2. 함수 디스크립터

함수형 인터페이스의 추상 메서드 시그니처는 람다 표현식의 시그니처를 가리킨다. 람다 표현식의 시그니처를 서술하는 메서드를 **함수 시그니처** 라고 한다.

**예제**

- ex> Runnable 인터페이스의 추상 메서드 `run` 은 인수와 반환 값이 없으므로 Runnable 인터페이스는 인수와 반환 값이 없는 시그니처로 생각할 수 있다.
- `() → void` :  파라미터가 없으며, void를 반환하는 함수
- `(Apple, Apple) -> int` : 두개의 Apple을 인수로 받으며, int를 반환하는 함수

람다 표현식은 변수에 할당하거나, 함수형 인터페이스를 인수로 받는 메서드로 전달할 수도 있으며, 함수형 인터페이스의 추상 메서드와 같은 시그니처를 갖는다.

---

## 람다 활용 : 실행 어라운드 패턴

자원 처리에 사용하는 순환 패턴은 자원을 열기 → 처리 → 닫기 순서로 진행된다. 설정과 정리 과정은 대부분 비슷하다. 실제 자원을 처리하는 코드를 설정과 정리 두 과정이 둘러싸는 형태를 갖고, 아래 그림같은 형식의 코드를 실행 어라운드 패턴이라고 부른다.

<img width="707" alt="Untitled" src="https://user-images.githubusercontent.com/75190035/155705430-dcf22825-3d81-4da9-b866-b4ba8b442dcc.png">

다음 예제코드를 개선해보자.

```java
public String processFile() throws IOException{
	try (BufferedReader br = new BufferedReader(new FileReader("data.txt")){
		return br.readLine();
	}
}
```

### 1단계 : 동작 파라미터화를 기억하라

현재 코드는 파일에서 한 번에 한줄만 읽을 수 있다. 더 나은 기능을 위해서 설정, 정리 과정은 재사용하고, processFile 메서드만 다른 동작을 수행할 수 있도록 명령할 수 있다면 좋을 것이다. 이것을 동작 파라미터화해 가능하게 할 수 있다.

```java
String result = processFile((BufferedReader br) -> br.readLine() + br.readLine());
```

### 2단계 : 함수형 인터페이스를 이용해 동작 전달

함수형 인터페이스를 사용해 람다를 사용할 수 있도록 할 수 있다.

BufferedReader → String 과 IOException을 던질 수 있는 시그니처와 일치하는 함수형 인터페이스를 만들어야 한다.

```java
@FunctionalInterface
public interface BufferedReaderProcessor{
	String process(BufferedReader b) throws IOException;
}
```

```java
public String processFile(BufferedReaderProcessor p) throws IOException{
	try (BufferedReader br = new BufferedReader(new FileReader("data.txt")){
		return p.process(br);
	}
}
```

### 3단계 : 동작 실행

이제 람다를 전달 할 수 있다. 위에서 작성한 람다식은 BufferedReaderProcessor 를 구현해 processFile에서 process를 호출할 수 있다.

### 4단계 : 람다 전달

이제 람다의 구현만으로 한 행, 두 행을 동시에 읽는 코드를 유연하게 구현할 수 있게 되었다.

```java
//두 행
String twoLines = processFile((BufferedReader br) -> br.readLine() + br.readLine());
//한 행
String oneLines = processFile((BufferedReader br) -> br.readLine());
```

---

## 함수형 인터페이스 사용

함수형 인터페이스의 추상 메서드는 람다 표현식의 시그니처를 묘사한다. 함수형 인터페이스의 추상 메서드 시그니처를 함수 디스크립터라고 한다. 

다양한 람다 표현식을 사용하기 위해 공통의 함수 디스크립터를 기술하는 함수형 인터페이스 집합이 필요하다.

### Predicate (T → boolean)

```java
@FucntionalInterface
public interface Predicate<T> {
	boolean test(T t);
}

public <T> List<T> filter(List<T> list, Predicate<T> p){
	List<T> results = new ArrayList<>();
	for(T t: list){
		if (p.test(t)){
			results.add(t);
		}
	}
	return results;
}

//사용
Predicate<String> nonEmptyStringPredicate = (String s) -> !s.isEmpty();
List<String> nonEMpty = filter(listOfStrings, nonEmptyStringPredicate);
```

### Consumer (T → void)

```java
@FucntionalInterface
public interface Consumer<T> {
	void accept(T t);
}

public <T> void forEach(List<T> list, Consumer<T> c){
	for(T t: list){
		c.accept(t);
	}
}

//사용
forEach(
	Arrays.asList(1,2,3,4,5),
	(Integer i) -> System.out.println(i)
);
```

### Functional (T → R)

```java
@FunctionalInterface
public interface Functional<T, R>{
	R apply(T t);
}

public <T, R> List<R> map(List<T> list, Function<T, R> f){
	List<R> result = new ArrayList<>();
	for (T t : list){
		result.add(f.apply(t));
	}
return result;
}

//사용
List<Integer> i = map(
	Arrays.asList("lmambdas", "in", "action"),
	(String s) -> s.length
);
```

### 기본형 특화

위의 함수형 인터페이스들은 제네릭을 사용한 함수형 인터페이스다. 

자바의 모든 형식은 참조형(Byte, Integer, Object, List) 아니면 기본형(int,double,byte)에 해당한다. 하지만 제네릭 파라미터에는 참조형만 사용할 수 있다. 제네릭의 내부 구현떄문에 어쩔 수 없다. 

따라서 자바에서는 기본형을 참조형으로 변환하는 기능을 제공하며 이 기능을 **박싱(기본형→참조형), 언박싱(참조형→기본형)** 이라 한다. 또한 프로그래머가 편리하게 코드 구현할 수 있도록 자동으로 이 기능이 이루어지는 **오토박싱**이라는 기능도 제공한다.

**오토박싱의 예**

```java
//int -> Integer
List<Integer> list = new ArrayList<>();
for (int i = 300; i < 400; i++) list.add(i);
```

다만 변환 과정은 비용이 소모된다. 박싱한 값은 기본형을 감싸는 래퍼며 힙에 저장된다. 따라서 박싱한 값은 메모리를 더 소모하며, 기본형을 가져올 때도 메모리를 탐색하는 과정이 필요하다.

자바 8에서는 기본형을 입출력으로 사용하는 상황에서 오토박싱 동작을 피할 수 있도록 특별한 버전의 함수형 인터페이스를 제공한다. 이런 인터페이스들은 보통 앞에 `DoublePredicate, IntConsumer` 처럼 형식이 따라 붙는다.

**함수형 인터페이스**

| 함수형 인터페이스 | 함수 디스크럽터 |
| --- | --- |
| Predicate<T> | T → boolean |
| Consumer<T> | T → void |
| Functional<T, R> | T → R |
| UnaryOperator<T> | T → T |
| Supplier<T> | () → T |
| BinaryOperator<T> | (T, T) → T |
| BiPredicate<L, R> | (T, U) → boolean |
| BiConsumer<T, U> | (T, U) → void |
| BiFunction<T,U,R> | (T, U) → R |

> 예외, 람다, 함수형 인터페이스의 관계
> 
> 
> 함수형 인터페이스는 확인된 예외를 던지는 동작을 허용하지 않는다. 
> 
> 예외를 던지는 람다 표현식을 만들기 위해서는 예외를 선언하는 함수형 인터페이스를 직접 정의하거나, try/catch 블록으로 감싸야 한다.
> 

---

## 형식 검사, 형식 추론, 제약

람다 표현식으로 함수형 인터페이스의 인스턴스를 만들 수 있다. 람다 표현식 자체에는 어떤 함수형 인터페이스를 구현하는지 정보가 없다. 따라서 람다의 실제 형식을 파악해야한다.

### 형식 검사

람다가 사용되는 콘텍스트를 이용해서 람다의 형식을 추론할 수 있다. 어떤 콘텍스트(람다가 전달될 메서드 파라미터나 람다가 할당되는 변수 등)에서 기대되는 람다 표현식의 형식을 **대상 형식**이라고 부른다. 

```java
List<Apple> heavierThan150g = 
	filter(inventory, (Apple apple) -> apple.getWeight() > 150);
```

- 코드의 형식 확인 과정
1. filter 메서드의 선언을 확인
2. filter 메서드는 두 번째 파라미터로 `Predicate<Apple>` 형식을 기대한다.
3. `Predicate<Apple>` 은 test라는 한개의 추상 메서드를 정의하는 함수형 인터페이스다.
4. test 메서드는 Apple을 받아 boolean을 반환하는 함수 디스크립터를 묘사한다.
5. filter 메서드로 전달된 인수는 이와 같은 요구사항을 만족해야 한다.

### 같은 람다, 다른 함수형 인터페이스

대상 형식이라는 특징 때문에 같은 람다 표현식이어도 호환되는 추상 메서드를 가진 다른 함수형 인터페이스로 사용될 수 있다.

```java
Comparator<Apple> c1 =
	(Apple a1, Apple a2) -> a1.getWeight()>compareTo(a2.getWeight();
ToIntBiFunction<Apple, Apple> c2 = 
	(Apple a1, Apple a2) -> a1.getWeight()>compareTo(a2.getWeight();
BiFunction<Apple, Apple, Integer> c3 =
	(Apple a1, Apple a2) -> a1.getWeight()>compareTo(a2.getWeight();
```

### 형식 추론

자바 컴파일러에서는 람다 표현식이 사용된 콘텍스트를 이용해 람다 표현식과 관련된 함수형 인터페이스를 추론한다. 즉, 대상형식을 이용해서 함수 디스크럽터를 알 수 있으므로 컴파일러는 람다의 시그니처도 추론할 수 있다.

```java
Comparator<Apple> c = 
	(Apple a1, Apple a2) -> a1.getWeight()>compareTo(a2.getWeight();
Comparator<Apple> c = 
	(a1, a2) -> a1.getWeight()>compareTo(a2.getWeight();
```

상황에 따라 어떤게 좋을지 다를 것이다. 개발자 스스로가 어떤 코드가 가독성을 향상시킬 수 있는지 결정해야 한다.

### 지역 변수 사용

람다 표현식에서는 익명 함수가 하는 것 처럼 자유 변수를 활용할 수 있다. 이와 같은 동작을 **람다 캡처링**이라 부른다.

```java
int portNumber = 1337;
Runnable r = () -> System.out.println(portNumber);
```

- 제약
    - 람다는 인스턴스 변수와 정적 변수를 자유롭게 캡처 할 수 있다. 그러려면 지역 변수는 명시적으로 `final` 로 선언되거나 실제로 `final` 로 선언된 변수와 동일하게 사용되어야 한다.
    - 즉, 람다 표현식은 한 번만 할당할 수 있는 지역변수를 캡처할 수 있다.
    - 지역 변수의 제약
        - 인스턴수 변수와 지역 변수는 태생부터 다르다. 인스턴스는 힙에 저장되고, 지역변수는 스택에 저장된다. 람다가 스레드에서 실행된다면 변수를 할당한 스레드가 사라져 변수 할당이 해제되었는데도 람다를 실행하는 스레드에서는 해당 변수에 접근하려 할 수도 있다. 따라서 자바 구현에서는 원래 변수에 접근을 허용하는 것이 아니라 자유 지역 변수의 복사본을 제공한다. 따라서 복사본이 바뀌지 않아야 하므로 지역 변수에는 한 번만 값을 할당해야 한다는 제약이 생긴 것이다.

---

## 메서드 참조

메서드 참조를 이용하면 기존 메서드 정의를 재활용해 람다처럼 전달할 수 있다.

어떤때는 람다 표현식보다 메서드 참조를 사용하는 것이 가독성이 좋은 경우가 있다.

```java
//람다
inventory.sort((Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight()));
//메서드 참조
inventory.sort(comparing(Apple::getWeight));
```

메서드 참조를 이용하면 기존 메서드 구현으로 람다 표현식을 만들 수 있는데, 이때 명시적으로 메서드 명을 참조함으로써 가독성을 높일 수 있다.

메서드 참조를 새로운 기능이 아닌 하나의 메서드를 참조하는 람다를 편리하게 표현할 수 있는 문법으로 간주할 수 있다. 이를 이용하면 같은 기능을 더 간결하게 구현할 수 있다.

| 람다 | 메서드 참조 단축 표현 |
| --- | --- |
| (Apple apple) → apple.getWeight() | Apple::getWeight |
| () → Thread.currentThread().dumpStack() | Thread.currentThread()::dumpStack |
| (str, i) → str.substring(i) | String::substring |
| (String s) → System.out.println(s) | System.out::println |
| (String s) → this.isValidName(s) | this::isValidName |

### 메서드 참조를 만드는 방법

메서드 참조는 3가지 유형으로 구분할 수 있다.

- 정적 메서드 참조
    - 예) Integer의 parseInt 메서드는 `Integer::parseInt` 로 표현할 수 있다.
- 다양한 형식의 인스턴스 메서드 참조
    - 예) String의 length 메서드는 `String::length` 로 표현할 수 있다.
- 기존 객체의 인스턴스 메서드 참조
    - 예) Transaction 객체를 할당받은 expensiveTransaction과 getValue 메서드는 `expensiveTransaction::getValue` 로 표현할 수 있다.
- 3가지 종류의 람다 표현식을 메서드 참조로 변환

```java
//1.
(args) -> ClassName.staticMethod(args)
ClassName::staticMethod
//2.
(arg0, rest) -> arg0.instanceMethod(rest) //arg0 는 ClassName 형식
ClassName::instanceMethod
//3.
(args) -> expr.instanceMethod(args)
expr::instanceMethod
```

### 생성자 참조

Class::new 처럼 클래스명과 new 키워드를 이용해서 기존 생성자의 참조를 만들 수 있다.

```java
Supplier<Apple> c1 = Apple::new; // Supplier<Apple> c1 = () -> new Apple();
Apple a1 = c1.get();

Function<Integer, Apple> c2 = Apple::new; //(weight) -> new Apple(weight);
Apple a2 = c2.apply(110);
```

위의 예제들은 인수가 없거나, 하나 또는 둘인 생성자를 생성자 참조로 바꾸는 방법들이다. 만약 인수가 3개 이상인 생성자의 생성자 참조를 사용하려면, 사용하려는 생성자 참조와 일치하는 함수형 인터페이스를 만들어야 한다.

---

## 람다, 메서드 참조 활용

요구사항

- 사과 리스트 정렬

### 1단계 : 코드 전달

```java
void sort(Comparator<? super E> c)
```

자바 8의 List API 에서 sort 메서드를 제공하므로 정렬 기능을 구현할 필요는 없다. `sort` 는 Comparator 객체를 인수로 받아 비교한다. Comparator의 구현 방식에 따라서 다양한 정렬 전략을 전달할 수 있다.

```java
public class AppleComparator implements Comparator<Apple>() {
	public int compare(Apple a1, Apple a2){
		return a1.getWeight().compareTo(a2.getWeight());
	}
}
```

### 2단계 : 익명 클래스 사용

반복 사용할 것이 아닌 한번만 사용할 Comparator를 위 코드처럼 구현하는 것보다는 익명 클래스를 이용하는 것이 좋다.

```java
inventory.sort(new Comparator<Apple>() {
	public int compare(Apple a1, Apple a2){
		return a1.getWeight().compareTo(a2.getWeight());
	}
}
```

### 3단계 : 람다 표현식 사용

자바 8 에서는 익명 클래스 보다 더 경량화된 문법인 람다 표현식을 제공하며, 이를 이용해 함수형 인터페이스를 기대하는 곳 어디에서나 람다 표현식을 사용할 수 있다.

자바 컴파일러는 람다 표현식이 사용된 콘텍스트를 활용해 파라미터 형식을 추론하기 때문에 `Apple` 을 생략할 수도 있다.

```java
inventory.sort((a1, a2) -> a1.getWeight().compareTo(a2.getWeight());
```

Comparator는 Comparable 키를 추출해서 Comparator 객체로 만드는 FUnction함수를 인수로 받는 정적 메서드 comparing을 포함한다. 이를 사용하면 다음과 같다.

```java
Comparator<Apple> c = Comparator.comparing((Apple a) -> a.getWeight());
//람다식 사용
inventory.sort(comparing(apple -> apple.getWeight()));//static import
```

### 4단계 : 메서드 참조 사용

메서드 참조를 이용해 람다 표현식의 인수를 더 깔끔하게 전달할 수 있다.

```java
inventory(comparing(Apple::getWeight));
```

---

## 람다 표현식을 조합할 수 있는 유용한 메서드

자바 8 의 Comparaotr, Function, Predicate 같은 몇몇 함수형 인터페이스들은 람다 표현식을 조합할 수 있도록 유틸리티 메서드를 제공한다.

간단히 말해, 간단한 여러 개의 람다 표현식을 조합해서 복잡한 람다 표현식을 만들 수 있다는 것이다. 

다만, 함수형 인터페이스에서 추가적인 메서드를 제공하는 것은 함수형 인터페이스의 정의에 어긋난다.

이것을 가능하게 해주는 것이 **디폴트 메서드다.**

### Comparator 조합

위 예제에서 사용했던 정적 메서드 Compartor.comparing을 이용해서 비교에 사용할 키를 추출하는 Function 기반의 Comparator를 반환할 수 있다.

**역정렬**

만약 내림차순으로 정렬하고 싶다면, 다른 Comparator 인스턴스를 만들 필요 없이 인터페이스 자체에서 주어진 비교자의 순서를 바꾸는 `reverse` 라는 디폴트 메서드를 제공한다. 단지 처음 비교자 구현을 그대로 재사용해서 역정렬을 구현할 수 있다.

```java
inventory.sort(comparing(Apple:getWeight).reversed());
```

**Comperator 연결**

잘 동작할 수도 있지만, 동일한 무게를 가진 Apple이 존재한다면 또다른 기준으로 정렬하도록 해야할 것이다. 이것을 `thenComparing` 메서드로 두 번째 비교자를 만들 수 있다.

```java
inventory.sort(comparing(Apple.getWeight()
	.reversed()
	.thenComparing(Apple::getCountry));
```

### Predicate 조합

Predicate 에서는 `negate, and, or` 세 가지 메서드로 더 복잡한 프레디케이트를 만들 수 있다.

```java
//기존 Predicate 객체인 redApple의 결과를 반전시킨 객체
Predicate<Apple> notRedApple = redApple.negate(); 

//빨간색이면서 무거운 사과를 선택하는 객체
Predicate<Apple> redAndHeavyApple = redApple.and(apple -> apple.getWeight() >150);

//빨간색이면서 무거운 객체 또는 그냥 초록 사과를 선택하는 객체
Predicate<Apple> redAndHeavyApple = redApple
	.and(apple -> apple.getWeight() >150)
	.or(apple -> GREEN.equals(a.getColor()));
```

### Function 조합

Function 에서는 `andThen, compose` 두 가지 디폴트 메서드를 제공한다.

```java
Function<Integer, Integer> f = x -> x + 1;
Function<Integer, Integer> g = x -> x * 1;

Function<Integer, Integer> h = x -> f.andThen(g); // (x+1) * 1 = 4
Function<Integer, Integer> h = x -> f.compose(g); // (x*1) + 1 = 3

```
