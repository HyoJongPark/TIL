# 모던 자바 인 액션

<img src="https://user-images.githubusercontent.com/75190035/155264476-7167c8c1-7447-4235-8163-8400017ba9e0.png" width="500" width="500">

- [2. 동작 파라미터화 코드 전달하기](https://github.com/HyoJongPark/TIL/new/main/Java#2-%EB%8F%99%EC%9E%91-%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0%ED%99%94-%EC%BD%94%EB%93%9C-%EC%A0%84%EB%8B%AC%ED%95%98%EA%B8%B0)
- [3. 람다 표현식](https://github.com/HyoJongPark/TIL/edit/main/Java/%EB%AA%A8%EB%8D%98%20%EC%9E%90%EB%B0%94%20%EC%9D%B8%20%EC%95%A1%EC%85%98.md#3-%EB%9E%8C%EB%8B%A4-%ED%91%9C%ED%98%84%EC%8B%9D)
- [4. 스트림 소개](https://github.com/HyoJongPark/TIL/edit/main/Java/%EB%AA%A8%EB%8D%98%20%EC%9E%90%EB%B0%94%20%EC%9D%B8%20%EC%95%A1%EC%85%98.md#4-%EC%8A%A4%ED%8A%B8%EB%A6%BC-%EC%86%8C%EA%B0%9C)
- [5. 스트림 활용](https://github.com/HyoJongPark/TIL/edit/main/Java/%EB%AA%A8%EB%8D%98%20%EC%9E%90%EB%B0%94%20%EC%9D%B8%20%EC%95%A1%EC%85%98.md#5-%EC%8A%A4%ED%8A%B8%EB%A6%BC-%ED%99%9C%EC%9A%A9)
- [6. 스트림으로 데이터 수집](https://github.com/HyoJongPark/TIL/edit/main/Java/%EB%AA%A8%EB%8D%98%20%EC%9E%90%EB%B0%94%20%EC%9D%B8%20%EC%95%A1%EC%85%98.md#6-%EC%8A%A4%ED%8A%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%88%98%EC%A7%91)
- [7. 병렬 데이터 처리와 성능](https://github.com/HyoJongPark/TIL/edit/main/Java/%EB%AA%A8%EB%8D%98%20%EC%9E%90%EB%B0%94%20%EC%9D%B8%20%EC%95%A1%EC%85%98.md#7-%EB%B3%91%EB%A0%AC-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%B2%98%EB%A6%AC%EC%99%80-%EC%84%B1%EB%8A%A5)

---

# 2. 동작 파라미터화 코드 전달하기

### 동작 파라미터화란?

아직은 어떻게 실행할 것인지 결정하지 않은 코드 블록을 의미한다. 이 코드 블록은 나중에 프로그램에서 호출한다.(즉, 코드 블록의 실행은 나중으로 미뤄진다.)

동작 파라미터화를 이용하면 자주 바뀌는 요구사항에 효과적으로 대응할 수 있다.

### 1. 녹색 사과 필터링

```java
public static List<Apple> filterGreenApples(List<Apple> inventory){
	List<Apple> result = new ArrayList<>();
	for (Apple apple : inventory){
		if (GREEN.equals(apple.getColor()) result.add(apple);
	}
	return result;
}
```

만약 위 코드에서 필터링 할 색을 변경해야할 경우 if문의 조건을 변경하는 방법을 사용할 수도 있지만, 나중에 더 다양한 색으로 필터링하는 등의 변화에는 적절하게 대응할 수 없을 것이다.

이런 상황에서는 다음과 같은 규칙이 있다.

**거의 비슷한 코드가 반복 존재한다면, 그 코드를 추상화한다.**

### 2. 색을 파라미터화

 색을 파라미터화 할 수 있도록 메서드에 파라미터를 추가하면, `filterGreenApples` 의 코드를 반복 사용하지 않고 `filterRedApples` 를 구현할 수 있고, 결과적으로 변화하는 요구사항에 좀 더 유연하게 대응하는 코드를 만들 수 있다.

```java
public static List<Apple> filterApplesByColor(List<Apple> inventory, Color color){
	List<Apple> result = new ArrayList<>();
	for (Apple apple : inventory){
		if (apple.getColor().equals(color)) result.add(apple);
	}
	return result;
}
```

위와같이 변경하면, 모든 색에 대해 필터링 가능한 메서드가 만들어진다. 그런데 무게에 따른 필터링이 요구사항으로 발생한다면 어떨까?

```java
public static List<Apple> filterApplesByWeight(List<Apple> inventory, int weight){
	List<Apple> result = new ArrayList<>();
	for (Apple apple : inventory){
		if (apple.getWeight() > weight) result.add(apple);
	}
	return result;
}
```

위 코드로 해결할 수 있겠지만 색 필터링의 코드와 대부분 중복되는 코드다. 이는 DRY(같은 것을 반복하지 말 것)라는 소프트웨어 원칙을 어기는 것이다.

### 3. 가능한 모든 속성으로 필터링

플래그라는 파라미터를 추가해 어떤 것을 기준으로 필터링 할지 구분할 수 있다.(실전에서 사용권장 x)

```java
public static List<Apple> filterApples(List<Apple> inventory, Color color, 
																			 int weight, boolean flag){
	List<Apple> result = new ArrayList<>();
	if ((flag && apple.getColor().equals(color)) ||
			(!flag && apple.getWeigt > weight)){
		result.add(apple);
	}
	return result;
}
```

위 코드에서 true와 false가 무엇을 의미하는지 불분명하고, 요구사항이 바뀌었을 때 유연하게 대응할 수도 없다.

## 동작 파라미터화

```java
public interface ApplePredicate{
	boolean test(Apple apple);
}
```

```java
public class AppleHeavyWightPredicate implements ApplePredicate{
	public boolean test(Apple apple){
		return apple.getWeight() > 150;
	}
}
```

```java
public class AppleGreenColorPredicate implements ApplePredicate{
	public boolean test(Apple apple){
		return GREEN.equals(apple.getColor());
	}
}
```

위 조건에 따라 filter메서드가 다르게 동작할 것이라고 예상할 수 있다. 이를 전략 디자인 패턴이라고 부른다.

전략 디자인 패턴은 각 알고리즘(`AppleHeavyWieghtPredicate, AppleGreenColorPredicate`)을 캡슐화 하는 알고리즘 패밀리(`ApplePredicate`)를 정의해둔 다음에 런타임에 알고리즘을 선택하는 기법이다.

`ApplePredicate` 객체를 `FilterApples` 에서 받아 검사하도록 변경하면, 메서드가 다양한 동작을 받아서 내부적으로 다양한 동작을 수행할 수 있게된 것이다.(**동작 파라미터화**)

### 4. 추상적 조건으로 필터링

```java
public static List<Apple> filterApples(List<Apple> inventory, ApplePredicate p){
	List<Apple> result = new ArrayList<>();
	for(Apple apple : inventory){
		if(p.test(apple)) result.add(apple);
	}
	return result;
}
```

가장 처음의 코드보다 가독성, 유연성, 사용성 면에서 우수한 코드가 만들어 졌다. 이제 변경된 요구사항은 구현된 알고리즘의 수정혹은 또다른 전략의 구현으로 적절히 대응할 수 있다. 

실제 사용에서 적용할 때 구현한 알고리즘을 파라미터로 전달해 원하는 결과를 얻을 수 있다.

```java
List<Apple> greenApples = filterApples(inventory, new AppleGreenColorPredicate());
```

### 5. 익명 클래스 사용

```java
List<Apple> greenApples = filterApples(inventory, new ApplePredicate(){
	public boolean test(Apple apple){
		return RED.equals(apple.getColor());
	}
});
```

익명 클래스로 구현된 객체를 사용하면 2가지 단점이 있다.

1. 여전히 많은 공간을 차지한다.
    - 여러 클래스를 정의할 코드를 줄이기 위해서 사용했지만, 여전히 많은 공간을 차지한다.
2. 많은 프로그래머가 익명 클래스 사용에 익숙하지 않다.

코드의 장황함은 나쁜 특성이다. 장황한 코드는 구현, 유지보수하는데 시간이 많이 걸리고 가독성도 좋지않다. 익명 클래스로 인터페이스를 구현하는 클래스를 선언하는 과정을 줄일 수 있지만 만족스럽지 않다.

자바 8에서는 동작 파라미터화의 다음과 같은 문제를 람다 표현식이라는 간단한 코드 전달 기법을 도입해 해결했다.

### 6. 람다 표현식 사용

```java
List<Apple> result = filterApples(inventory, (Apple apple) -> RED.equals(apple.getColor()));
```

익명 클래스에 비해 람다 표현식을 사용했을 때 더 간결한 코드를 만들 수 있다.

### 7. 리스트 형식으로 추상화

```java
public interface Predicate<T>{
	boolean test(T t);
}
```

```java
public static <T> List<T> filter(List<T> list, Predicate<T> p){
	List<T> result = new ArrayList<>();
	for (T e : list){
		if(p.test(e)) return result.add(e);
	}
	return result;
}
```

이제 사과 뿐만 아니라 다른 요소들도 해당 기능을 사용해 구분할 수 있게 됐다.

### 정리

- 동작 파라미터화에서는 메서드 내부적으로 다양한 동작을 수행할 수 있도록 코드를 메서드 인수로 전달한다.
- 동작 파라미터화를 이용하면 변화하는 요구사항에 더 잘 대응할 수 있는 코드를 구현할 수 있으며, 나중에 엔지니어링 비용을 줄일 수 있다.
- 코드 전달 기법을 이용하면 동작을 메서드 인수로 전달할 수 있다.
    - 자바 8 이전에는 지저분한 코드
    - 익명 클래스를 사용해 1차 개선
    - 람다 표현식을 사용해 인터페이스를 상속받아 여러 클래스를 구현해야하는 수고를 없앨 수 있게됨.
- 자바 API의 많은 메서드는 정렬, 스레드, GUI 처리 등을 포함한 다양한 동작으로 파라미터화 할 수 있다.

---

# 3. 람다 표현식

## 람다란?

람다 표현식은 메서드로 전달할 수 있는 익명 함수를 단순화 한 것이다. 람다 표현식에는 이름은 없지만, 파라미터 리스트, 바디, 반환 형식, 발생할 수 있는 예외 리스트는 가질 수 있다.

### 람다의 특징

- 익명
    - 보통의 메서드와 달리 이름이 없으므로 익명이라 표현한다. 구현해야 할 코드에 대한 걱정거리가 줄어든다.
- 함수
    - 람다는 메서드처럼 특정 클래스에 종속되지 않으므로 함수라고 부른다. 하지만 메서드처럼 파라미터 리스트, 바디, 반환 형식, 예외 리스트를 포함한다.
- 전달
    - 람다 표현식을 메서드 인수로 전달하거나 변수로 저장할 수 있다.
- 간결성
    - 익명 클래스처럼 많은 자질구레한 코드를 구현할 필요가 없다.

람다는 기술적으로 자바 8 이전에 할 수 없었던 일을 지원하는 것이 아니다. 다만 동작 파라미터를 이용할 때 익명 클래스 등 판에 박힌 코드를 구현할 필요가 없다. 결과적으로 간결하고 유연한 코드작성을 가능하게 해준다.

### 람다의 구성

```java
//람다 사용전
Comparator<Apple> byWeight = new Comparator<Apple>(){
	public int compare(Apple a1, Apple a2){
		return a1.getWeight().compareTo(a2.getWeight());
	}
}

//람다 사용
Comparator<Apple> byWeight = 
	(Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWieght());
```

람다를 사용한 코드에서 람다는 3부분으로 나뉜다.

- 파라미터 리스트 : `(Apple a1, Apple a2)`
- 화살표 : `->`
- 람다 바디 : `a1.getWeight().compareTo(a2.getWieght());`

### 람다 문법

다음은 람다의 기본 문법이다.

- **표현식 스타일** :`(parameters) -> expression`
- **블록 스타일** :`(parameters) -> {statements;}`

```java
() -> {} //OK
() -> "Raoul" //OK
() -> {return "Mario";} //OK
(Integer i) -> return "Alan" + i; //Error. return은 흐름제어문 {}로 감싸야한다.
(String s) -> {"Iron Man";} //Error. "Iron Man"은 표현식이다. {}를 없애거나, return을 붙혀야 한다.
```

### 람다 예제

| 사용 사례 | 람다 예제 |
| --- | --- |
| 불리언 표현식 | (List<String> list) → list.isEmpty() |
| 객체 생성 | () → new Apple(10) |
| 객체에서 소비 | (Apple a) → {System.out.println(a.getWeight());} |
| 객체에서 선택/추출 | (String s) → s.length() |
| 두 값을 조합 | (int a, int b) → a * b |
| 두 객체 비교 | (Apple a1, Apple a2) → a1.getWeight().compareTo(a2.getWeight()) |

## 람다의 사용

### 1. 함수형 인터페이스

간단히 말해 함수형 인터페이스는 정확히 하나의 추상 메서드를 지정하는 인터페이스다.

```java
//함수형 인터페이스
public interface Adder{
	int add(int a, int b);
}

//Adder를 상속해 두 추상 add메서드를 가짐으로 함수형 인터페이스가 아니다.
public interface SmartAdder{
	int add(double a, double b);
}

//람다 표현식으로 구현
Adder adder = (int a, int b) -> a+b;
```

람다 표현식으로 함수형 인터페이스의 추상 메서드 구현을 직접 할 수 있으므로 **전체 표현식을 함수형 인터페이스의 인스턴스로 취급**할 수 있다.

> @FunctionallInterface
> 
> 
> 함수형 인터페이스에 @FucntionalInterface를 확인할 수 있다. 이것은 함수형 인터페이스를 가리키는 애노테이션으로 만약 해당 애노테이션이 붙은 인터페이스가 함수형 인터페이스가 아니라면, 컴파일러가 에러를 발생시킨다.
> 

### 2. 함수 디스크립터

함수형 인터페이스의 추상 메서드 시그니처는 람다 표현식의 시그니처를 가리킨다. 람다 표현식의 시그니처를 서술하는 메서드를 **함수 시그니처** 라고 한다.

**예제**

- ex> Runnable 인터페이스의 추상 메서드 `run` 은 인수와 반환 값이 없으므로 Runnable 인터페이스는 인수와 반환 값이 없는 시그니처로 생각할 수 있다.
- `() → void` :  파라미터가 없으며, void를 반환하는 함수
- `(Apple, Apple) -> int` : 두개의 Apple을 인수로 받으며, int를 반환하는 함수

람다 표현식은 변수에 할당하거나, 함수형 인터페이스를 인수로 받는 메서드로 전달할 수도 있으며, 함수형 인터페이스의 추상 메서드와 같은 시그니처를 갖는다.

---

## 람다 활용 : 실행 어라운드 패턴

자원 처리에 사용하는 순환 패턴은 자원을 열기 → 처리 → 닫기 순서로 진행된다. 설정과 정리 과정은 대부분 비슷하다. 실제 자원을 처리하는 코드를 설정과 정리 두 과정이 둘러싸는 형태를 갖고, 아래 그림같은 형식의 코드를 실행 어라운드 패턴이라고 부른다.

<img width="707" alt="Untitled" src="https://user-images.githubusercontent.com/75190035/155705430-dcf22825-3d81-4da9-b866-b4ba8b442dcc.png">

다음 예제코드를 개선해보자.

```java
public String processFile() throws IOException{
	try (BufferedReader br = new BufferedReader(new FileReader("data.txt")){
		return br.readLine();
	}
}
```

### 1단계 : 동작 파라미터화를 기억하라

현재 코드는 파일에서 한 번에 한줄만 읽을 수 있다. 더 나은 기능을 위해서 설정, 정리 과정은 재사용하고, processFile 메서드만 다른 동작을 수행할 수 있도록 명령할 수 있다면 좋을 것이다. 이것을 동작 파라미터화해 가능하게 할 수 있다.

```java
String result = processFile((BufferedReader br) -> br.readLine() + br.readLine());
```

### 2단계 : 함수형 인터페이스를 이용해 동작 전달

함수형 인터페이스를 사용해 람다를 사용할 수 있도록 할 수 있다.

BufferedReader → String 과 IOException을 던질 수 있는 시그니처와 일치하는 함수형 인터페이스를 만들어야 한다.

```java
@FunctionalInterface
public interface BufferedReaderProcessor{
	String process(BufferedReader b) throws IOException;
}
```

```java
public String processFile(BufferedReaderProcessor p) throws IOException{
	try (BufferedReader br = new BufferedReader(new FileReader("data.txt")){
		return p.process(br);
	}
}
```

### 3단계 : 동작 실행

이제 람다를 전달 할 수 있다. 위에서 작성한 람다식은 BufferedReaderProcessor 를 구현해 processFile에서 process를 호출할 수 있다.

### 4단계 : 람다 전달

이제 람다의 구현만으로 한 행, 두 행을 동시에 읽는 코드를 유연하게 구현할 수 있게 되었다.

```java
//두 행
String twoLines = processFile((BufferedReader br) -> br.readLine() + br.readLine());
//한 행
String oneLines = processFile((BufferedReader br) -> br.readLine());
```

---

## 함수형 인터페이스 사용

함수형 인터페이스의 추상 메서드는 람다 표현식의 시그니처를 묘사한다. 함수형 인터페이스의 추상 메서드 시그니처를 함수 디스크립터라고 한다. 

다양한 람다 표현식을 사용하기 위해 공통의 함수 디스크립터를 기술하는 함수형 인터페이스 집합이 필요하다.

### Predicate (T → boolean)

```java
@FucntionalInterface
public interface Predicate<T> {
	boolean test(T t);
}

public <T> List<T> filter(List<T> list, Predicate<T> p){
	List<T> results = new ArrayList<>();
	for(T t: list){
		if (p.test(t)){
			results.add(t);
		}
	}
	return results;
}

//사용
Predicate<String> nonEmptyStringPredicate = (String s) -> !s.isEmpty();
List<String> nonEMpty = filter(listOfStrings, nonEmptyStringPredicate);
```

### Consumer (T → void)

```java
@FucntionalInterface
public interface Consumer<T> {
	void accept(T t);
}

public <T> void forEach(List<T> list, Consumer<T> c){
	for(T t: list){
		c.accept(t);
	}
}

//사용
forEach(
	Arrays.asList(1,2,3,4,5),
	(Integer i) -> System.out.println(i)
);
```

### Functional (T → R)

```java
@FunctionalInterface
public interface Functional<T, R>{
	R apply(T t);
}

public <T, R> List<R> map(List<T> list, Function<T, R> f){
	List<R> result = new ArrayList<>();
	for (T t : list){
		result.add(f.apply(t));
	}
return result;
}

//사용
List<Integer> i = map(
	Arrays.asList("lmambdas", "in", "action"),
	(String s) -> s.length
);
```

### 기본형 특화

위의 함수형 인터페이스들은 제네릭을 사용한 함수형 인터페이스다. 

자바의 모든 형식은 참조형(Byte, Integer, Object, List) 아니면 기본형(int,double,byte)에 해당한다. 하지만 제네릭 파라미터에는 참조형만 사용할 수 있다. 제네릭의 내부 구현떄문에 어쩔 수 없다. 

따라서 자바에서는 기본형을 참조형으로 변환하는 기능을 제공하며 이 기능을 **박싱(기본형→참조형), 언박싱(참조형→기본형)** 이라 한다. 또한 프로그래머가 편리하게 코드 구현할 수 있도록 자동으로 이 기능이 이루어지는 **오토박싱**이라는 기능도 제공한다.

**오토박싱의 예**

```java
//int -> Integer
List<Integer> list = new ArrayList<>();
for (int i = 300; i < 400; i++) list.add(i);
```

다만 변환 과정은 비용이 소모된다. 박싱한 값은 기본형을 감싸는 래퍼며 힙에 저장된다. 따라서 박싱한 값은 메모리를 더 소모하며, 기본형을 가져올 때도 메모리를 탐색하는 과정이 필요하다.

자바 8에서는 기본형을 입출력으로 사용하는 상황에서 오토박싱 동작을 피할 수 있도록 특별한 버전의 함수형 인터페이스를 제공한다. 이런 인터페이스들은 보통 앞에 `DoublePredicate, IntConsumer` 처럼 형식이 따라 붙는다.

**함수형 인터페이스**

| 함수형 인터페이스 | 함수 디스크럽터 |
| --- | --- |
| Predicate<T> | T → boolean |
| Consumer<T> | T → void |
| Functional<T, R> | T → R |
| UnaryOperator<T> | T → T |
| Supplier<T> | () → T |
| BinaryOperator<T> | (T, T) → T |
| BiPredicate<L, R> | (T, U) → boolean |
| BiConsumer<T, U> | (T, U) → void |
| BiFunction<T,U,R> | (T, U) → R |

> 예외, 람다, 함수형 인터페이스의 관계
> 
> 
> 함수형 인터페이스는 확인된 예외를 던지는 동작을 허용하지 않는다. 
> 
> 예외를 던지는 람다 표현식을 만들기 위해서는 예외를 선언하는 함수형 인터페이스를 직접 정의하거나, try/catch 블록으로 감싸야 한다.
> 

---

## 형식 검사, 형식 추론, 제약

람다 표현식으로 함수형 인터페이스의 인스턴스를 만들 수 있다. 람다 표현식 자체에는 어떤 함수형 인터페이스를 구현하는지 정보가 없다. 따라서 람다의 실제 형식을 파악해야한다.

### 형식 검사

람다가 사용되는 콘텍스트를 이용해서 람다의 형식을 추론할 수 있다. 어떤 콘텍스트(람다가 전달될 메서드 파라미터나 람다가 할당되는 변수 등)에서 기대되는 람다 표현식의 형식을 **대상 형식**이라고 부른다. 

```java
List<Apple> heavierThan150g = 
	filter(inventory, (Apple apple) -> apple.getWeight() > 150);
```

- 코드의 형식 확인 과정
1. filter 메서드의 선언을 확인
2. filter 메서드는 두 번째 파라미터로 `Predicate<Apple>` 형식을 기대한다.
3. `Predicate<Apple>` 은 test라는 한개의 추상 메서드를 정의하는 함수형 인터페이스다.
4. test 메서드는 Apple을 받아 boolean을 반환하는 함수 디스크립터를 묘사한다.
5. filter 메서드로 전달된 인수는 이와 같은 요구사항을 만족해야 한다.

### 같은 람다, 다른 함수형 인터페이스

대상 형식이라는 특징 때문에 같은 람다 표현식이어도 호환되는 추상 메서드를 가진 다른 함수형 인터페이스로 사용될 수 있다.

```java
Comparator<Apple> c1 =
	(Apple a1, Apple a2) -> a1.getWeight()>compareTo(a2.getWeight();
ToIntBiFunction<Apple, Apple> c2 = 
	(Apple a1, Apple a2) -> a1.getWeight()>compareTo(a2.getWeight();
BiFunction<Apple, Apple, Integer> c3 =
	(Apple a1, Apple a2) -> a1.getWeight()>compareTo(a2.getWeight();
```

### 형식 추론

자바 컴파일러에서는 람다 표현식이 사용된 콘텍스트를 이용해 람다 표현식과 관련된 함수형 인터페이스를 추론한다. 즉, 대상형식을 이용해서 함수 디스크럽터를 알 수 있으므로 컴파일러는 람다의 시그니처도 추론할 수 있다.

```java
Comparator<Apple> c = 
	(Apple a1, Apple a2) -> a1.getWeight()>compareTo(a2.getWeight();
Comparator<Apple> c = 
	(a1, a2) -> a1.getWeight()>compareTo(a2.getWeight();
```

상황에 따라 어떤게 좋을지 다를 것이다. 개발자 스스로가 어떤 코드가 가독성을 향상시킬 수 있는지 결정해야 한다.

### 지역 변수 사용

람다 표현식에서는 익명 함수가 하는 것 처럼 자유 변수를 활용할 수 있다. 이와 같은 동작을 **람다 캡처링**이라 부른다.

```java
int portNumber = 1337;
Runnable r = () -> System.out.println(portNumber);
```

- 제약
    - 람다는 인스턴스 변수와 정적 변수를 자유롭게 캡처 할 수 있다. 그러려면 지역 변수는 명시적으로 `final` 로 선언되거나 실제로 `final` 로 선언된 변수와 동일하게 사용되어야 한다.
    - 즉, 람다 표현식은 한 번만 할당할 수 있는 지역변수를 캡처할 수 있다.
    - 지역 변수의 제약
        - 인스턴수 변수와 지역 변수는 태생부터 다르다. 인스턴스는 힙에 저장되고, 지역변수는 스택에 저장된다. 람다가 스레드에서 실행된다면 변수를 할당한 스레드가 사라져 변수 할당이 해제되었는데도 람다를 실행하는 스레드에서는 해당 변수에 접근하려 할 수도 있다. 따라서 자바 구현에서는 원래 변수에 접근을 허용하는 것이 아니라 자유 지역 변수의 복사본을 제공한다. 따라서 복사본이 바뀌지 않아야 하므로 지역 변수에는 한 번만 값을 할당해야 한다는 제약이 생긴 것이다.

---

## 메서드 참조

메서드 참조를 이용하면 기존 메서드 정의를 재활용해 람다처럼 전달할 수 있다.

어떤때는 람다 표현식보다 메서드 참조를 사용하는 것이 가독성이 좋은 경우가 있다.

```java
//람다
inventory.sort((Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight()));
//메서드 참조
inventory.sort(comparing(Apple::getWeight));
```

메서드 참조를 이용하면 기존 메서드 구현으로 람다 표현식을 만들 수 있는데, 이때 명시적으로 메서드 명을 참조함으로써 가독성을 높일 수 있다.

메서드 참조를 새로운 기능이 아닌 하나의 메서드를 참조하는 람다를 편리하게 표현할 수 있는 문법으로 간주할 수 있다. 이를 이용하면 같은 기능을 더 간결하게 구현할 수 있다.

| 람다 | 메서드 참조 단축 표현 |
| --- | --- |
| (Apple apple) → apple.getWeight() | Apple::getWeight |
| () → Thread.currentThread().dumpStack() | Thread.currentThread()::dumpStack |
| (str, i) → str.substring(i) | String::substring |
| (String s) → System.out.println(s) | System.out::println |
| (String s) → this.isValidName(s) | this::isValidName |

### 메서드 참조를 만드는 방법

메서드 참조는 3가지 유형으로 구분할 수 있다.

- 정적 메서드 참조
    - 예) Integer의 parseInt 메서드는 `Integer::parseInt` 로 표현할 수 있다.
- 다양한 형식의 인스턴스 메서드 참조
    - 예) String의 length 메서드는 `String::length` 로 표현할 수 있다.
- 기존 객체의 인스턴스 메서드 참조
    - 예) Transaction 객체를 할당받은 expensiveTransaction과 getValue 메서드는 `expensiveTransaction::getValue` 로 표현할 수 있다.
- 3가지 종류의 람다 표현식을 메서드 참조로 변환

```java
//1.
(args) -> ClassName.staticMethod(args)
ClassName::staticMethod
//2.
(arg0, rest) -> arg0.instanceMethod(rest) //arg0 는 ClassName 형식
ClassName::instanceMethod
//3.
(args) -> expr.instanceMethod(args)
expr::instanceMethod
```

### 생성자 참조

Class::new 처럼 클래스명과 new 키워드를 이용해서 기존 생성자의 참조를 만들 수 있다.

```java
Supplier<Apple> c1 = Apple::new; // Supplier<Apple> c1 = () -> new Apple();
Apple a1 = c1.get();

Function<Integer, Apple> c2 = Apple::new; //(weight) -> new Apple(weight);
Apple a2 = c2.apply(110);
```

위의 예제들은 인수가 없거나, 하나 또는 둘인 생성자를 생성자 참조로 바꾸는 방법들이다. 만약 인수가 3개 이상인 생성자의 생성자 참조를 사용하려면, 사용하려는 생성자 참조와 일치하는 함수형 인터페이스를 만들어야 한다.

---

## 람다, 메서드 참조 활용

요구사항

- 사과 리스트 정렬

### 1단계 : 코드 전달

```java
void sort(Comparator<? super E> c)
```

자바 8의 List API 에서 sort 메서드를 제공하므로 정렬 기능을 구현할 필요는 없다. `sort` 는 Comparator 객체를 인수로 받아 비교한다. Comparator의 구현 방식에 따라서 다양한 정렬 전략을 전달할 수 있다.

```java
public class AppleComparator implements Comparator<Apple>() {
	public int compare(Apple a1, Apple a2){
		return a1.getWeight().compareTo(a2.getWeight());
	}
}
```

### 2단계 : 익명 클래스 사용

반복 사용할 것이 아닌 한번만 사용할 Comparator를 위 코드처럼 구현하는 것보다는 익명 클래스를 이용하는 것이 좋다.

```java
inventory.sort(new Comparator<Apple>() {
	public int compare(Apple a1, Apple a2){
		return a1.getWeight().compareTo(a2.getWeight());
	}
}
```

### 3단계 : 람다 표현식 사용

자바 8 에서는 익명 클래스 보다 더 경량화된 문법인 람다 표현식을 제공하며, 이를 이용해 함수형 인터페이스를 기대하는 곳 어디에서나 람다 표현식을 사용할 수 있다.

자바 컴파일러는 람다 표현식이 사용된 콘텍스트를 활용해 파라미터 형식을 추론하기 때문에 `Apple` 을 생략할 수도 있다.

```java
inventory.sort((a1, a2) -> a1.getWeight().compareTo(a2.getWeight());
```

Comparator는 Comparable 키를 추출해서 Comparator 객체로 만드는 FUnction함수를 인수로 받는 정적 메서드 comparing을 포함한다. 이를 사용하면 다음과 같다.

```java
Comparator<Apple> c = Comparator.comparing((Apple a) -> a.getWeight());
//람다식 사용
inventory.sort(comparing(apple -> apple.getWeight()));//static import
```

### 4단계 : 메서드 참조 사용

메서드 참조를 이용해 람다 표현식의 인수를 더 깔끔하게 전달할 수 있다.

```java
inventory(comparing(Apple::getWeight));
```

---

## 람다 표현식을 조합할 수 있는 유용한 메서드

자바 8 의 Comparaotr, Function, Predicate 같은 몇몇 함수형 인터페이스들은 람다 표현식을 조합할 수 있도록 유틸리티 메서드를 제공한다.

간단히 말해, 간단한 여러 개의 람다 표현식을 조합해서 복잡한 람다 표현식을 만들 수 있다는 것이다. 

다만, 함수형 인터페이스에서 추가적인 메서드를 제공하는 것은 함수형 인터페이스의 정의에 어긋난다.

이것을 가능하게 해주는 것이 **디폴트 메서드다.**

### Comparator 조합

위 예제에서 사용했던 정적 메서드 Compartor.comparing을 이용해서 비교에 사용할 키를 추출하는 Function 기반의 Comparator를 반환할 수 있다.

**역정렬**

만약 내림차순으로 정렬하고 싶다면, 다른 Comparator 인스턴스를 만들 필요 없이 인터페이스 자체에서 주어진 비교자의 순서를 바꾸는 `reverse` 라는 디폴트 메서드를 제공한다. 단지 처음 비교자 구현을 그대로 재사용해서 역정렬을 구현할 수 있다.

```java
inventory.sort(comparing(Apple:getWeight).reversed());
```

**Comperator 연결**

잘 동작할 수도 있지만, 동일한 무게를 가진 Apple이 존재한다면 또다른 기준으로 정렬하도록 해야할 것이다. 이것을 `thenComparing` 메서드로 두 번째 비교자를 만들 수 있다.

```java
inventory.sort(comparing(Apple.getWeight()
	.reversed()
	.thenComparing(Apple::getCountry));
```

### Predicate 조합

Predicate 에서는 `negate, and, or` 세 가지 메서드로 더 복잡한 프레디케이트를 만들 수 있다.

```java
//기존 Predicate 객체인 redApple의 결과를 반전시킨 객체
Predicate<Apple> notRedApple = redApple.negate(); 

//빨간색이면서 무거운 사과를 선택하는 객체
Predicate<Apple> redAndHeavyApple = redApple.and(apple -> apple.getWeight() >150);

//빨간색이면서 무거운 객체 또는 그냥 초록 사과를 선택하는 객체
Predicate<Apple> redAndHeavyApple = redApple
	.and(apple -> apple.getWeight() >150)
	.or(apple -> GREEN.equals(a.getColor()));
```

### Function 조합

Function 에서는 `andThen, compose` 두 가지 디폴트 메서드를 제공한다.

```java
Function<Integer, Integer> f = x -> x + 1;
Function<Integer, Integer> g = x -> x * 1;

Function<Integer, Integer> h = x -> f.andThen(g); // (x+1) * 1 = 4
Function<Integer, Integer> h = x -> f.compose(g); // (x*1) + 1 = 3

```
---

# 4. 스트림 소개

### 스트림이란?

스트림은 자바 8 API에 새로 추가된 기능이다. 스트림을 이용하면, 선언형으로 컬렉션 데이터를 처리할 수 있으며, 멀티스레드 코드를 구현하지 않아도 데이터를 투명하게 병렬로 처리할 수 있다.

다음 예제는 저칼로리의 요리명을 반환하고, 칼로리를 기준으로 요리를 정렬하는 자바 코드다.

**스트림 사용X**

```java
//누적자로 요소 필터링
List<Dish> lowCaloricDishes = new ArrayList<>();
for (Dish dish : menu){
	if(dish.getCalories() < 400) lowCaloricDishes.add(dish);
}
//익명 클래스로 요리 정렬
Collections.sort(lowCaloricDishes, new Comparator<Dish>(){
	public int compare(Dish dish1, Dish dish2){
		return Integer.compare(dish1.getCalories(), dish2.getCalories());
	}
});
//정렬된 리스트를 처리하면서 요리 이름 선택
List<String> lowCaloricDishesName = new ArrayList<>();
for(Dish dish: lowCaloricDishes){
	lowCaloricDishesName.add(dish.getName());
}
```

**스트림 사용O**

```java
//stream 사용
List<String> lowCaloricDishesName = 
	menu.stream()
		.filter(d -> d.getCalories() < 400)
		.sorted(comparing(Dish::getName))
		.map(Dish::getName)
		.collect(toList());
```

- 장점
    - 선언형으로 코드를 구현할 수 있다.
    - `filter, sorted, map, collect` 같은 여러 빌딩 블록 연산을 연결해서 복잡한 데이터 처리 파이프라인을 만들 수 있다.
- 여기서 `stream` 을 `parallelStream` 으로 바꾸면 이 코드를 멀티코어 아키텍처에서 병렬로 실행할 수 있다.

`filter, sorted, map, collect` 같은 연산은 **고수준 빌딩 블록**으로 이루어져 있으므로 특정 스레딩 모델에 제한되지 않고 자유롭게 어떤 상황에서든 사용할 수 있다. 결과적으로 데이터 처리 과정을 병렬화 하면서 스레드와 락을 걱정할 필요가 없다.

**스트림의 장점**

- 선언형 : 더 간결하고 가독성이 좋아진다.
- 조립할 수 있음 : 유연성이 좋아진다.
- 병렬화 : 성능이 좋아진다.

---

## 스트림 시작

스트림이란 ‘데이터 처리 연산을 지원하도록 소스에서 추출된 연속된 요소’로 정의할 수 있다.

- 연속된 요소 : 컬렉션과 마찬가지로 스트림은 특정 요소 형식으로 이루어진 연속된 값 집합의 인터페이스를 제공한다.
    - 컬렉션에서는 시간, 공간의 복잡성과 관련된 요소 저장 및 접근 연산이 주를 이루고,
        
        스트림은 `filter, sorted, map` 처럼 표현 계산식이 주를 이룬다.
        
- 소스: 스트림은 컬렉션, 배열, I/O자원 등의 데이터 제공 소스로부터 데이터를 소비한다.
- 데이터 처리 연산 : 스트림은 함수형 프로그래밍 언어에서 지원하는 연산과 데이터베이스와 비슷한 연산을 지원한다.

### 스트림의 주요 특징

- 파이프 라이닝 : 대부분의 스트림 연산은 스트림 연산끼리 연결해 커다란 파이프라인을 구성할 수 있도록 스트림 자신을 반환한다. (그 덕분에 게으름, 쇼트서킷 같은 최적화도 얻을 수 있다. - 5장)
- 내부 반복 : 반복자를 이용해 명시적으로 반환하는 컬렉션과 달리 스트림은 내부 반복을 지원한다.

다음을 스트림을 이용해 구현한 코드다.

```java
List<String> threeHighCaloricDishNames = 
	menu.stream() //메뉴에서 스트림을 얻는다.
		.filter(dish -> dish.getCalories() > 300)
		.map(Dish::getName)
		.limit(3)
		.collect(toList()); //결과를 다른 리스트로 저장
```

- `filter` : 람다를 인수로 받아 스트림에서 특정 요소를 제외시킨다.
- `map` : 람다를 이용해서 한 요소를 다른 요소로 변환하거나, 정보를 추출한다.
- `limit` : 정해진 개수 이상의 요소가 스트림에 저장되지 못하도록 제한한다.
- `collect` : 스트림을 다른 형식으로 변환한다.

---

## 스트림과 컬렉션

자바의 컬렉션과 스트림 모두 연속된(순차적으로 값에 접근) 요소 형식의 값을 저장하는 자료구조의 인터페이스를 제공한다.

이 둘의 차이 중 데이터를 언제 계산하느냐가 둘의 가장 큰 차이다. 컬렉션은 현재 자료구조가 포함하는 모든 값을 메모리에 저장하기 때문에 컬렉션의 모든 요소는 컬렉션에 추가되기 전에 계산되어야 한다.(컬렉션에 요소를 추가하거나 삭제할 수 있지만 이런 연산을 수행할 때 마다 컬렉션의 모든 요소를 메모리에 저장해야한다.)

반면 스트림은 이론적으로 요청할 때만 요소를 계산하는 고정된 자료구조다.(스트림에 요소를 추가하거나 제거할 수 없다.)

### 딱 한 번만 탐색할 수 있다.

반복자와 마찬가지로 스트림도 한 번만 탐색할 수 있다.(탐색된 스트림의 요소는 소비된다.)

반복자와 마찬가지로 한 번 탐색한 요소를 다시 탐색하려면 초기 데이터 소스에서 새로운 스트림을 만들어야 한다.(컬렉션처럼 반복 사용할 수 있는 데이터 소스여야함)

```java
List<String> title = Arrays.asList("Java8", "In", "Action");
Stream<String> s = title.stream();
s.forEach(System.out::println); //tilte의 간 단어 출력
s.forEach(System.out::println); //IllegalStateException. 스트림이 이미 소비되었거나 닫힘
```

### 외부 반복과 내부 반복

컬렉션 인터페이스를 사용하려면 사용자가 직접 요소를 반복해야 한다. 이를 **외부 반복** 이라고 한다.

반면 스트림 라이브러리는 **내부 반복**을 사용한다. 함수에 어떤 작업을 수행할지만 지정하면 모든 것이 알아서 처리된다.

- 외부 반복(for-each 루프를 이용하는 외부 반복)

```java
List<String> names = new ArrayList<>();
for(Dish dish : menu) {
	names.add(dish.getName());
} ****
```

- 내부 반복(스트림)

```java
List<String> names = menu.stream()
	.map(Dish::getName)
	.collect(toList());
```

---

## 스트림 연산

스트림 인터페이스는 많은 연산을 정의한다. 스트림 연산은 크게 중간 연산과 최종 연산 2가지로 구분할 수 있다.

연결할 수 있는 스트림 연산을 중간 연산이라고 하며, 스트림을 닫는 연산을 최종 연산이라고 한다.

```java
List<String> threeHighCaloricDishNames = 
	menu.stream() //메뉴에서 스트림을 얻는다.
		.filter(dish -> dish.getCalories() > 300) //중간 연산
		.map(Dish::getName)                       //중간 연산
		.limit(3)                                 //중간 연산
		.collect(toList());                       //최종 연산
```

- `filter, map, limit` 는 서로 연결되어 파이프라인을 형성한다.
- `collect` 로 파이프라인을 실행한 다음에 닫는다.

### 중간 연산

`filter, sorted` 같은 중간 연산은 다른 스트림을 반환한다. 따라서 여러 중간 연산을 연결해서 질의를 만들 수 있다. 중간 연산의 중요한 특징은 단말 연산을 스트림 파이프라인에 실행하기 전까지는 아무 연산도 수행하지 않는 것, 즉 게으르다는 것이다.

중간 연산을 합친 다음, 최종 연산으로 한 번에 처리하기 때문이다.

```java
List<String> names = 
	menu.stream()
		.filter(dish -> {
			System.out.println("filtering:"+dish.getName());
			return dish.getCalories() > 300;
		})
		.map(dish -> {
			System.out.println("mapping:"+dish.getName());
			return dish.getName();
		})
		.limit(3)
		.collect(toList());
System.out.println(names);
```

- 출력 결과

```java
filtering:pork
mapping:pork
filtering:beef
mapping:beef
filtering:chicken
mapping:chicken
[pork, beef, chicken]
```

- 칼로리가 300을 넘는 요리는 여러 개지만, 처음 3개만 출력된다. 이는 `limit` 연산, 쇼트서킷이라 불리는 기법 덕분이다.
- `filter, map` 은 서로 다른 연산이지만 한 과정으로 병합되었다. 이를 루프 퓨전 이라고 한다.

### 최종 연산

최종 연산은 스트림 파이프라인에서 결과를 도출한다. 보통 최종 연산에 의해 List, Integer, void 등 스트림 이외의 결과가 반환된다.

```java
menu.stream().forEach(System.out::println);
```

- `forEach` 는 소스의 각 요리에 람다를 적용한 다음 void를 반환하는 최종 연산이다.
- 최종 연산이므로 스트림의 모든 요리를 출력한다.

### 스트림 이용

스트림의 이용 과정은 3가지로 요약할 수 있다.

- 질의를 수행할 데이터 소스
- 스트림 파이프라인을 구성할 중간 연결 연산
- 스트림 파이프라인을 실행하고 결과를 만들 최종연산

스트림 파이프라인의 개념은 빌더 패턴과 비슷하다.(빌더 패턴:[http://en.wikipedia.org/wiki/Buider_pattern](http://en.wikipedia.org/wiki/Buider_pattern))

빌더 패턴에서는 호출을 연결해서 설정을 만든다(스트림에서 중간 연산을 연결하는 것과 같다). 그리고 준비된 설정에 build 메서드를 호출한다(스트림에서는 최종 연산에 해당한다).

| 연산 | 형식 | 반환 형식 | 연산의 인수 | 함수 디스크립터 |
| --- | --- | --- | --- | --- |
| filter | 중간 연산 | Stream<T> | Predicate<T> | T → boolean |
| map | 중간 연산 | Stream<R> | Function<T, R> | T → R |
| limit | 중간 연산 | Stream<T> |  |  |
| sorted | 중간 연산 | Stream<T> | Comparator<T> | (T, T) → int |
| distinct | 중간 연산 | Stream<T> |  |  |

| 연산 | 형식 | 반환 형식 | 목적 |
| --- | --- | --- | --- |
| forEach | 최종 연산 | void | 스트림의 각 요소를 소비하면서 람다를 적용한다. |
| count | 최종 연산 | long(generic) | 스트림의 요소 개수를 반환한다. |
| collect | 최종 연산 |  | 스트림을 리듀스해서 리스트, 맵, 정수 형식의 컬렉션을 만든다. |

---

# 5. 스트림 활용

## 필터링

스트림의 요소를 선택하는 방법에서는 프레디케이트 필터링 방법과 고유 요소만 필터링 하는 방법이 있다.

### 프레디케이트로 필터링

스트림 인터페이스는 `filter`메서드를 가지며, 이 메서드는 프레디케이트(boolean 반환)를 인수로 받아서 일치하는 모든 요소를 포함하는 스트림을 반환한다.

```java
List<Dish> vegetarianMenu = menu.stream()
																.filter(Dish::isVegeterian) //채식인지 확인하는 메서드 참조
																.collect(toList());
```

### 고유 요소 필터링

스트림은 고유 요소로 이루어진 스트림을 반환하는 `distinct`메서드도 지원한다.

```java
List<Integer> numbers = Arrays.asList(1, 2, 1, 3, 2, 4);
numbers.stream()
	.filter(i -> i%2 == 0)         //(2,2,4)
	.distinct()
	.forEach(System.out::println); //(2,4)
```

---

## 스트림 슬라이싱

### 프레디케이트를 이용한 슬라이싱

자바 9에서는 스트림의 요소 선택에서 효과적인 방법인 `takeWhile, dropWhile` 두 가지 새로운 메서드를 지원한다.

- `**takeWhile` 활용**

```java
//filter 메서드 사용
List<Dish> slicedMenu = specialMenu.stream()
																	 .filter(dish -> dish.getCalories() < 320)
																	 .collect(toList());
//takeWhile 메서드 사용
List<Dish> slicedMenu = specialMenu.stream()
																	 .takeWhile(dish -> dish.getCalories() < 320)
																	 .collect(toList());
```

위 코드는 320칼로리 이하의 요리들을 필터링하는 기능을 수행하는 코드들이다.

`filter` 를 사용하면, 전체 스트림을 반복하면서 프레디케이트를 적용하고,

`takeWhile` 을 사용하면, 스트림의 요소중 해당 조건을 만족하는 요소가 나왔을 때 반복 잡업을 중단할 수 있다. 이 기능은 리스트가 정렬되어 있을때 유용하며, 규모가 큰 스트림에서 `filter` 와 상당한 차이가 될 수 있다.

- `**dropWhile` 활용**

```java
List<Dish> slicedMenu = specialMenu.stream()
																	 .dropWhile(dish -> dish.getCalories() < 320)
																	 .collect(toList());
```

`dropWhile` 은 `takeWhile` 과 정반대의 작업을 수행한다. `dropWhile` 은 처음부터 발견된 지점까지 요소를 버린다. 프레디케이트가 거짓이되면 그 지점에서 작업을 중단하고 남은 모든 요소를 반환한다.

`dropWhile` 은 무한한 남은 요소를 가진 무한 스트림에서도 동작한다.

### 스트림 축소

스트림은 주어진 값(n) 이하의 크기를 갖는 새로운 스트림을 반환하는 `limit(n)` 메서드를 지원한다.

```java
List<Dish> dishes = specialMenu.stream()
															 .filter(dish -> dish.getCalories() > 300)
															 .limit(3)
															 .collect(toList());
```

프레디케이트와 일치하는 처음 3개의 요소를 선택한 다음에 즉시 결과를 반환한다.

### 요소 건너뛰기

스트림은 처음 n개 요소를 제외한 스트림을 반환하는 `skip(n)` 메서드를 지원한다. 만약 스트림의 크기가 n 이하였다면, 빈 스트림이 반환된다.

```java
List<Dish> dishes = menu.stream()
												.filter(d -> d.getCalories() > 300)
											  .skip(2)
												.collect(toList());
```

---

## 매핑

### 스트림의 각 요소에 함수 적용

스트림은 함수를 인수로 받는 `map` 메서드를 지원한다. 인수로 제공된 함수는 각 요소에 적용되어 함수를 적용한 결과가 새로운 요소로 매핑된다.

```java
List<Integer> dishNameLengths = menu.stream()
																 .map(Dish::getName)
																 .map(String::length)
																 .collect(toList());
```

위 코드는 Dish → String → Integer 로 매핑되는 예시코드다.

### 스트림 평면화

매핑을 응용해서 고유 문자로 이루어진 리스트를 반환하는 코드들이다.

```java
words.stream()
	.map(word -> word.split(""))
	.distinct()
	.collect(toList()); 
```

위 코드는 `map(), distinct()` 를 활용해 고유문자를 얻는 코드고 실제로 잘 동작한다. 하지만 여기서 반환 타입이 Stream<String[]> 로 문자열 배열을 반환한다. → 실제 원하는 것은 Stream<String>이다.

- **`map` 과 Arrays.stream 활용**

```java
words.stream()
	.map(word -> word.split(""))
	.map(Arrays::stream) //Stream<Stream<String>>(각 배열을 별도의 스트림으로 생성)
	.distinct()
	.collect(toList());
```

`Arrays.stream()` 메서드는 문자열을 받아 스트림을 만든다.

이걸 활용해 구현한 코드는 List<Stream<String>>을 반환하며 원하는 결과를 얻지 못한다.

- `**flatMap` 사용**

```java
List<String> uniqueCharacters = words.stream()
																		 .map(word -> word.split(""))
																		 .flatMap(Arrays::stream) //Stream<String>
																		 .distinct()
																		 .collect(toList());
```

`flatMap` 은 각 배열을 스트림이 아니라 스트림의 콘텐츠로 매핑한다. 즉, `map(Arrays::stream)` 과는 달리 하나의 평면화된 스트림을 반환한다.

---

## 검색과 매칭

### 프레디케이트가 적어도 한 요소와 일치하는지 확인

프레디케이트가 주어진 스트림에서 적어도 한 요소와 일치하는지 확인할 때 `anyMatch` 메서드를 이용한다.

```java
if (menu.stream().anyMatch(Dish::isVegetarian)){
	System.out.println("채식 메뉴가 존재합니다.");
}
```

### 프레디케이트가 모든 요소와 일치하는지 검사

프레디케이트가 주어진 스트림의 모든 요소와 일치하는지 검사할 때 `allMatch` 메서드를 이용한다.

- `**allMatch**`

```java
boolean isHealthy = menu.stream()
												.allMatch(dish -> dish.getCalories() < 1000);
```

- `**noneMatch**`

`allMatch` 의 정반대 연산이 `noneMatch` 다. 주어진 프레디케이트와 일치하는 요소가 없는지 확인한다. 만약 일치하는게 있다면 false

```java
boolean isHealthy = menu.stream()
												.noneMatch(dish -> dish.getCalories() < 1000);
```

`anyMatch, allMatch, noneMatch`  세 메서드는 스트림 쇼트서킷 기법, 즉 자바의 &&, ||와 같은 연산을 활용한다.

> 쇼트서킷 평가
> 
> 
> 때로는 전체 스트림을 처리하지 않았어도 결과를 반환할 수 있다. 
> 
> 예를 들어 여러 and연산으로 연결된 커다란 불리언 표현식을 평가한다고 가정했을 때, 표현식에서 하나로도 거짓으로 결과가 나오면 나머지 표현식의 결과와 상관없이 전체 결과도 거짓이 된다. 이러한 상황을 쇼트서킷 이라고 부른다.
> 
> `allMatch, noneMatch, findAny, findFirst` 등의 연산은 모든 스트림의 요소를 처리하지 않고, 원하는 요소를 찾았으면 즉시 결과를 반환할 수 있다.  `limit` 도 마찬가지다.
> 

### 요소 검색

`findAny` 메서드는 현재 스트림에서 임의의 요소를 반환한다. 

```java
Optional<Dish> dish = menu.stream()
													.filter(Dish::isVegetarian)
													.findAny()
													.isPresent(dish -> System.out.println(dish.getName());
```

- `Optional` 이란?
    - 위 코드에서 `findAny` 는 아무 요소도 반환하지 않을 수 있다. null은 쉽게 오류를 일으킴으로 자바 8에서는 `Optional<T>` 를 제공해 null확인 관련 버그를 피할 수 있게 했다.
    - `isPresent(), isPresent(Consumer<T> block)` 은 값이 있으면 주어진 블럭을 실행하고, 없다면 false를 반환한다.

### 첫 번째 요소 찾기

리스트 또는 정렬된 연속 데이터로부터 생성된 스트림처럼 일부 스트림에는 논리적인 아이템 순서가 정해져 있을 수 있다. 이런 식에서 첫 번째 요소를 찾을 때 `findFirst` 를 활용한다.

```java
List<Integer> someNumbers = Arrays.asList(1, 2, 3, 4, 5);
Optional<Integer> firstSquareDivisibleByThree = someNumbers.stream()
																													 .map(n -> n * n)
																													 .filter(n -> n%3 == 0)
																													 .findFirst(); // 9
```

> `finFirst` 와 `findAny` 는 언제 사용하나?
> 
> 
> findFirst 와 findAny 메서드가 모두 필요한 이유는 병렬성 때문이다. 병렬 실행에서는 첫 번째 요소를 찾기 어렵다. 따라서 요소의 반환 순서가 상관없다면 병렬 스트림에서는 제약이 적은 findAny 를 사용한다.
> 

---

## 리듀싱

리듀싱 연산은 모든 스트림 요소를 처리해서 값으로 도출하는 것이다.

### 리듀싱 활용

- 요소의 합

```java
//for-each루프
int sum = 0;
for (int x : numbers) sum += x;

//리듀싱 연산
int sum = numbers.stream.reduce(0, (a,b) -> a + b);
//리듀싱 연산과 메서드 참조
int sum = numbers.stream.reduce(0, Integer::sum);
```

- 초기 값: 0
- 두 요소를 조합해서 새로운 값을 만드는 `BinaryOperator<T>`

람다의 첫 번째 파라미터(a)에 초기 값이 사용되고, 두 번째 파라미터에는 numbers의 첫 번째 요소가 사용된다.

이후에는 첫 번째 연산의 결과를 a에 저장해 값을 누적해나가는 방식이다.

- **초기 값 없음**

```java
Optional<Integer> sum = numbers.stream().reduce((a,b) -> (a + b));
```

초기값을 받지 않도록 오버로드된 reduce도 있다. 이 reduce는 Optional 객체를 반환한다. 그 이유는 초기값이 없으면 reduce는 합계를 반환할 수 없고, 따라서 합계가 없음을 가리킬 수 있도록 Optional 객체로 감싼 결과를 반환한다.

- 최대, 최소값

```java
Optional<Integer> max = numbers.stream().reduce(Integer::max);
Optional<Integer> min = numbers.stream().reduce(Integer::min);
```

### 맵 리듀스 패턴

`map` 과 `reduce` 를 연결하는 기법을 맵 리듀스 패턴이라 하며, 쉽게 병렬화하는 특징 덕분에 구글이 웹 검색에 적용하며 유명해 졌다.

```java
Integer reduce = num1.stream().map(d -> 1).reduce(0, (a, b) -> a + b);
```

---

## 숫자형 스트림

지금까지 누적계산 등의 계산 전에 Integer를 기본형으로 언박싱 해야한다. 하지만 불필요한 과정 없이 메서드를 호출할 수 있는 방식을 제공한다.

스트림 API는 숫자 스트림을 효율적으로 처리할 수 있도록 기본형 특화 스트림을 제공한다.

### 기본형 특화 스트림

자바 8에서는 기본형 특화 스트림을 제공한다. 스트림 API는 박싱 비용을 피할 수 있도록 `IntStrea, DoubleStream, DoubleStream, LongStream` 을 제공한다. 각각의 인터페이스는 숫자 스트림에서 사용하는 유틸리티 메서드를 제공한다.(`sum, max` 등)

특화 스트림은 오직 박싱 과정에서 일어나는 효율성과 관련 있으며 스트림에 추가 기능을 제공하지 않는다.

**숫자 스트림으로 매핑**

스트림을 특화 스트림으로 변환할 때는 `mapToInt, mapToDouble, mapToLong` 세 가지 메서드를 가장 많이 사용한다. 이들은 `map` 과 정확히 같은 기능을 수행하지만, 특화된 스트림을 반환한다.

```java
int calories = menu.stream()
									 .mapToInt(Dish::getCalories) //IntStream 반환
									 .sum();
```

**객체 스트림으로 복원하기**

특화 스트림을 `boxed` 메서드를 사용해 기존의 특화되지 않은 스트림으로 복원할 수 있다.

```java
IntStream intStream = menu.stream().mapToInt(Dish::getCalories);
Stream<Integer> stream = intStream.boxed();
```

**기본값 : OptionalInt**

IntStream 에서 최대값을 찾을 때는 0이라는 기본값 때문에 잘못된 결과가 도출될 수 있다. 스트림에 요소가 없는 상황과 실제 최대값이 0 인 상황을 `OptionalInt, OptionalDouble, OptionalLong` 같은 `Optional` 을 기본형 특화 한 것을 사용해 해결할 수 있다.

```java
Optional maxCalories = menu.stream().mapToInt(Dish::getCalories).max();
int max = maxCalories.orElse(1); //값이 없을 때 최대값을 명시적으로 설정
```

### 숫자 범위

프로그램에서 특정 범위의 숫자를 이용해야하는 상황에 자바 8의 IntStream 과 LongStream 에서는 `range, rangeClosed` 라는 두가지 정적 메서드를 제공한다. 두 메서드 모두 첫 번째 인수로는 시작값을 두 번째 인수로 종료값을 갖는다.

- `range` : 시작값과 종료값이 결과에 포함되지 않는다.
- `rangeClosed` : 시작값과 종료값이 결과에 포함된다.

```java
IntStream evenNumbers = IntStream.rangeClosed(1,100).filter(n -> n%2 == 0);
```

---

## 스트림 만들기

### 값으로 스트림 만들기

임의의 수를 인수로 받는 정적 메서드 `Stream.of` 를 이용해서 스트림을 만들 수 있다.

```java
Stream<String> stream = Stream.of("Mordern", "Java", "In ", "Action");
stream.map(String::toUpperCase).forEach(System.out::println);

Stream<String> emptyStream = Stream.empty();
```

위 코드는 문자열 스트림을 만드는 예제다.

`Stream.empty()` 를 이용해서 스트림을 비울 수도 있다.

### null이 될 수 있는 객체로 스트림 만들기

자바 9 에서는 null이 될 수 있는 개체를 스트림으로 만들 수 있는 새로운 메서드인 `Stream.ofNullable` 을 제공한다.

```java
Stream<String> homeValueStream = Stream.ofNullable(System.getProperty("home"));
```

### 배열로 스트림 만들기

`[Arrays.stream](http://Arrays.stream)` 을 사용하면 배열을 스트림으로 만들 수 있다.

```java
int[] numbers = {2, 3, 4, 5, 6};
int sum = Arrays.stream(numbers).sum();
```

### 파일로 스트림 만들기

파일을 처리하는 등의 I/O 연산에 사용하는 자바의 NIO API도 스트림 API 를 활용할 수 있게 되었다. `java.nio.file.Files` 의 많은 정적 메서드가 스트림을 반환한다. 예를 들어 `Files.lines` 로 파일의 각 행 요소를 반환하는 스트림을 얻을 수 있다.

### 함수로 무한 스트림 만들기

스트림 API 는 함수에서 스트림을 만들 수 있는 두 정적 메서드 `Stream.iterate, Steam.generate` 를 제공한다. 두 연산을 이용해서 무한 스트림, 즉 크기가 고정되지 않은 스트림을 만들 수 있다.

보통 무한한 값을 출력하지 않도록 `limit` 와 함께 사용한다.

- `iterate`

```java
Stream.iterate(0, n -> n + 2).limit(10).forEach(System.out::println);
```

`iterate` 메서드는 초기값과 람다를 사용인수로 받아 새로운 값을 끊임없이 생산할 수 있다. `iterate` 는 요청할 때 마다 값을 생산할 수 있으며 끝이 없으므로 무한 스트림을 만든다. 이러한 스트림을 언바운드 스트림이라고 표현한다.

일반적으로 연속된 일련의 값을 만들 때는 `iterate` 를 사용한다.

```java
IntStream.iterate(0, n -> n<100, n -> n +4).forEach(System.out::println);
```

위 코드처럼 자바 9의 `iterate` 는 페레디케이트를 지원한다.

- `generate`

```java
Stream.generate(Math::random).limit(5).forEach(System.out::println);
```

iterate 와 비슷하게 `generate` 도 요구할 때 값을 계산하는 무한 스트림을 만들 수 있다. 하지만 연속적으로 계산하지 않고 `Supplier<T>` 를 인수로 받아서 새로운 값을 생성한다.

여기서 limit가 없다면 스트림은 언바운드 상태가 된다.

우리가 사용한 `supplier`는 상태가 없는 메서드(나중에 계산에 사용할 어떤 값도 저장해 두지 않음)다. 하지만 `supplier`가 꼭 상태가 없어야 하는건 아니다. `supplier` 가 상태를 저장한 다음 스트림의 다음 값을 만들 때 상태를 고칠 수도 있다. 만약 `supplier` 에 상태가 있으면 안전하지 않아 실제로는 피해야한다.

`IntStream` 을 이용하면 박싱 문제를 피할 수 있고, 이때 `generate` 메서드는 `IntSupplier` 를 인수로 받는다.

---

# 6. 스트림으로 데이터 수집

## 컬렉터란?

명령형 프로그래밍에 비해 함수형 프로그래밍에서는 무엇을 원하는지 직접 명시할 수 있어서 어떤 방법으로 이를 얻을지는 신경 쓸 필요가 없다.

Collector 인터페이스 구현은 스트림의 요소를 어떤 식으로 도출할지 지정한다.

### 고급 리듀싱 기능을 수행하는 컬렉터

`collect` 로 결과를 수집하는 과정을 간단하면서도 유연한 방식으로 정의할 수 있다는 점이 컬렉터의 최대 강점이다. 구체적으로 스트림에 `collect` 를 호출하면 스트림의 요소에 리듀싱 연산이 수행된다.

보통 함수를 요소로 변환할 때는 컬랙터를 적용하며 최종 결과를 저장하는 자료구조에 값을 누적한다.

```java
List<Transaction> transactions = transactionStream.collect(Collectors.toList());
```

위 예제에서 볼 수 있듯이 Collector 인터페이스의 메서드를 어떻게 구현하냐에 따라 스트림에 어떤 리듀싱 연산을 수행할지 결정된다.

Collectors 유틸리티 클래스는 자주 사용하는 컬렉터 인스턴스를 손쉽게 생성할 수 있는 정적 팩토리 메서드를 제공한다.

### 미리 정의된 컬렉터

Collectors에서 제공하는 메서드의 기능은 크게 3가지로 구분할 수 있다.

- 스트림 요소를 하나의 값으로 리듀스하고 요약
- 요소 그룹화
- 요소 분할

---

## 리듀싱과 요약

컬렉터(`Stream.collect` 메서드의 인수)로 스트림의 항목을 컬렉션으로 재구성 할 수 있다. 좀 더 일반적으로 컬렉터로 스트림의 모든 항목을 하나의 결과로 합칠 수 있다.

### 카운트 연산

`counting()` 이라는 팩토리 메서드가 반환하는 컬렉터로 스트림의 수를 계산할 수 있다.

```java
long howManyDishes = menu.stream().collect(Collectors.counting());

long howManyDishes = menu.stream().count();
```

### 스트림값에서 최댓값과 최솟값 검색

`Collectors.maxBy, Collectors.minBy` 를 사용해 스트림의 최댓값과 최솟값을 계산할 수 있다.

두 메서드는 요소를 비교하는데 사용할 Comparator를 인수로 받는다.

```java
Comparator<Dish> dishCaloriesComparator = 
	Comparator.comparingInt(Dish::getCalories);

Optional<Dish> mostCalorieDish = 
	menu.stream().collect(maxBy(dishCaloriesComparator));
```

만약 menu가 비어있다면 어던 요리도 반환되지 않으므로 Optional 을 제공한다.

### 요약 연산

Collectors 클래스는 다양한 형식의 특별한 요약 팩토리 메서드를 제공한다.

**총합**

`Collectors.summingInt, Collectors.summingLong, Collectors.summingDouble` 로 다양한 형식으로 이루어진 숫자 집합의 합계를 계산할 수 있다.

`summingInt` 는 객체를 int로 매핑하는 함수를 인수로 받는다. 인수로 전달된 함수는 객체를 int로 매핑한 컬렉터를 반환한다. 그리고 `summingInt` 가 collect 메서드로 전달되면 요약 작업을 수행한다.

```java
int totalCalories = menu.stream().collect(summingInt(Dish::getCalories));
```

**평균**

`Collectors.averagingInt, Collectors.averagingLong, Collectors.averagingDouble` 등으로 다양한 형식으로 이루어진 숫자 집합의 평균을 계산할 수 있다.

```java
double avgCalories = menu.stream().collect(averagingLong(Dish::getCalories));
```

**여러 작업을 동시에 수행**

만약 스트림의 요소 수를 계산하고, 최댓값과 최솟값을 찾는 등의 작업을 동시에 수행해야할 때는 `summarizingInt` 메서드를 사용한다. 이 메서드 또한 다양한 형식을 지원한다.

```java
IntSummaryStatistics menuStatistics 
	menu.stream().collect(summarizingInt(Dish::getCalories));

//menuStatistics 객체 출력
IntSummaryStatistics{count=9, sum=4300, min=120, average=477.7777778, max=800}
```

### 문자열 연결

컬렉터에 `joining` 팩토리 메서드를 이용하면 스트림의 각 객체에 `toString` 메서드를 호출해서 추출한 모든 문자열을 하나의 문자열로 연결해서 반환한다.

`joining` 메서드는 내부적으로 StringBuilder 를 이용해서 문자열을 하나로 만든다. 또한 구분 문자열을 인수로 받는 오버로딩된 `joining` 팩토리 메서드를 사용하면, 문자열 간 해당문자로 구분해 출력되게 할 수도 있다.

```java
//출력: porkbeefchickenfrench friesriceseanson ...
String shortMenu = menu.stream().collect(joining());
//출력: pork, beef, chicken, french freis, rice, ...
String shortMenu = menu.stream().collect(joining(", ");
```

### 범용 리듀싱 요약 연산

앞서 살펴본 모든 컬렉터는 reducing 팩토리 메서드로도 정의할 수 있다. 즉, 범용 `Collectors.reducing` 으로도 구현할 수 있다. 그럼에도 편의성때문에 위의 코드들을 사용했다.

합계를 구하는 코드는 다음과 같이 구현할 수 있다.

**3개의 인수를 받는 리듀싱 연산**

```java
int totalCalories = 
	menu.stream().collect(reducing(0, Dish::getCalories, (i,j) -> i+j));
```

- 해당 리듀싱 연산은 3개의 인수를 받는다.
    - 첫 번째 인수는 리듀싱 연산의 시작값이거나, 스트림에 인수가 없을 때는 반환값이다.
    - 두 번째 인수는 정수를 변환할 때 사용한 변환 함수다.
    - 세 번째 인수는 원하는 동작을 수행하도록 구현한 BinaryOperator다.
- 초기값을 가지고 있어 `null` 이 반환될 이유가 없다. 따라서 반환값으로 해당 타입을 반환한다.

**1개의 인수를 받는 리듀싱 연산**

```java
Optional<Dish> mostCalories = 
	menu.stream.collect(reducing(
		(d1, d2) -> d1.getCalories() > d2.getCalories() ? d1 : d2));
```

스트림의 첫 번째 요소를 시작값으로 사용하고, 자신 그대로를 반환하는 항등 함수를 두 번째 인수로 받는다. 

즉, 한 개의 인수를 갖는 reducing 컬렉터는 시작 값이 없으므로 빈 스트림이 넘겨졌을 때 시작값이 설정되지 않는 상황이 벌어진다. 따라서 Optional 을 반환한다.

---

## 그룹화

자바 8의 함수형을 이용한면, 한 줄의 코드로 데이터 집합을 하나 이상의 특성으로 분류해서 그룹화하는 그룹화 연산도 구현할 수 있다.

```java
Map<Dish, Type, List<Dish>> dishesByType = 
	menu.stream.collect(groupingBy(Dish::getType));
```

스트림의 각 요리에서 Dish.Type과 일치하는 모든 요리를 추출하는 함수를 `groupingBy` 메서드로 전달했다. 이 함수를 기준으로 그룹화 되므로 이를 분류 함수라고 부른다.

그룹화 연산의 결과로 그룹화 함수가 반환하는 키 그리고 각 키에 대응하는 스트림의 모든 항목 리스트를 값으로 갖는 맵이 반환된다.

또한 미리 정의된 속성이 아닌 필요한 로직을 구현해 사용할 수 있다.

```java
public enum CaloricLevel {DIET, NORMAL, FAT}

Map<CaloricLevel, List<Dish>> dishesByCaloricLevel = menu.stream().collect(
	groupingBy(dish -> {
		if (dish.getCalories() <= 400) return CaloricLevel.DIET;
		else if (dish.getCalories() <= 700) return CaloricLevel.NORMAL;
		else return CaloricLevel.FAT;
	}));
```

### 그룹화된 요소 조작

요소를 그룹화 한 다음에는 각 결과 그룹의 요소를 조작하는 연산이 필요하다. `filter` 를 사용해 문제를 해결할 수도 있지만, 결과 맵에서 해당 키가 사라질 수도 있다는 단점이 존재한다. 

Collectors 클래스는 일반적인 분류 함수에 Collector 형식의 두 번째 인수를 갖도록 `groupingBy` 팩토리 메서드를 오버로드해 이 문제를 해결한다.

**`filtering` 사용**

```java
Map<Dish, Type, List<Dish>> caloricDishesByType = menu.stream()
	.collect(groupingBy(Dish::getType, 
		filtering(dish -> dish.getCalories() > 500, toList()))); 
//결과 맵
{OTHER=[french fries, pizza], MEAT=[pork, beef], FISH=[]}
```

`filtering` 메소드는 Collectors 클래스의 또 다른 정적 팩토리 메서드로 프레디케이트를 인수로 받는다. 이 프레디케이트로 각 그룹의 요소와 필터링 된 요소를 재그룹화 한다.

`**mapping` 사용**

```java
Map<Dish, Type, List<String>> dishNamesByType = 
	menu.stream().collect(groupingBy(Dish::getType, mapping(Dish::getName, toList())));
```

`mapping` 메소드를 사용한 결과는 문자열 리스트다.

**`flatMapping` 사용**

```java
Map<Dish, Type, Set<String>> dishNamesByType = 
	menu.stream().collect(groupingBy(Dish::getType, 
		flatMapping(dish -> dishTags.get(dish.getName()).stream(), toSet()));
```

### 다수준 그룹화

두 인수를 받는 팩토리 메서드 `Collectors.groupingBy` 를 이용해서 항목을 다수준으로 그룹화 할 수 있다. 해당 팩토리 메서드는 일반적인 분류 함숭와 컬렉터를 인수로 받는다.

```java
Map<Dish.Type, Map<CaloricLevel, List<Dish>>> dishesByTypeCaloricLevel = 
	menu.stream().collect(
		groupingBy(Dish::getType, //첫 번째 수준의 분류 함수
			groupingBy(dish -> {    //두 번째 수준의 분류 함수
				if (dish.getCalories() <= 400) return CaloricLevel.DIET;
				else if (dish.getCalories <= 700) return CaloricLevel.NORMAL;
				else return CaloricLevel.FAT;
			})
		)
	);
//그룹화 결과
{MEAT={DIET[chicken], NORMAL=[...], FAT=[...]}, FISH={...}, OTHER={...}}
```

그룹화의 결과로 두 수준의 맵이 만들어 진다.

외부 맵은 첫 번째 수준의 분류함수에서 분류한 키값 - meat, fish, other 을 갖고, 두 번째 수준의 분류함수에서 분류한 키값 - normal, diet, fat 을 키값으로 값는다. 즉, n수준 그룹화의 결과는 n수준 트리 구조로 표현되는 n 수준 맵이 된다.

### 서브그룹으로 데이터 수집

다수준 그룹화에서는 `gourpingBy` 를 두 번째 인수로 전달했지만, 첫 번째 `groupingBy` 로 넘겨주는 컬렉터의 형식은 제한이 없다. 다음처럼 `couting` 컬렉터를 전달해서 요리의 수를 종류별로 계산하는 코드를 작성할 수도 있다.

```java
Map<Dish, Type, Long> typesCount = menu.stream().collect(
	groupingBy(Dish::getType, counting()));
//결과 맵
{MEAT=3, FISH=2, OTHER=4}
```

분류 함수 한 개의 인수를 갖는 `gourpingBy(f)` 는 `groupingBy(f, toList())` 의 축약형이다.

**컬렉터 결과를 다른 형식에 적용**

만약 `maxBy` 를 사용한 그룹화의 결과는 Optional<Dish>가 반환될 것이다. 하지만 맵의 모든 값은 Optional로 감쌀 필요가 없으므로 Optional을 삭제할 수도 있다. 팩토리 메서드 `Collectors.collectingAndThen` 으로 컬렉터가 반환한 결과를 다른 형식으로 활용할 수 있다.

```java
Map<Dish, Type, Dish> mostCaloricByType = 
	menu.stream().collect(groupingBy(Dish::getType, 
		collectingAndThen(
			maxBy(comparingInt(Dish::getCalories)), Optional::get));
```

`Collectors.collectingAndThen` 은 적용할 컬렉터와 변환할 함수를 인수로 받아 다른 컬렉터를 반환한다. 

반환되는 컬렉터는 기존 컬렉터의 래퍼 역할을 하며 collect의 마지막 과정에서 변환 함수로 자신이 반환하는 값을 매핑한다.

> 팩토리 메서드 maxBy가 생성하는 컬렉터의 결과 형식에 따라 맵의 결과가 Optional 이 되었다.
> 
> 
> 실제로 요리 중 Optional.empty()를 값으로 갖는 요리는 존재하지 않는다. 처음부터 존재하지 않는 요리의 키는 맵에 추가되지 않기 때문이다. groupingBy 컬렉터는 스트림의 첫 번째 요소를 찾은 이후에야 그룹화 맵에 새로운 키를 추가한다. 리듀싱 컬렉터가 반환하는 형식을 사용하는 상황이므로 굳이 Optional 래퍼를 사용할 필요가 없다.
> 

---

## 분할

분할은 분할 함수라 불리는 프레디케이트를 분류 함수로 사용하는 특수한 그룹화 기능이다. 분할 함수는 불리언을 반환하므로 맵의 키 형식은 Boolean 이다. 결과적으로 그룹화 맵은 최대 두 개의 그룹으로 분류된다.

### 장점

분할 함수가 반환하는 참, 거짓 두 가지 요소의 스트림 리스트를 모두 유지한다는 것이 분할의 장점이다.

```java
Map<Boolean, List<Dish>> partitionedMenu = 
	menu.stream().collect(partitioningBy(Dish::isVegetarian));
```

또한 다음 코드에서 보여주는 것처럼 컬렉터를 두 번째 인수로 전달할 수 있는 오버로드된 버전의 `partitioningBy` 메서드도 있다.

```java
Map<Boolean, Map<Dish.Type, List<Dish>>> vegetarianDishesByType = 
	menu.stream().collect(partitioningBy(Dish::isVegetarian, groupingBy(Dish::getType));숫자를 소수와 비소수로 분할하기
```

### Collectors 클래스의 정적 팩토리 메서드

| 팩토리 메서드 | 반환 형식 | 사용 예시 |
| --- | --- | --- |
| toList | List<T> | 스트림의 모든 항목을 리스트로 수집 |
| toSet | Set<T>  | 스트림의 모든 항목을 중복이 없는 집합으로 수집 |
| toCollection | Collection<T> | 스트림의 모든 항목을 발행자가 제공하는 컬렉션으로 수집 |
| counting | Long | 스트림의 항목 수 계산 |
| summingInt | Integer | 스트림의 항목에서 정수 프로퍼티값을 더함 |
| averageingInt | Double | 스트림 항목의 정수 프로퍼티의 평균 값 계산 |
| joining | String | 스트림의 각 항목에 toString 메서드를 호출한 결과 문자열 연결 |
| maxBy | Optional<T> | 주어진 비교자를 이용해서 스트림의 최댓값 요소를 Optional로 감싼 값을 반환, 스트림에 요소가 없을 때는 Optional.empty() 반환 |
| minBy | Optional<T> | 주어진 비교자를 이용해서 스트림의 최솟값 요소를 Optional로 감싼 값을 반환, 스트림에 요소가 없을 때는 Optional.empty() 반환 |
| reducing |  | 누적자를 초깃값으로 설정한 다음에 BinaryOperator로 스트림의 각 요소를 반복적으로 누적자와 합쳐 스트림의 값으로 리듀싱 |
| collectingAndThen |  | 다른 컬렉터를 감싸고 그 결과에 변환 함수 적용 |
| groupingBy | Map<K, List<T>> | 하나의 프로퍼티 값을 기준으로 스트림의 항목을 그룹화 하며 기준 프로퍼티 값을 결과 맵의 키로 사용 |
| partitioningBy | Map<Boolean, List<T>> | 프레디케이트를 스트림의 각 항목에 적용한 결과로 항목 분할 |

---

## Collector 인터페이스

Collector 인터페이스는 리듀싱 연산을 어떻게 구현할지 제공하는 메서드 집합으로 구성된다. 

```java
public interface Collector<T, A, R> {
	Supplier<A> supplier();
	BiConsumer<A, T> accumulator();
	Function<A, R> finisher();
	BinarOperator<A> combiner();
	Ser<Characteristics> characteristics();
}
```

- T는 수집될 스트림 항목의 제네릭 형식이다.
- A는 누적자, 즉 수집 과정에서 중간 결과를 누적하는 객체의 형식이다.
- R은 수집 연산 결과 객체의 형식이다.

### Collector 인터페이스의 메서드 살표보기

**supplier 메서드 : 새로운 결과 컨테이너 만들기**

`supplier` 메서드는 빈 결과로 이루어진 Supplier를 반환해야 한다. 즉, `supplier` 는 수집 과정에서 빈 누적자 인스턴스를 만드는 파라미터가 없는 함수다.

`ToListCollector` 처럼 누적자를 반환하는 컬렉터에서는 빈 누적자가 비어있는 스트림의 수집 과정의 결과가 될 수 있다.

```java
public Supplier<List<T>> supplier(){
	return ArrayList::new;
}
```

**accumulator 메서드 : 결과 컨테이너에 요소 추가하기**

`accumulator` 메서드는 리듀싱 연산을 수행하는 함수를 반환한다.

스트림에서 n번째 요소를 탐색할 때 두 인수, 누적자와 n번째 요소를 함수에 적용한다.

```java
public BiConsumer<List<T>, T> accumulator(){
	return (list, item) -> list.add(item);
}
```

**finisher 메서드 : 최종 변환값을 결과 컨테이너로 적용하기**

`finisher` 메서드는 스트림 탐색을 끝내고 누적자 객체를 최종 결과로 반환하면서 누적 과정을 끝낼 때 호출할 함수를 반환해야 한다.

```java
public Function<List<T>, List<T>> finisher(){
	return Function.identity();
}
```

**combiner 메서드 : 두 결과 컨테이너 병합**

`combiner` 메서드는 스트림의 서로 다른 서브파트를 병렬로 처리할 때 누적자가 이 결과를 어떻게 처리할지 정의한다.

```java
public BinaryOperator<List<T>> combiner(){
	return (list1, list2) -> {
		list1.addAll(list2);
		return list1;
	}
}
```

이 메서드를 이용하면 스트림의 리듀싱을 병렬로 수행할 수 있다.스트림의 리듀싱을 병렬로 수행할 때 자바 7의 포크/조인 프레임워크와 Spliterator를 사용한다.

**Characteristics 메서드**

`characteristics` 메서드는 컬렉터의 연산을 정의하는 Characteristics 형식의 불변 집합을 반환한다.

Characteristics 는 스트림을 병렬로 리듀스할 것인지 그리고 병렬로 리듀스한다면 어떤 최적화를 선택해야 할지 힌트를 제공한다. Characteristics 는 다음 세 항목을 포함하는 열거형이다.

- UNORDERED : 리듀싱 결과는 스트림 요소의 방문 순서나 누적 순서에 영향을 받지 않는다.
- CONCURRENT : 다중 스레드에서 accumulator 함수를 동시에 호출할 수 있으며, 이 컬렉터는 스트림의 병렬 리듀싱을 수행할 수 있다. 컬렉터의 플레그에 UNORDERED 를 함께 설정하지 않았다면 데이터 소스가 정렬되어 있지 않은 상황에서만 병렬 리듀싱을 수행할 수 있다.
- IDENTITY_FINISH : finisher 메서드가 반환하는 함수는 단순히 identity를 적용할 뿐이므로 이를 생략할 수 있다. 따라서 리듀싱 과정의 최종 결과로 누적자 객체를 바로 사용할 수 있다. 또한 누적자 A를 B로 안전하게 형변환 할 수 있다.

---

# 7. 병렬 데이터 처리와 성능

스트림을 이용하면 아주 간단하게 요소를 병렬로 처리할 수 있다.

컬렉션에 `parallelStream` 을 호출하면 병렬 스트림이 생성된다. 병렬 스트림이란 각각의 스레드에서 처리할 수 있도록 스트림 요소를 여러 청크로 분할한 스트림이다. 따라서 병렬 스트림을 이용하면 모든 멀티코어 프로세서가 각각의 청크를 처리하도록 할당할 수 있다.

**병렬 스트림을 사용하지 않은 1부터 n까지 합계를 반환하는 메서드**

```java
public long sequentialSum(long n){
	return Stream.iterate(1L, i -> i+1)
		.limit(n)
		.reduce(0L, Long::sum)
}
```

### 순차 스트림을 병렬 스트림으로 반환

순차 스트림에 `parallel` 메서드를 호출하면 기존의 함수형 리듀싱 연산이 병렬로 처리된다.

```java
public long parallelSum(long n){
	return Stream.iterate(1L, i -> i+1)
		.limit(n)
		.parallel() //스트림을 병렬 스트림으로 변환
		.reduce(0L, Long::sum);
}
```

이전의 코드와 다른 점은 스트림이 여러 청크로 분할되어 있다는 것이다. 따라서 리듀싱 연산을 여러 청크에 병렬로 수행할 수 있다. 마지막으로 리듀싱 연산으로 생성된 **부분 결과**를 다시 리듀싱 연산으로 합쳐서 전체 스트림의 리듀싱 결과를 도출한다.

`parallel` 을 호출해도 스트림 자체에는 아무 변화도 일어나지 않는다. 내부적으로는 호출 이후 연산이 병렬로 수행되야 함을 의미하는 불리언 플래그가 설정된다.

반대로 `sequential` 로 병렬 스트림을 순차 스트림으로 바꿀 수도 있다. 두 메서드가 동시에 호출되었다면, 최종적으로 호출된 메서드가 전체 파이프라인에 영향을 미친다.

> **병렬 스트림에서 사용하는 스레드 풀 설정**
> 
> 
> 병렬 스트림은 내부적으로 ForkJoinPool을 사용한다. 기본적으로 ForkJoinPool 은 프로세서 수, 즉 `Runtime.getRuntime().availableProcessors()` 가 반환하는 값에 상응하는 스레드를 갖는다.
> 

### 스트림 성능 측정

자바 마이크로벤치마크 하이니스(JMH)라는 라이브러리를 이용해 작은 벤치마크를 구현할 수 있다. JMH를 이용해면 간단하고, 어노테이션 기반 방식을 지원하며, 안정적으로 자바 프로그램이나 JVM을 대상으로하는 다른 언어용 벤치마크를 구현할 수 있다.

JVM을 실행되는 프로그램을 벤치마크하는 작업은 쉽지 않다. 핫스팟이 바이트코드를 최적화하는데 필요한 준비시간, 가비지 컬렉터로 인한 오베헤드 등과 같은 여러 요소를 고려해야하기 때문이다.

```java
@BenchmarkMode(Mode.AverageTime) //벤치마크 대상 메서드를 실행하는 데 걸린 평균 시간 측정
@OutPutTimeUnit(TimeUnit.MILLISECONDS) //벤치마크 결과를 밀리초 단위로 출력
@Fork(2, jvmArgs={"-Xms4G", "-Xmx4G"}) //4Gb의 힙 공간을 제공한 환경에서 두번 벤치마크를 수행해 결과의 신뢰성 확보
public class ParallelStreamBenchmark{
	private static final long N = 10_000_000L;

	@Benchmark
	public long sequentialSum(){
		return Stream.iterate(1L, i -> i+1).limit(n).reduce(0L, Long::sum);
	}
	@TearDown(Level.Invocation) //매 번 벤치마크를 실행한 다음에는 가비지 컬렉터 동작 시도
	public void tearDown(){
		System.gc();
	}
}
```

위 코드처럼 병렬 스트림 등을 실행해보면 예상과 다른 결과를 출력한 것을 확인할 수 있다.

- 반복문> 순차 스트림 > 병렬 스트림 순서다.
- 문제점
    - 반복 결과로 박싱된 객체가 만들어지므로 숫자를 더하려면 언박싱을 해야 한다.
    - 반복 작업은 병렬로 수행할 수 있는 독립 단위로 나누기가 어렵다.

리듀싱 연산과정을 시작하는 시점에 전체 숫자 리스트가 준비되지 않았으므로 스트림을 병렬로 처리할 수 있도록 청크로 분할할 수 없다. 스트림이 병렬로 처리되도록 지시했지만 결국 순차 처리 방식과 다른 점이 없고, 오히려 스레드를 할당하는 오버헤드만 증가하게 된다.

이처럼 병렬 프로그래밍은 까다롭고 오용하면 전체 성능이 더 나빠질 수도 있다.

**더 특화된 메서드 사용**

효과적으로 합계 연산을 수행하기 위해 `LongStream.rangeClosed` 라는 메서드를 사용할 수도 있다.

- `LongStream.rangeClosed` 는 기본형 long을 직접 사용하므로 박싱, 언박싱 오버헤드가 사라진다.
- `LongStream.rangeClosed` 는 쉽게 청크로 분할할 수 있는 숫자 범위를 생산한다.

해당 메서드를 사용해 벤치마크를 측정해보면, 기존의 `iterate` 팩토리 메서드로 생성한 순차 버전에 비해 이 예제의 숫자 스트림 처리 속도가 더 빠르다. 박싱, 언박싱으로 인한 오베헤드가 사라졌기 때문이다. 상황에 따라서는 어떤 알고리즘을 병렬화 하는 것 보다 적절한 자료구조를 선택하는 것이 더 중요하다는 사실을 단적으로 보여준다.

또한, 병렬 스트림의 벤치마크도 원하는 성능을 나타내었다.

하지만 병렬화가 완전 공짜가 아니라는 사실을 기억하자. 병렬화를 이용하려면 스트림을 재귀적으로 분할해야 하고, 각 서브스트림을 서로 다른 스레드의 리듀싱 연산으로 할당하고, 이들 결과를 하나의 값으로 합쳐야 한다. 멀티코어 간의 데이터 이동은 우리 생각보다 비싸다. 

따라서, 코어 간에 데이터 전송 시간보다 훨씬 오래 걸리는 작업만 병렬로 다른 코에에서 수행하는 것이 바람직하다.

### 병렬 스트림의 올바른 사용법

병렬 스트림을 잘못 사용하면서 발생하는 많은 문제는 공유된 상태를 바꾸는 알고리즘을 사용하기 때문에 일어난다.

```java
public long sideEffectSum(long n){
	Accumulator accumulator = new Accumulator();
	LongStream.rangeClosed(1, n).forEach(accumulator::add);
	return accumulator.total;
}
public class Accumulator{
	public long total = 0;
	public void add(long value){ total += value;}
}
```

위 코드는 본질적으로 순차 실행할 수 있도록 구현되어 있으므로 병렬로 실행하면 문제가 발생한다. 특히 total을 접글할 때마다 (다수의 스레드에서 동시에 데이터에 접근) 데이터 레이스 문제가 발생한다. 동기화로 문제를 해결하다 보면 결국 병렬화라는 특성이 없어져 버릴 것 이다.

실제로 `parallel` 을 적용해보면 성능을 둘째로 하더라도 정상적인 결과가 출력되지 않을 것이다. 여러 스레드에서 동시에 누적자 `total` 를 실행하면서 이런 문제가 발생한다.

결과적으로 병렬 스트림과 병렬 계산에서는 **공유된 가변 상태를 피해야한다.**

### 병렬 스트림 효과적으로 사용하기

양을 기준으로 병렬 스트림 사용을 결정하는 것은 적절하지 않다. 정해진 기기에서 정해진 연산을 수행할 때는 이와 같은 기준을 사용할 수 있지만 상황이 달라지면 무용지물일 것이다. 

- 확신이 서지 않으면 직접 측정하라.
    
    순차 스트림을 병렬 스트림으로 쉽게 바꿀 수 있다. 하지만 무조건 병렬 스트림으로 바꾸는 것이 능사는 아니다. 언제나 병렬 스트림이 순차 스트림 보다 빠른건 아니기 때문이다. 만약 어떤 것이 좋은지 모르겠다면, 적절한 벤치마크로 직접 성능을 측정하는 것이 바람직하다.
    
- 방식을 주의하라.
    
    자동 박싱, 언방식은 성능을 크게 저하시킬 수 있는 요소다. 이런 것을 피할 수 있도록 기본형 특화 스트림을 제공한다.
    
- 순차 스트림보다 병렬 스트림에서 성능이 떨어지는 연산이 있다.
    
    특히 limit나 findFirst 처럼 요소의 순서에 의존하는 연산을 병렬스트림에서 수행하려면 비싼 비용을 치러야 한다. 스트림에 N개의 요소가 있을 때 요소의 순서가 상관 없다면, 비정렬된 스트림에 limit를 호출하는 것이 효율적이다.
    
- 소량의 데이터에서는 병렬 스트림이 도움 되지 않는다.
    
    소량의 데이터를 처리하는 상황에서는 병렬화 과정에서 생기는 부가 비용을 상쇄할 수 있을 만큼의 이득을 얻지 못하기 때문이다.
    
- 스트림을 구성하는 자료구조가 적절한지 확인하라.
    
    예를들어 ArrayList를 LinkedList보다 효율적으로 분할할 수 있다. LinkedList를 분할하려면 모든요소를 탐색해야 하기 때문이다. 또한 range 팩토리 메서드로 만든 기본형 스트림도 쉽게 분할할 수 있다.
    
- 스트림의 특성과 파이프라인의 중간 연산이 스트림의 특성을 어떻게 바꾸는지에 따라 붆 과정의 성능이 달라질 수 있다.
    
    SIZED 스트림은 정확히 같은 크기의 스트림으로 분할할 수 있으므로 효과적으로 스트림을 병렬 처리할 수 있다. 반면 필터 연산이 있으면 길이를 예측할 수 없어 효과적으로 스트림을 병렬 처리할 수 있을지 알 수 없게된다.
    
- 최종 연산의 병합 과정 비용을 살펴보라.
    
    병합 과정의 비용이 비싸다면 병렬 스트림으로 얻은 성능의 이익이 서브스트림의 부분 결과를 합치는 과정에서 상쇄될 수 있다.
    

---

## 포크/조인 프레임워크

포크/조인 프레임워크는 병렬화 할 수 있는 작업을 재귀적으로 작은 작업으로 분할한 다음 에 서브태스크 각각의 결과를 합쳐서 전체 결과를 만들도록 설계되었다. 

포크/조인 프레임워크에서는 서브태스크를 스레드 풀의 작업자 스레드에 분산 할당하는 `ExecutorService` 인터페이스를 구현한다.

### RecursiveTask 활용

스레드 풀을 이용하려면 `RecursiveTask<R>` 의 서버클래스를 만들어야 한다. 여기서 R은 병렬화된 태스크가 생성하는 결과 형식 또는 결과가 없을 때는 RecursiveAction 형식이다.

RecuresiveTask를 정의하려면 추상 메서드 `compute`를 구현해야 한다.

```java
protected abstract R compute();
```

`compute` 메서드는 태스크를 서브태스크로 분할하는 로직과 더 이상 분할할 수 없을 때 개별 서브태스크의 결과를 생산할 알고리즘을 정의한다. 따라서 대부분의 `compute` 메서드 구현은 다음과 같은 의사코드 형식을 유지한다.

```java
if (태스크가 충분히 작거나 더 이상 분할할 수 없으면){
	순차적으로 테서크 계산
} else {
	태스크를 두 서브태스크로 분할
	태스크가 다스 서브태스크로 분할되도록 이 메서드를 재귀적으로 호출함
	모든 서브태스크의 연산이 완료될 때까지 기다림
	각 서브태스크의 결과를 합침
}
```

이 알고리즘은 분할 후 정복 알고리즘의 병렬화 버전이다.

```java
public class ForkJoinSumCalculator extends java.util.concurrent.RecursiveTask<Long>{
	private final long[] numbers;
	private final int start;
	private final int end;
	private static final long THRESHOLD = 10_000;

	public FOrkJoinSumCalculator(long[] numbers){
		this(numbers, 0, numbers.length);
	}
	
	private ForkJoinSumCalculator(long[] numbers, int start, int end){
		this.numbers = nubmers;
		this.start = start;
		this.end = end;
	}
	
	@Override
	protected Long compute() {
		int length = end- start;
		if (longth <= THRESHOLD){
			return computeSequaentilally();
		}
		ForkJoinSumCalculator leftTask = new ForkJoinSumCalculator(numbers, start, start+length/2);
		leftTask.fork();
		ForkJoinSumCalculator rightTask = new ForkJoinSumCalculator(numbers, start + length/2, end);
		Long rightResult = rightTask.compute();
		Long leftResult = leftTask.join();
		return leftResult + rightResult;
	}
	private long scomputeSequentilally(){
		long sum = 0;
		for (int i = start; i < end ; i++){
			sum += numbers[i];
		}
		return sum;
	}
}
```

포크/조인 프레임워크의 합계 메서드의 성능을 벤치마크로 확인해보면 기존의 병렬 스트림보다 성능이 나빠졌다. 이는 ForkJoinSumCalculator 태스크에서 사용할 수 있도록 전체 스트림은 long[]으로 변환했기 때문이다.

### 포크/조인 프레임워크를 제대로 사용하는 방법

포크/조인 프레임워크는 쉽게 사용할 수 있는 편이지만 주의를 기울여야한다.

- join메서드를 태스크에 호출하면 태스크가 생산하는 결과가 준비될때까지 호출자를 블록시킨다. 따라서 두 서브태스크가 모두 시작된 다음에 join을 호출해야 한다. 그렇지 않으면 각각의 서브태스크가 다른 태스카가 끝나길 기다리는 일이 발생하며, 원래 순차 알고리즘보다 느리고 복잡한 프로그램이 되어버릴 수 있다.
- RecuresiveTask 내에서는 ForkJoinPool의 invoke 메서드를 사용하지 말아야한다. 대신 compute나 fork메서드를 직접 호출할 수 있다. 순차 코드에서 병렬 계산을 시작할 때만 invoke를 사용한다.
- 서브태스크에 fork 메서드를 호출해서 ForkJoinPool의 일정을 조절할 수 있다. 왼쪽 작업과 오른쪽 작업 모두에 fork 메서드를 호출하는 것이 자연스러울 것 같지만 한쪽 작업에는 compute를 호출하는 것이 효율적이다. 그러면 두 서브태스크의 한 태스크에서는 같은 스레드를 재사용할 수 있으므로 풀에서 불필요한 태스크를 할당하는 오버헤드를 피할 수 있다.
- 포크/조인 프레임워크를 이용하는 병렬 계산은 디버깅하기 어렵다. 보통 ID로 디버깅할 때 스택 트레이스로 문제가 일어난 과정을 쉽게 확인할 수 있는데, 포크/조인 프레임워크에서는 fork라 불리는 다른 스레드에서 compute를 호출하므로 스택 트레이스가 도움이 되지 않는다.
- 병렬 스트림에서 살펴본 것처럼 멀티코어에 포크/조인 프레임워크를 사용하는 것이 순차 처리보다 무조건 빠를 거라는 생각은 버려야 한다. 병렬 처리로 성능을 개선하려면 태스크를 여러 독립적인 서브태스크로 분할할 수 있어야 한다. 각 서브태스크의 실행시간은 새로운 태스크를 포킹하는데 드는 시간보다 길어야 한다. 또한 순차 버전과 병렬 버전의 성능을 비교할 때는 다른 요소도 고려해야한다.

### 작업 훔치기

서브태스크 분할을 중단했다. 여기서 기준을 바꿔가며 실험해보는 방식 말고는 좋은 기준을 찾을 방법이 없어보인다. 

작업 훔치기 기법에서는 ForkJoinPool의 모든 스레드를 거의 공정하게 분할한다. 각각의 스레드는 자신에게 할당된 태스크를 포함하는 이중 연결 리스트를 참조하며 작업이 끝날때 마다 큐의 헤드에서 다른 태스크를 가져와서 작업을 처리한다.

한 스레드의 작업이 끝나면 유휴 상태로 바뀌는 것이 아닌 다른 스레드의 꼬리에서 작업을 훔쳐온다. 모든 큐가 빌 때까지 이 작업을 반복한다. 따라서 태스크의 크기를 작게 나누어야 작업자 스레드 간의 작업부하를 비슷한 수준으로 유지할 수 있다.

---

## Spliterator 인터페이스

자바 8은 Spliterator라는 새로운 인터페이스를 제공한다.

Iterator 처럼 소스의 요소 탐색 기능을 제공한다는 점은 같지만 Spliterator는 병렬 작업에 특화되어 있다. 자바 8 은 컬렉션 프레임워크에 포함된 모든 자료구조에 사용할 수 있는 디폴트 Spliterator 구현을 제공한다.

```java
public interface Spliterator<T>{
	boolean tryAdvance(Consumer<? super T> action);
	Spliterator<T> trysplit();
	long estimateSize();
	int characteristics();
}
```

- `tryAdvance` : 요소를 하나씩 순차적으로 소비하며 탐색할 요소가 남아있으면 true 반환
- `trySplit` : 일부 요소를 분할해서 두 번째 Spliterator를 생성
- `estimateSize` : 탐색해야할 요소 수 정보를 제공
- `characteristics` : Spliterator 자체 특성 집합을 포함하는 int 를 반환한다.
