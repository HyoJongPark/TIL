# 모던 자바 인 액션

<img src="https://user-images.githubusercontent.com/75190035/155264476-7167c8c1-7447-4235-8163-8400017ba9e0.png" width="500" width="500">

- [동작 파라미터화 코드 전달하기](https://github.com/HyoJongPark/TIL/new/main/Java#2-%EB%8F%99%EC%9E%91-%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0%ED%99%94-%EC%BD%94%EB%93%9C-%EC%A0%84%EB%8B%AC%ED%95%98%EA%B8%B0)

---

# 2. 동작 파라미터화 코드 전달하기

### 동작 파라미터화란?

아직은 어떻게 실행할 것인지 결정하지 않은 코드 블록을 의미한다. 이 코드 블록은 나중에 프로그램에서 호출한다.(즉, 코드 블록의 실행은 나중으로 미뤄진다.)

동작 파라미터화를 이용하면 자주 바뀌는 요구사항에 효과적으로 대응할 수 있다.

### 1. 녹색 사과 필터링

```java
public static List<Apple> filterGreenApples(List<Apple> inventory){
	List<Apple> result = new ArrayList<>();
	for (Apple apple : inventory){
		if (GREEN.equals(apple.getColor()) result.add(apple);
	}
	return result;
}
```

만약 위 코드에서 필터링 할 색을 변경해야할 경우 if문의 조건을 변경하는 방법을 사용할 수도 있지만, 나중에 더 다양한 색으로 필터링하는 등의 변화에는 적절하게 대응할 수 없을 것이다.

이런 상황에서는 다음과 같은 규칙이 있다.

**거의 비슷한 코드가 반복 존재한다면, 그 코드를 추상화한다.**

### 2. 색을 파라미터화

 색을 파라미터화 할 수 있도록 메서드에 파라미터를 추가하면, `filterGreenApples` 의 코드를 반복 사용하지 않고 `filterRedApples` 를 구현할 수 있고, 결과적으로 변화하는 요구사항에 좀 더 유연하게 대응하는 코드를 만들 수 있다.

```java
public static List<Apple> filterApplesByColor(List<Apple> inventory, Color color){
	List<Apple> result = new ArrayList<>();
	for (Apple apple : inventory){
		if (apple.getColor().equals(color)) result.add(apple);
	}
	return result;
}
```

위와같이 변경하면, 모든 색에 대해 필터링 가능한 메서드가 만들어진다. 그런데 무게에 따른 필터링이 요구사항으로 발생한다면 어떨까?

```java
public static List<Apple> filterApplesByWeight(List<Apple> inventory, int weight){
	List<Apple> result = new ArrayList<>();
	for (Apple apple : inventory){
		if (apple.getWeight() > weight) result.add(apple);
	}
	return result;
}
```

위 코드로 해결할 수 있겠지만 색 필터링의 코드와 대부분 중복되는 코드다. 이는 DRY(같은 것을 반복하지 말 것)라는 소프트웨어 원칙을 어기는 것이다.

### 3. 가능한 모든 속성으로 필터링

플래그라는 파라미터를 추가해 어떤 것을 기준으로 필터링 할지 구분할 수 있다.(실전에서 사용권장 x)

```java
public static List<Apple> filterApples(List<Apple> inventory, Color color, 
																			 int weight, boolean flag){
	List<Apple> result = new ArrayList<>();
	if ((flag && apple.getColor().equals(color)) ||
			(!flag && apple.getWeigt > weight)){
		result.add(apple);
	}
	return result;
}
```

위 코드에서 true와 false가 무엇을 의미하는지 불분명하고, 요구사항이 바뀌었을 때 유연하게 대응할 수도 없다.

## 동작 파라미터화

```java
public interface ApplePredicate{
	boolean test(Apple apple);
}
```

```java
public class AppleHeavyWightPredicate implements ApplePredicate{
	public boolean test(Apple apple){
		return apple.getWeight() > 150;
	}
}
```

```java
public class AppleGreenColorPredicate implements ApplePredicate{
	public boolean test(Apple apple){
		return GREEN.equals(apple.getColor());
	}
}
```

위 조건에 따라 filter메서드가 다르게 동작할 것이라고 예상할 수 있다. 이를 전략 디자인 패턴이라고 부른다.

전략 디자인 패턴은 각 알고리즘(`AppleHeavyWieghtPredicate, AppleGreenColorPredicate`)을 캡슐화 하는 알고리즘 패밀리(`ApplePredicate`)를 정의해둔 다음에 런타임에 알고리즘을 선택하는 기법이다.

`ApplePredicate` 객체를 `FilterApples` 에서 받아 검사하도록 변경하면, 메서드가 다양한 동작을 받아서 내부적으로 다양한 동작을 수행할 수 있게된 것이다.(**동작 파라미터화**)

### 4. 추상적 조건으로 필터링

```java
public static List<Apple> filterApples(List<Apple> inventory, ApplePredicate p){
	List<Apple> result = new ArrayList<>();
	for(Apple apple : inventory){
		if(p.test(apple)) result.add(apple);
	}
	return result;
}
```

가장 처음의 코드보다 가독성, 유연성, 사용성 면에서 우수한 코드가 만들어 졌다. 이제 변경된 요구사항은 구현된 알고리즘의 수정혹은 또다른 전략의 구현으로 적절히 대응할 수 있다. 

실제 사용에서 적용할 때 구현한 알고리즘을 파라미터로 전달해 원하는 결과를 얻을 수 있다.

```java
List<Apple> greenApples = filterApples(inventory, new AppleGreenColorPredicate());
```

### 5. 익명 클래스 사용

```java
List<Apple> greenApples = filterApples(inventory, new ApplePredicate(){
	public boolean test(Apple apple){
		return RED.equals(apple.getColor());
	}
});
```

익명 클래스로 구현된 객체를 사용하면 2가지 단점이 있다.

1. 여전히 많은 공간을 차지한다.
    - 여러 클래스를 정의할 코드를 줄이기 위해서 사용했지만, 여전히 많은 공간을 차지한다.
2. 많은 프로그래머가 익명 클래스 사용에 익숙하지 않다.

코드의 장황함은 나쁜 특성이다. 장황한 코드는 구현, 유지보수하는데 시간이 많이 걸리고 가독성도 좋지않다. 익명 클래스로 인터페이스를 구현하는 클래스를 선언하는 과정을 줄일 수 있지만 만족스럽지 않다.

자바 8에서는 동작 파라미터화의 다음과 같은 문제를 람다 표현식이라는 간단한 코드 전달 기법을 도입해 해결했다.

### 6. 람다 표현식 사용

```java
List<Apple> result = filterApples(inventory, (Apple apple) -> RED.equals(apple.getColor()));
```

익명 클래스에 비해 람다 표현식을 사용했을 때 더 간결한 코드를 만들 수 있다.

### 7. 리스트 형식으로 추상화

```java
public interface Predicate<T>{
	boolean test(T t);
}
```

```java
public static <T> List<T> filter(List<T> list, Predicate<T> p){
	List<T> result = new ArrayList<>();
	for (T e : list){
		if(p.test(e)) return result.add(e);
	}
	return result;
}
```

이제 사과 뿐만 아니라 다른 요소들도 해당 기능을 사용해 구분할 수 있게 됐다.

### 정리

- 동작 파라미터화에서는 메서드 내부적으로 다양한 동작을 수행할 수 있도록 코드를 메서드 인수로 전달한다.
- 동작 파라미터화를 이용하면 변화하는 요구사항에 더 잘 대응할 수 있는 코드를 구현할 수 있으며, 나중에 엔지니어링 비용을 줄일 수 있다.
- 코드 전달 기법을 이용하면 동작을 메서드 인수로 전달할 수 있다.
    - 자바 8 이전에는 지저분한 코드
    - 익명 클래스를 사용해 1차 개선
    - 람다 표현식을 사용해 인터페이스를 상속받아 여러 클래스를 구현해야하는 수고를 없앨 수 있게됨.
- 자바 API의 많은 메서드는 정렬, 스레드, GUI 처리 등을 포함한 다양한 동작으로 파라미터화 할 수 있다.

---
