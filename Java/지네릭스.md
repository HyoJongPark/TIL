# 지네릭스

지네릭스는 다양한 타입의 객체들을 다루는 메서드나 컬렉션 클래스에 컴파일 시의 **타입체크(compile-time type check)를 해주는 기능**

장점

- 타입 안정성을 제공
- 타입체크와 형변환을 생략할 수 있으므로 코드가 간결해 진다.

---

## 사용 예시

- 지네릭 클래스 생성

Box.java

```java
class Box<T>{
	T item;
	void setItem(T item) {this.item = item;}
	T getItem() {return item;}
}
```

- 지네릭 클래스 객체 생성과 사용

```java
Box<String> box = new Box<String>(); //타입 T대신, 실제 타입 지정
box.setItem(new Object());           //에러 -> String타입 이외의 타입 지정 불가
box.setItem("ABC");                  //OK  ->  String타입
String item = ~~(String)~~ box.getItem();//이미 String 타입체크가 완료되었기 때문에 형변환 필요x

// 지네릭이 도입되기 이전의 코드와 호환을 위해, 
// 지네릭 클래스임에도 예전의 방식으로 객체를 생성가능
Box box = new Box();        //Ok. 여기서 T는 Object로 간주됨
box.setItem(new Object());  //경고. uncheked or unsafe operation
box.setItem("ABC");         //경고. uncheked or unsafe operation
```

- 실제 타입을 지정한 객체를 생성하고 난 이후, 지네릭스는 실제 타입으로 타입 체크한다.
- 상속관계에서
    - 실제 타입의 부모 타입은 타입 체크를 통과하지 못한다.
    - 실제 타입의 자식 타입은 타입 체크를 통과한다.
- 위 코드에서 String으로 실제 타입을 지정한 것으로 인해서 Box.java는 다음과 같이 변한 것과 같은 효과를 낸다.

```java
class Box{
	String item;
	void setItem(String item) {this.item = item;}
	String getItem() {return item;}
}
```

---

## 지네릭스 용어

- `Box<T>` : 지네릭 클래스. T의 Box, T Box라고 읽는다
- `T`            : 타입 변수 또는 타입 매개변수.
- `Box`        : 원시 타입
- 위 코드에서 처럼 타입 매개변수에 타입을 지정하는 것을 ‘지네릭 타입 호출’
- 지정된 타입(위에서는 String)을 ‘매개변수화된 타입(parameterized type)’  혹은  간단히 ‘대입된 타입’

---

## 지네릭스의 제한

```java
class Box<T> {
	static T item;                      //에러
	static int compare(T t1, T t2){...} //에러

	T[] itemArr;                          //OK. T타입의 배열을 위한 참조 변수
	T[] toArray(){
		T[] tmpArr = new T[itemArr.length]; //에러. 지네릭 배열 생성 불가
		...
		return tmpArr;
		}
	...
}
```

- 모든 객체에 대해 동일하게 동작해야하는 static멤버에 타입 변수 T를 사용할 수 없다.
    - **T는 인스턴스 변수로 간주되기 때문, static멤버는 인스턴스를 참조할 수 없다.**
    - Box<Apple>.item과 Box<Grape>.item이 동일해야 한다는 것
- 지네릭 타입의 배열을 생성할 수 없다.
    - 지네릭 배열 타입의 참조변수를 선언하는 것은 가능하지만, ‘new T[10]’과 같이 배열을 생성하는 것은 안된다.
    - new연산자 때문 → 컴파일 시점에 타입T가 뭔지 정확히 알아야 한다.
    - instanceof연산자도 같은 이유로 사용할 수 없다.

---

## 지네릭 클래스의 객체 생성과 사용

```java
class Box<T> {
	ArrayList<T> list = new ArrayList<T>();
	
	void add(T item)         {list.add(item);}
	T get(int i)             {return list.get(i);}
	ArrayList<T> getList()   {return list;}
	int size()               {return list.size();}
	public String toString() {return list.toString();}
}
```

```java
Box<Apple> appleBox = new Box<Apple>(); //OK
Box<Apple> appleBox = new Box<Grape>(); //에러
```

### 다형성

```java
Box<Fruit> appleBox = new Box<Apple>();     //에러. 둘이 상속관계여도 타입이 달라 오류발생
Box<Apple> appleBox = new FruitBox<Apple>();//OK. 지네릭 클래스끼리 상속 관계에 있는건 가능

Box<Apple> appleBox = new Box<>(); //OK. JDK1.7부터 생략 가능

Box<Apple> appleBox = new Box<Apple>();
appleBox.add(new Apple()); // OK.
appleBox.add(new Grape()); //에러. Box<Apple>에는 Apple객체만 추가 가능

Box<Fruit> fruitBox = new Box<Fruit>();
fruitBox.add(new Fruit());
fruitBox.add(new Apple()); //OK. void add(Fruit item);
```

- **둘이 상속관계여도 타입이 다르기 때문에 에러 발생.**
- 추정 가능한 경우 타입을 생략 가능
    - 참조변수의 타입으로 부터 Box가 Apple타입의 객체만 저장하는 것을 알 수 있기 때문에, 타입을 지정해 주지 않아도 된다.
- 생성된 지네릭 객체에 ‘`void add(T item)`’으로 객체를 추가할 때도 대입된 타입과 다른 타입의 객체는 추가할 수 없다.
    - 그러나 타입 T가 Fruit인 경우는 그의 자식들이 메서드의 매개변수가 될 수 있다.

---

## 제한된 지네릭 클래스

기존에 T(타입 문자)로 사용할 타입을 명시하면, 한 종류의 타입만 저장할 수 있도록 제한할 수 있지만 여전히 모든 종류의 타입을 지정할 수 있다는 것에는 변함이 없다.

지정할 수 있는 타입에 제한을 걸때 ‘extends’를 사용한다.

```java
class FruitBox<T extends Fruit>{...}
```

- 다음과 같이 사용하면 T에는 Fruit의 자식 타입만 지정할 수 있게된다.
- 여기에는 타입 뿐만아니라 특정 인터페이스를 구현한 클래스만 T에 대입될 수 있도록 할 수 있다.

---

## 와일드 카드

```java
static Juice makeJuice(FruitBox<Fruit> box){
	String tmp = "";
	for(Fruit f : box.getList()) tmp += f + " ";
	return new Juice(tmp);
}

static Juice makeJuice(FruitBox<Apple> box){
	String tmp = "";
	for(Fruit f : box.getList()) tmp += f + " ";
	return new Juice(tmp);
}
```

위와 같이 오버로딩하면 컴파일에러가 발생한다.

- **지네릭 타입이 다른것 만으로는 오버로딩이 성립하지 않는다.**
    - 단지 “메서드 중복 정의” 이다.
- 위와 같은 경우에 와일드 카드를 사용한다.

`<? extends T>` : 와일드 카드의 상한 제한, T와 그 자손들만 가능
`<? super T>`     : 와일드 카드의 하한 제한, T와 그 조상들만 가능
`<?>`                  : 제한 없음. 모든 타입이 가능 → `<? extends Object>` 와  동일 

```java
static Juice makeJuice(FruitBox<? extends Fruit> box){
	String tmp = "";
	for(Fruit f : box.getList()) tmp += f + " ";
	return new Juice(tmp);
}
```

```java
FruitBox<Fruit> fruitBox = new FruitBox<Fruit>();   //OK
FruitBox<Apple> fruitBox = new FruitBox<Apple>();   //OK
```

---

## 지네릭 메서드

메서드의 선언부에 지네릭 타입이 선언된 메서드를 지네릭 메서드라고 한다.

`static <T> void sort(List<T> list, Comparator<? super T>)`

- 지네릭 클래스에 정의된 타입 매개변수와 지네릭 메서드에 정의된 타입 매개변수는 전혀 별개의 것이다. **같은 T를 사용해도 같은 것이 아니다.**
- 이전에 static 멤버에는 타입 매개변수를 사용할 수 없었지만 메서드에 지네릭 타입을 선언하고 사용하는 것은 가능하다.
    - 메서드에 선언된 지네릭 타입은 지역 변수와 비슷하다. 메서드 내에서만 지역적으로 사용할 것이므로 static에도 사용가능하다.

```java
static <T extends Fruit> Juice makeJuice(FruitBox<T> box){
	String tmp = "";
	for(Fruit f : box.getList()) tmp += f + " ";
	return new Juice(tmp);
}
```

메서드를 사용할 시에도 이제 타입변수에 타입을 대입해야한다. 

다만, 대부분의 경우 컴파일러가 타입을 추정할 수 있기 때문에 생략 가능하다.

```java
System.out.println(Juicer.<Fruit>makeJuice(fruitBox));
System.out.println(Juicer.<Apple>makeJuice(appleBox));

System.out.println(Juicer.makeJuice(fruitBox)); // 타입 생략
System.out.println(Juicer.makeJuice(appleBox)); // 타입 생략

// 타입 생략 불가한 경우
System.out.println(<Fruit>makeJuice(appleBox)); //에러, 클래스 이름 생략 불가
System.out.println(this.<Fruit>makeJuice(appleBox));   //OK
System.out.println(Juicer.<Fruit>makeJuice(appleBox)); //OK
```

또한 인터페이스라고 해서 implements라고 쓰지 않는다.

```java
public static <T extends Comparable<? super T>> void sort(List<T> list)
```

1. 타입 T를 요소로 하는 List 를 매개변수로 허용한다.
2. ‘T’는 Comparable을 구현한 클래스여야 한다.
    - `<T extends Comparable<? super T>>`
3. 구현한 클래스는 T 또는 그 조상의 타입을 비교하는 Comparable 구현체여야 한다.
    - `Comparable<? super T>`

---

## 지네릭 타입의 형변환

### 원시 타입, 지네릭 타입

```java
Box box = null;
Box<Object> objBox = null;

box = (Box) objBox;           //OK. 지네릭 타입 -> 원시 타입. 경고 발생 
objBox = (Box<Object>) box;   //OK. 원시 타입 -> 지네릭 타입. 경고 발생 
```

- 위와같이 원시타입과 지네릭 타입간의 형변환은 가능하다.
    - 다만 경고가 발생한다.

### 지네릭 타입, 지네릭 타입

```java
Box<String> strBox = null;
Box<Object> objBox = null;

strbox = (Box<String>) objBox; //에러
objBox = (Box<Object>) strBox; //에러
```

- 지네릭 타입이 다른 지네릭 타입간에는 형변환이 불가능 하다.

```java
Box<Object> objBox = new Box<String>(); //에러, 상속관계에 있어도 불가능

FruitBox<? extends Fruit> box = new FruitBox<Fruit>(); // OK
FruitBox<? extends Fruit> box = new FruitBox<Apple>(); // OK
FruitBox<? extends Fruit> box = new FruitBox<Grape>(); // OK
```

- 다만 위에서 배운것 처럼 와일드카드를 활용하면 규칙에 따라서 다형성이 적용될 수 있다.

```java
Optional<?> wopt =new Optional<Object>();
Optional<Object> oopt =new Optional<Object>();

Optional<String> wopt =new Optional<Object>(); // OK. 형변환 가능
Optional<String> oopt =new Optional<Object>(); // 에러, 형변환 불가

Optional<Object> -> Optional<?> -> Optional<T> //형변환 가능, 경고 발생
```

- <?> 는 <? extends Object> 를 줄여쓴 것이다.
    - 따라서, 와일드 카드가 포함된 지네릭 타입으로 형변환하면 가능하다.
    - 대신 확인되지 않은 타입으로 형변환이라는 경고가 발생한다??

---

## 지네릭 타입의 제거

1. 지네릭 타입이 치환되고, 클래스 옆의 선언은 제거된다.

```java
class Box<T extends Fruit>{
	void add(T t){
		...
	}
}
```

```java
class Box{
	void add(Fruit t){
		...
	}
}
```

1. 지네릭 타입을 제거한 후에 타입이 일치하지 않으면 형변환 추가

```java
T get(int i){
	return list.get(i);
}
```

```java
Fruit get(int i){
	return (Fruit) list.get(i);
}
```