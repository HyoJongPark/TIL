# 모던 자바 인 액션

<img src="https://user-images.githubusercontent.com/75190035/155264476-7167c8c1-7447-4235-8163-8400017ba9e0.png" width="500" width="500">

### Part 3. 스트림과 람다를 이용한 효과적 프로그래밍

- [8. 컬렉션 API 개선]()

# 8. 컬렉션 API 개선

# 팩토리 메서드

자바 9에서는 작은 컬렉션 객체를 쉽게 만들 수 있는 몇 가지 방법을 제공한다.

## 리스트 팩토리

`List.of()` 팩토리 메서드를 이용해서 간단하게 리스트를 만들 수 있다.

```java
List<String> friends = List.of("Raphael", "Olivia");
friends.add("Park"); //UnsupportedOperationException 발생
```

`List.of()` 메서드로 만든 리스트는 변경할 수 없는 리스트다. 따라서 `add()` 를 사용해서 요소를 추가하려고 하면 예외가 발생한다. 리스트를 바꿔야 하는 상황에서는 직접 리스트를 만들어서 사용해야 한다.

또한 `set()` 메서드로 아이템을 바꾸려고 해도 변경 할 수 없는 리스트가 만들어 졌기 때문에 비슷한 예외가 발생한다.

### 오버로딩 vs 가변 인수

`List.of` 메서드에는 다양한 오버로드 버전이 존재한다.

```java
static <E> List<E> of(E e1, E e2, E e3, E e4)
static <E> List<E> of(E e1, E e2, E e3, E e4, E e5)
```

하지만 가변 인수를 사용해서 다음과 같이 구현할 수도 있을 것이다.

```java
static <E> List<E> of(E... elements)
```

내부적으로 가변 인수 버전은 추가 배열을 할당해서 리스트로 감싼다. 따라서 배열을 할당하고 초기화하며 나중에 가비지 컬렉션을 하는 비용을 지불해야 한다. 이런 비용을 제거하기 위해서 고정된 숫자의 요소를 API로 정의한다.

10개 이상의 요소를 `List.of()` 로 생성할 때는 가변 인수를 이용하는 메서드를 사용한다. `Set.of` , `Map.of` 에서도 동일한 패턴이 등장한다.

> **스트림 vs 팩토리 메서드**
> 
> 
> 스트림 API의 `Collectors.toList()` 를 사용해도 리스트로의 변환이 가능하다.
> 
> 컬랙션 팩토리 메서드는 데티어 처리 형식을 설정하거나 데이터를 변환할 필요가 없다면 사용한다. 팩토리 메서드 구현이 더 단순하고 목적을 달성하는데 충분하기 때문이다.
> 

## 집합 팩토리

`Set.of()` 로 바꿀 수 없는 집합을 만들 수 있다.

```java
Set<String> friends = Set.of("Raphael", "Olivia");
```

## 맵 팩토리

자바 9에서는 두 가지 방법으로 바꿀 수 없는 맵을 초기화 할 수 있다.

```java
Map<String, Integer> ageOfFriends = Map.of("Raphael", 30, "Olivia", 25);
```

`Map.of()` 메서도도 `List.of()` 와 동일하게 열 개 이하의 키와 값을 가진 작은 맵에서는 유용하다. 그 이상의 크기에서는 `Map.Entry<K, V>` 객체를 인수로 받으며 가변인수로 구성된 `Map.ofEntries()` 팩토리 메서드를 이용하는 것이 좋다.

```java
Map<String, Integer> ageOfFriends = Map.ofEntries(entry("Raphael", 30),
																									entry("Olivia", 25));
```

`Map.entry()` 메서드는 `Map.Entry` 객체를 만드는 새로운 팩토리 메서드다.

---

# 리스트와 집합 처리

자바 8에서는 List, Set 인터페이스에 다음과 같은 메서드를 추가했다.

- `removeIf` : 프레디케이트를 만족하는 요소를 제거한다.
- `replaceAll` : 리스트에서 이용할 수 있는 기능으로 `UnaryOperator` 함수를 이용해 요소를 바꾼다.
- `sort` : List 인터페이스에서 제공하는 기능으로 리스트를 정렬한다.

이들 메서드는 호출한 컬렉션 자체를 바꾼다. 새로운 결과를 만드는 스트림 동작과 달리 이들은 기존 컬렉션을 바꾼다.

## removeIf 메서드

- 예외 발생 코드

```java
for (Transaction transaction : transactions) {
	if(Character.isDigit(transaction.getReferenceCode().charAt(0)) {
		transactions.remove(transaction);
	}
}
```

다음 코드는 숫자로 시작하는 참조 코드를 가진 트랜잭션을 삭제하는 코드다. 이 코드는 `ConcurrentModificaitonException` 을 발생시킨다. 

for-each 루프는 Iterator 객체를 사용하므로 위 코드는 다음과 같이 해석된다.

```java
for (Iterator<Transaction> iterator = transactions.iterator(); iterator.hasNext()) {
	Transcation transaction = iterator.next();
	if(Character.isDigit(transaction.getReferenceCode().charAt(0)) {
		iterator.remove();//transactions.remove(transaction); 변경 전 코드
	}
}
```

- 두 개의 개별 객체가 컬렉션을 관리한다
    - Iterator 객체, `next(), hasNext()`를 이용해 소스를 질의한다.
    - Collection 객체 자체, `remove()`를 호출해 요소를 삭제한다.

결과적으로 반복자의 상태는 컬렉션의 상태와 서로 동기화되지 않는다. `Iterator` 객체를 명시적으로 사용하고 그 객체의 `remove()` 메서드를 호출함으로 이 문제를 해결할 수 있다.

또한 이 코드 패턴은 자바 8의 `removeIf` 메서드로 변경할 수 있다. 이로 인해서 코드를 간결하게 만들고, 버그를 예방할 수 있다.

- `removeIf` 로 개선된 코드

```java
transactions.removeIf(transaction ->
	Character.isDigit(transaction.getReferenceCode().charAt(0)));
```

## replaceAll 메서드

`replaceAll` 메서드를 이용해 리스트의 각 요소를 새로운 요소로 바꿀 수 있다.

```java
referenceCodes
	.replaceAll(code -> Character.toUpperCase(code.charAt(0) + code.substring(1));
```

---

# 맵 처리

자바 8에서는 Map 인터페이스에 몇가지 디폴트 메서드를 추가했다.

## forEach 메서드

맵에서 키와 값을 반복하면서 확인하는 작업은 직접 구현하려면 귀찮은 작업이다. 자바 8에서 부터는 Map 인터페이스는 `BiConsumer` 를 인수로 받는 `forEach` 메서드를 지원하므로 코드를 좀 더 간단하게 구현할 수 있다.

```java
ageOfFriends.forEach(
	(friend, age) -> System.out.println(friend + " is " + age + " years old");
```

## 정렬 메서드

다음 두 개의 새로운 유틸리티를 이용하면 맵의 항목을 값 또는 키를 기준으로 정렬할 수 있다.

- `Entry.comparingByValue`
- `Entry.comparingByKey`

```java
Map<String, String> favoriteMovies = Map.ofEntries(
	entry("Cristina", "Matrix"),
	entry("Olivia", "James Bond"));

favoriteMovies.entrySet().stream()
	.sorted(Entry.comparingByKey()) //사람의 이름(키)을 알파벳 순으로 스트림 요소를 처리한다.
	.forEachOrdered(System.out::println);
```

> **HashMap 성능**
> 
> 
> 자바 8에서는 HashMap의 내부 구조를 바꿔 성능을 개선했다. 기존에 맵의 항목은 키로 생성한 해시코드로 접근할 수 있는 버켓에 저장했다. 많은 키가 같은 해시코드를 반환하는 상황이 되면 O(n)의 시간이 걸리는 `LinkedList` 버킷을 반환해야 하므로 성능이 저하된다.
> 
> 최근에는 버킷이 너무 커질 경우 O(log(n))의 시간이 소요되는 정렬된 트리를 이용해 동적으로 치환해 충돌이 일어나는 요소 반환 성능을 개선했다. 하지만 키가 String, Number 클래스 같은 Comparable의 형태여야만 정렬된 트리가 지원된다.
> 

## getOrDefault 메서드

기존에 찾으려는 키가 존재하지 않으면 널이 반환되므로 `NullPointerException` 을 방지하려면 요청 결과가 널인지 확인해야 한다.

`getOrDefault` 메서드를 사용하면 첫 번째 인수로 키를, 두 번째 인수로 기본값을 받으며 맵에 키가 존재하지 않으면 기본값을 반환한다.

```java
Map<String, String> favoriteMovies = Map.ofEntries(
	entry("Cristina", "Matrix"),
	entry("Olivia", "James Bond"));

System.out.println(favoriteMovies.getorDefalut("김여정", "미나리"); //미나리 출력
```

## 계산 패턴

맵에 키가 존재하는지 여부에 따라 어떤 동작을 실행하고 결과를 저장해야 하는 상황이 필요한 때가 있다. 다음 세가지 연산이 이런 상황에서 도움을 준다.

- `computeIfAbsent` : 제공된 키에 해당하는 값이 없으면, 키를 이용해 새 값을 계산하고 맵에 추가
- `computeIfPresent` : 제공된 키가 존재하면, 새 값을 계산하고 맵에 추가
- `compute` : 제공된 키로 새 값을 계산하고 맵에 저장

```java
friendsToMovies.computeIfAbsent("Raphael", name -> new ArrayList<>())
	.add("Star Wars"); //Raphael이 키에 없다면, {Raphael:Star Wars} 추가
```

## 삭제 패턴

자바 8에서는 키가 특정한 값과 연관되었을 때만 항목을 제거하는 오버로드 버전 메서드를 제공한다. 

```java
//기존 remove 활용 코드
if (favoriteMovies.containsKey("Kim") && 
	Objects.equals(favoriteMovies.get("Kim"), "미나리")) {
	favoriteMovies.remove(key);
	return true;
} else {return false;}

//오버로드 버전 remove 활용 코드
favoriteMovies.remove("Kim", "미나리");
```

## 교체 패턴

맵의 항목을 바꾸는데 사용할 수 있는 두 가지의 메서드가 맵에 추가되었다.

- `replaceAll` : `BiFunction` 을 적용한 결과로 각 항목의 값을 교체한다.
- `Replace` : 키가 존재하면 맵의 값을 바꾼다. 키가 특정 값으로 매핑되었을 때만 값을 교체하는 오보로드 버전도 있다.

```java
Map<String, String> favoriteMovies = new HashMap<>();
favoriteMovies.put("Kim", "Minari");
favoriteMovies.replaceAll((friend, movie) -> movie.toUpperCase());
```

## 합침

두 그룹의 맵이 존재할 때 `putAll` 메서드를 사용해서 두 맵을 합칠 수 있다.

```java
Map<String, String> family = Map.ofEntries(
	entry("Teo", "Star Wars"), entry("Cristina", "James Bond"));
Map<String, String> friends = Map.ofEntries(
	entry("Raphael", "Star Wars"));

Map<String, String> everyone = new HashMap<>(family);
everyone.putAll(friends);
```

중복된 키가 없다면 위 코드는 잘 동작한다. 값을 좀 더 유연하게 합쳐야 한다면 `merge` 메서드를 이용할 수 있다.

이 메서드는 중복된 키를 어떻게 합칠지 결정하는 `BiFunction` 을 인수로 받는다.

```java
Map<String, String> everyone = new HashMap<>(family);
friends.forEach((k, v) ->
	everyone.merge(k, v, (movie1, movie2) -> movie1 + " & " + movie2));
```

또한 `merge` 는 널값과 관련된 복잡한 상황도 처리한다. 

지정된 키와 연관된 값이 없거나, 널이면 `merge` 는 키를 널이 아닌 값과 연결한다. 아니면 연결된 값을 주어진 매핑 함수의 결과 값으로 대치하거나 결과가 널이면 항목을 삭제한다.

---

# 개선된 ComcurrentHashMap

`ConcurrentHashMap` 클래스는 동시성 친화적이며 최신 기술을 반영한 `HashMap` 버전이다.

`ConcurrentHashMap` 은 내부 자료구조의 특정 부분만 잠궈 동시 추가, 갱신 작업을 허용한다. 따라서 동기화된 `Hashtable` 버전에 비해 읽기 쓰기 연산 성능이 월등하다.

## 리듀스와 검색

`ConcurrentHashMap` 은 스트림에서 와 비슷한 종류의 세 가지 새로운 연산을 지원한다.

- `forEach` : 각 (키, 값) 쌍에 주어진 액션을 실행
- `reduce` : 모든 (키, 값) 쌍을 제공된 리듀스 함수를 이용해 결과로 합침
- `search` : 널이 아닌 값을 반환할 때까지 (키, 값) 쌍에 함수를 적용

다음처럼 키에 함수 받기, 값, Map.Entry, (키, 값) 인수를 이용한 네 가지 연산 형태를 지원한다.

- 키, 값으로 연산 - `forEach, reduce, search`
- 키로 연산 - `forEachKey, reduceKeys, searchKeys`
- 값으로 연산 - `forEachValue, reduceValues, searchValues`
- Map.Entry 객체로 연산 - `forEachEntry, reduceEntries, searchEntries`

이들 연산은 `ConcurrentHashMap` 의 상태를 잠그지 않고 연산을 수행한다. 따라서 이들 연산에 제공한 함수는 계산이 진행되는 동안 바뀔 수 있는 객체, 값, 순서 등에 의존적이지 않아야 한다.

또한 이들 연산에 병렬성 기준값을 지정해야 한다. 맵의 크기가 주어진 값보다 작으면 순차적으로 연산을 실행한다. 기준값을 1로 지정하면 공통 쓰레드 풀을 이용해 병렬성을 극대화 한다. `Long.MAX_VALUE` 를 기준값으로 설정하면 한 개의 쓰레드로 연산을 실행한다.

### 계수

`ConcurrentHashMap` 클래스는 매핑 개수를 반환하는 `mappingCount` 메서드를 제공한다. 기존의 `size` 메서드 대신 새 코드에서는 int 를 반환하는 `mappingCount` 를 사용하는 것이 좋다. 그래야 매핑의 개수가 int의 범위를 넘어서는 이후의 상황을 대처할 수 있기 때문이다.

### 집합뷰

`ConcurrentHashMap` 클래스는 해당 클래스를 집합 뷰로 반환하는 `keySet` 메서드를 지원한다.

맵을 바꾸면 집합도 바뀌고 반대로 집합을 바꾸면 맵도 영향을 받는다. `newKeySet` 메서드를 이용해 `ConcurrentHashMap` 으로 유지되는 집합을 만들 수도 있다.
