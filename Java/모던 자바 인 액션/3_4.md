# 모던 자바 인 액션

<img src="https://user-images.githubusercontent.com/75190035/155264476-7167c8c1-7447-4235-8163-8400017ba9e0.png" width="500" width="500">

### Part 3. 스트림과 람다를 이용한 효과적 프로그래밍

- [8. 컬렉션 API 개선](https://github.com/HyoJongPark/TIL/blob/main/Java/%EB%AA%A8%EB%8D%98%20%EC%9E%90%EB%B0%94%20%EC%9D%B8%20%EC%95%A1%EC%85%98/3_4.md#8-%EC%BB%AC%EB%A0%89%EC%85%98-api-%EA%B0%9C%EC%84%A0)

### Part 4. 매일 자바와 함께

- [11. null 대신 Optional 클래스]()

# 8. 컬렉션 API 개선

# 팩토리 메서드

자바 9에서는 작은 컬렉션 객체를 쉽게 만들 수 있는 몇 가지 방법을 제공한다.

## 리스트 팩토리

`List.of()` 팩토리 메서드를 이용해서 간단하게 리스트를 만들 수 있다.

```java
List<String> friends = List.of("Raphael", "Olivia");
friends.add("Park"); //UnsupportedOperationException 발생
```

`List.of()` 메서드로 만든 리스트는 변경할 수 없는 리스트다. 따라서 `add()` 를 사용해서 요소를 추가하려고 하면 예외가 발생한다. 리스트를 바꿔야 하는 상황에서는 직접 리스트를 만들어서 사용해야 한다.

또한 `set()` 메서드로 아이템을 바꾸려고 해도 변경 할 수 없는 리스트가 만들어 졌기 때문에 비슷한 예외가 발생한다.

### 오버로딩 vs 가변 인수

`List.of` 메서드에는 다양한 오버로드 버전이 존재한다.

```java
static <E> List<E> of(E e1, E e2, E e3, E e4)
static <E> List<E> of(E e1, E e2, E e3, E e4, E e5)
```

하지만 가변 인수를 사용해서 다음과 같이 구현할 수도 있을 것이다.

```java
static <E> List<E> of(E... elements)
```

내부적으로 가변 인수 버전은 추가 배열을 할당해서 리스트로 감싼다. 따라서 배열을 할당하고 초기화하며 나중에 가비지 컬렉션을 하는 비용을 지불해야 한다. 이런 비용을 제거하기 위해서 고정된 숫자의 요소를 API로 정의한다.

10개 이상의 요소를 `List.of()` 로 생성할 때는 가변 인수를 이용하는 메서드를 사용한다. `Set.of` , `Map.of` 에서도 동일한 패턴이 등장한다.

> **스트림 vs 팩토리 메서드**
> 
> 
> 스트림 API의 `Collectors.toList()` 를 사용해도 리스트로의 변환이 가능하다.
> 
> 컬랙션 팩토리 메서드는 데티어 처리 형식을 설정하거나 데이터를 변환할 필요가 없다면 사용한다. 팩토리 메서드 구현이 더 단순하고 목적을 달성하는데 충분하기 때문이다.
> 

## 집합 팩토리

`Set.of()` 로 바꿀 수 없는 집합을 만들 수 있다.

```java
Set<String> friends = Set.of("Raphael", "Olivia");
```

## 맵 팩토리

자바 9에서는 두 가지 방법으로 바꿀 수 없는 맵을 초기화 할 수 있다.

```java
Map<String, Integer> ageOfFriends = Map.of("Raphael", 30, "Olivia", 25);
```

`Map.of()` 메서도도 `List.of()` 와 동일하게 열 개 이하의 키와 값을 가진 작은 맵에서는 유용하다. 그 이상의 크기에서는 `Map.Entry<K, V>` 객체를 인수로 받으며 가변인수로 구성된 `Map.ofEntries()` 팩토리 메서드를 이용하는 것이 좋다.

```java
Map<String, Integer> ageOfFriends = Map.ofEntries(entry("Raphael", 30),
																									entry("Olivia", 25));
```

`Map.entry()` 메서드는 `Map.Entry` 객체를 만드는 새로운 팩토리 메서드다.

---

# 리스트와 집합 처리

자바 8에서는 List, Set 인터페이스에 다음과 같은 메서드를 추가했다.

- `removeIf` : 프레디케이트를 만족하는 요소를 제거한다.
- `replaceAll` : 리스트에서 이용할 수 있는 기능으로 `UnaryOperator` 함수를 이용해 요소를 바꾼다.
- `sort` : List 인터페이스에서 제공하는 기능으로 리스트를 정렬한다.

이들 메서드는 호출한 컬렉션 자체를 바꾼다. 새로운 결과를 만드는 스트림 동작과 달리 이들은 기존 컬렉션을 바꾼다.

## removeIf 메서드

- 예외 발생 코드

```java
for (Transaction transaction : transactions) {
	if(Character.isDigit(transaction.getReferenceCode().charAt(0)) {
		transactions.remove(transaction);
	}
}
```

다음 코드는 숫자로 시작하는 참조 코드를 가진 트랜잭션을 삭제하는 코드다. 이 코드는 `ConcurrentModificaitonException` 을 발생시킨다. 

for-each 루프는 Iterator 객체를 사용하므로 위 코드는 다음과 같이 해석된다.

```java
for (Iterator<Transaction> iterator = transactions.iterator(); iterator.hasNext()) {
	Transcation transaction = iterator.next();
	if(Character.isDigit(transaction.getReferenceCode().charAt(0)) {
		iterator.remove();//transactions.remove(transaction); 변경 전 코드
	}
}
```

- 두 개의 개별 객체가 컬렉션을 관리한다
    - Iterator 객체, `next(), hasNext()`를 이용해 소스를 질의한다.
    - Collection 객체 자체, `remove()`를 호출해 요소를 삭제한다.

결과적으로 반복자의 상태는 컬렉션의 상태와 서로 동기화되지 않는다. `Iterator` 객체를 명시적으로 사용하고 그 객체의 `remove()` 메서드를 호출함으로 이 문제를 해결할 수 있다.

또한 이 코드 패턴은 자바 8의 `removeIf` 메서드로 변경할 수 있다. 이로 인해서 코드를 간결하게 만들고, 버그를 예방할 수 있다.

- `removeIf` 로 개선된 코드

```java
transactions.removeIf(transaction ->
	Character.isDigit(transaction.getReferenceCode().charAt(0)));
```

## replaceAll 메서드

`replaceAll` 메서드를 이용해 리스트의 각 요소를 새로운 요소로 바꿀 수 있다.

```java
referenceCodes
	.replaceAll(code -> Character.toUpperCase(code.charAt(0) + code.substring(1));
```

---

# 맵 처리

자바 8에서는 Map 인터페이스에 몇가지 디폴트 메서드를 추가했다.

## forEach 메서드

맵에서 키와 값을 반복하면서 확인하는 작업은 직접 구현하려면 귀찮은 작업이다. 자바 8에서 부터는 Map 인터페이스는 `BiConsumer` 를 인수로 받는 `forEach` 메서드를 지원하므로 코드를 좀 더 간단하게 구현할 수 있다.

```java
ageOfFriends.forEach(
	(friend, age) -> System.out.println(friend + " is " + age + " years old");
```

## 정렬 메서드

다음 두 개의 새로운 유틸리티를 이용하면 맵의 항목을 값 또는 키를 기준으로 정렬할 수 있다.

- `Entry.comparingByValue`
- `Entry.comparingByKey`

```java
Map<String, String> favoriteMovies = Map.ofEntries(
	entry("Cristina", "Matrix"),
	entry("Olivia", "James Bond"));

favoriteMovies.entrySet().stream()
	.sorted(Entry.comparingByKey()) //사람의 이름(키)을 알파벳 순으로 스트림 요소를 처리한다.
	.forEachOrdered(System.out::println);
```

> **HashMap 성능**
> 
> 
> 자바 8에서는 HashMap의 내부 구조를 바꿔 성능을 개선했다. 기존에 맵의 항목은 키로 생성한 해시코드로 접근할 수 있는 버켓에 저장했다. 많은 키가 같은 해시코드를 반환하는 상황이 되면 O(n)의 시간이 걸리는 `LinkedList` 버킷을 반환해야 하므로 성능이 저하된다.
> 
> 최근에는 버킷이 너무 커질 경우 O(log(n))의 시간이 소요되는 정렬된 트리를 이용해 동적으로 치환해 충돌이 일어나는 요소 반환 성능을 개선했다. 하지만 키가 String, Number 클래스 같은 Comparable의 형태여야만 정렬된 트리가 지원된다.
> 

## getOrDefault 메서드

기존에 찾으려는 키가 존재하지 않으면 널이 반환되므로 `NullPointerException` 을 방지하려면 요청 결과가 널인지 확인해야 한다.

`getOrDefault` 메서드를 사용하면 첫 번째 인수로 키를, 두 번째 인수로 기본값을 받으며 맵에 키가 존재하지 않으면 기본값을 반환한다.

```java
Map<String, String> favoriteMovies = Map.ofEntries(
	entry("Cristina", "Matrix"),
	entry("Olivia", "James Bond"));

System.out.println(favoriteMovies.getorDefalut("김여정", "미나리"); //미나리 출력
```

## 계산 패턴

맵에 키가 존재하는지 여부에 따라 어떤 동작을 실행하고 결과를 저장해야 하는 상황이 필요한 때가 있다. 다음 세가지 연산이 이런 상황에서 도움을 준다.

- `computeIfAbsent` : 제공된 키에 해당하는 값이 없으면, 키를 이용해 새 값을 계산하고 맵에 추가
- `computeIfPresent` : 제공된 키가 존재하면, 새 값을 계산하고 맵에 추가
- `compute` : 제공된 키로 새 값을 계산하고 맵에 저장

```java
friendsToMovies.computeIfAbsent("Raphael", name -> new ArrayList<>())
	.add("Star Wars"); //Raphael이 키에 없다면, {Raphael:Star Wars} 추가
```

## 삭제 패턴

자바 8에서는 키가 특정한 값과 연관되었을 때만 항목을 제거하는 오버로드 버전 메서드를 제공한다. 

```java
//기존 remove 활용 코드
if (favoriteMovies.containsKey("Kim") && 
	Objects.equals(favoriteMovies.get("Kim"), "미나리")) {
	favoriteMovies.remove(key);
	return true;
} else {return false;}

//오버로드 버전 remove 활용 코드
favoriteMovies.remove("Kim", "미나리");
```

## 교체 패턴

맵의 항목을 바꾸는데 사용할 수 있는 두 가지의 메서드가 맵에 추가되었다.

- `replaceAll` : `BiFunction` 을 적용한 결과로 각 항목의 값을 교체한다.
- `Replace` : 키가 존재하면 맵의 값을 바꾼다. 키가 특정 값으로 매핑되었을 때만 값을 교체하는 오보로드 버전도 있다.

```java
Map<String, String> favoriteMovies = new HashMap<>();
favoriteMovies.put("Kim", "Minari");
favoriteMovies.replaceAll((friend, movie) -> movie.toUpperCase());
```

## 합침

두 그룹의 맵이 존재할 때 `putAll` 메서드를 사용해서 두 맵을 합칠 수 있다.

```java
Map<String, String> family = Map.ofEntries(
	entry("Teo", "Star Wars"), entry("Cristina", "James Bond"));
Map<String, String> friends = Map.ofEntries(
	entry("Raphael", "Star Wars"));

Map<String, String> everyone = new HashMap<>(family);
everyone.putAll(friends);
```

중복된 키가 없다면 위 코드는 잘 동작한다. 값을 좀 더 유연하게 합쳐야 한다면 `merge` 메서드를 이용할 수 있다.

이 메서드는 중복된 키를 어떻게 합칠지 결정하는 `BiFunction` 을 인수로 받는다.

```java
Map<String, String> everyone = new HashMap<>(family);
friends.forEach((k, v) ->
	everyone.merge(k, v, (movie1, movie2) -> movie1 + " & " + movie2));
```

또한 `merge` 는 널값과 관련된 복잡한 상황도 처리한다. 

지정된 키와 연관된 값이 없거나, 널이면 `merge` 는 키를 널이 아닌 값과 연결한다. 아니면 연결된 값을 주어진 매핑 함수의 결과 값으로 대치하거나 결과가 널이면 항목을 삭제한다.

---

# 개선된 ComcurrentHashMap

`ConcurrentHashMap` 클래스는 동시성 친화적이며 최신 기술을 반영한 `HashMap` 버전이다.

`ConcurrentHashMap` 은 내부 자료구조의 특정 부분만 잠궈 동시 추가, 갱신 작업을 허용한다. 따라서 동기화된 `Hashtable` 버전에 비해 읽기 쓰기 연산 성능이 월등하다.

## 리듀스와 검색

`ConcurrentHashMap` 은 스트림에서 와 비슷한 종류의 세 가지 새로운 연산을 지원한다.

- `forEach` : 각 (키, 값) 쌍에 주어진 액션을 실행
- `reduce` : 모든 (키, 값) 쌍을 제공된 리듀스 함수를 이용해 결과로 합침
- `search` : 널이 아닌 값을 반환할 때까지 (키, 값) 쌍에 함수를 적용

다음처럼 키에 함수 받기, 값, Map.Entry, (키, 값) 인수를 이용한 네 가지 연산 형태를 지원한다.

- 키, 값으로 연산 - `forEach, reduce, search`
- 키로 연산 - `forEachKey, reduceKeys, searchKeys`
- 값으로 연산 - `forEachValue, reduceValues, searchValues`
- Map.Entry 객체로 연산 - `forEachEntry, reduceEntries, searchEntries`

이들 연산은 `ConcurrentHashMap` 의 상태를 잠그지 않고 연산을 수행한다. 따라서 이들 연산에 제공한 함수는 계산이 진행되는 동안 바뀔 수 있는 객체, 값, 순서 등에 의존적이지 않아야 한다.

또한 이들 연산에 병렬성 기준값을 지정해야 한다. 맵의 크기가 주어진 값보다 작으면 순차적으로 연산을 실행한다. 기준값을 1로 지정하면 공통 쓰레드 풀을 이용해 병렬성을 극대화 한다. `Long.MAX_VALUE` 를 기준값으로 설정하면 한 개의 쓰레드로 연산을 실행한다.

### 계수

`ConcurrentHashMap` 클래스는 매핑 개수를 반환하는 `mappingCount` 메서드를 제공한다. 기존의 `size` 메서드 대신 새 코드에서는 int 를 반환하는 `mappingCount` 를 사용하는 것이 좋다. 그래야 매핑의 개수가 int의 범위를 넘어서는 이후의 상황을 대처할 수 있기 때문이다.

### 집합뷰

`ConcurrentHashMap` 클래스는 해당 클래스를 집합 뷰로 반환하는 `keySet` 메서드를 지원한다.

맵을 바꾸면 집합도 바뀌고 반대로 집합을 바꾸면 맵도 영향을 받는다. `newKeySet` 메서드를 이용해 `ConcurrentHashMap` 으로 유지되는 집합을 만들 수도 있다.

---
# null 대신 Optional 클래스

- 예제 코드

```java
public class Person {
	private Car car;
	public Car getCar() {return car;}
}
public class Car {
	private Insurance insurance;
	public Insurance getInsurance() {return insurance;}
}
public class Insurance {
	private String name;
	public String getName() {return name;}
}
```

## 값이 없는 상황에서 처리

```java
public String getCarInsuranceName(Person person) {
	return person.getCar().getInsurance().getName();
}
```

만약 차를 소유하지 않은 상태에서 해당 메서드를 호출하면, 결과적으로 `null.getInsurance().getName()` 과 같은 형태와 같을 것이다. 이때 `getInsurance()` 는 null 참조의 보험 정보를 반환하려 할 것임으로 `NullPointerException` 이 발생하면서 프로그램이 종료될 것이다.

### 보수적인 자세로 NullPointerException 줄이기

예기치 않은 `NullPointerException` 을 줄이기 위해서 필요한 곳에 null 확인 코드를 추가해서 null 예외 문제를 해결할 수 있다.(더 보수적인 경우 필요하지 않은 곳에도 null 확인 코드를 추가할 것이다.)

```java
public String getCarInsuranceName(Person person) {
	if (person != null) {
		Car car = person.getCar();
		if (car != null) {
			Insurance insurance = car.getInsurance();
			if (insurance != null) {
				return insurance.getName();
			}
		}
	}
	return "Unknown";
}
```

위 코드에서는 변수를 참조할 때마다 null을 확인하며 null이 있는 경우 Unknown을 반환한다.

이런 코드에서는 모든 변수가 null인지 의심하므로 변수에 접근할 때마다 중첩된 if가 추가되면서 코드 들여쓰기 수준이 증가한다. 따라서 이와 같은 반복 패턴 코드를 **깊은 의심**이라 부른다.

즉, 변수가 null인지 의심해 중첩 if블록을 추가하면 코드 들여쓰기 수준이 증가하고, 이를 반복하면 코드의 구조가 엉망이 되고 가독성도 떨어지는 코드가 된다.

### null 때문에 발생하는 문제

자바에서 null 참조를 사용하면서 발생할 수 있는 이론적, 실용적 문제

- **에러의 근원이다.**
    - `NullPointerException` 은 자바에서 가장 흔히 발생하는 에러다.
- **코드를 어지럽힌다.**
    - 중첩된 null 확인 코드를 추가해야 하므로 null 때문에 코드 가독성이 떨어진다.
- **아무 의미가 없다.**
    - null은 아무 의미도 표현하지 않는다. 특히 정적 형식 언어에서 값이 없음으르 표현하는 방법으로는 적절하지 않다.
- **자바 철학에 위배된다.**
    - 자바는 개발자로부터 모든 포인터를 숨겼다. 하지만 null 포인터는 예외다.
- **형식 시스템에 구멍을 만든다.**
    - null은 무형식이며 정보를 포함하고 있지 않으므로 모든 참조 형식에 할당할 수 있다. 이런 식으로 할당되기 시작하며 다른 부분으로 퍼지면, 애초에 null이 어떤 의미로 사용되었는지 알 수 없다.

---

## Optional 클래스

자바 8은 `java.util.Optional<T>` 라는 새로운 클래스를 제공한다. `Optional` 은 선택형값을 캡슐화하는 클래스다.

값이 있다면 `Optional` 클래스는 값을 감싼다. 반면 값이 없으면 `Optional.empty` 메서드로 `Optional` 을 반환한다. `Optional.empty` 는 `Optional` 의 특별한 싱글턴 인스턴스를 반환하는 정적 팩토리 메서드다.

null을 참조하려 하면 `NullPointerException` 이 발생하지만, `Optional.empty` 는 `Optional` 객체이므로 이를 다양한 방식으로 활용할 수 있다.

```java
public class Person {
	private Optional<Car> car;
	public Optional<Car> getCar() {return car;}
}
public class Car {
	private Optional<Insurance> insurance;
	public Optional<Insurance> getInsurance() {return insurance;}
}
public class Insurance {
	private String name;
	public String getName() {return name;}
}
```

- `Optional` 클래스를 사용하면서 모델의 의미가 더 명확해졌다.
    - `Car` , `Insurance` 필드는 `Optional` 로 감싸줬는데, 이는 사람이 자동차를 소유할 수도 아닐 수도 있으며, 자동차는 보험에 가입 되었을 수도 아닐 수도 있음을 명확히 설명한다.
    - 보험회사 이름은 String으로 선언되었는데, 보험회사는 반드시 이름을 가져야 함을 보여준다.
- `Optional` 을 이용하면 값이 없는 상황이 우리 데이터에 문제가 있는 것인지 아니면 알고리즘의 버그인지 명확하게 구분할 수 있다.
    - `Optional` 클래스를 사용하지 않은 곳에서 발생한 `NullPointerException` 은 예외 처리 코드를 추가하는 것이 아닌 필드에 이름이 없는 이유를 찾아 해결해야 한다.

---

## Optional 적용 패턴

### Optional 객체 만들기

- **빈 Optional**

```java
Optional<Car> optCar = Optional.empty();
```

- **null이 아닌 값으로 Optional**

정적 팩토리 메서드 `Optional.of` 로 nul이 아닌 값을 포함하는 `Optional` 을 만들 수 있다. 

null값이 입력된다면 즉시 `NullPointerException` 이 발생한다. 만약 `Optional` 을 사용하지 않았다면, 입력된 값의 프로퍼티에 접근하려 할 때 예외가 발생했을 것이다.

```java
Optional<Car> optCar = Optional.of(car);
```

- **null값으로 Optional**

`Optional.ofNullable` 로 null을 저장할 수 있는 `Optional` 을 만들 수 있다.

입력된 값이 null이면 빈 Optional 객체가 반환된다.

```java
Optional<Car> optCar = Optional.ofNullable(car);
```

### 맵으로 Optional의 값 추출, 변환

`**map` 메서드로 값 추출, 변환**

Optional은 `map` 메서드를 지원한다.

```java
Optional<Insurance> optInsurance = Optional.ofNullable(insurance);
Optional<String> name = optInsurance.map(Insurance::getName);
```

- `Optional.map` 은 스트림의 map과 유사하다.
    - Optional 객체에 값이 존재하면, `map` 의 인수로 전달된 함수가 값을 바꾼다.
    - Optional이 비어있으면 아무 일도 일어나지 않는다.

`**flatMap` 으로 Optional 객체 연결**

```java
public String getCarInsuranceName(Optional<Person> person) {
	return person.flatMap(Person::getCar)
							 .flatMap(Car::getInsurance)
							 .map(Insurance::getName)
							 .orElse("Unknown");
```

- `getCar` , `getInsurance` 객체는 각각 Optional로 감싸진 객체를 반환한다. 따라서 만약 위 코드에서 `map` 을 사용했다면 중첩된 Optional 객체 구조가 반환되었을 것이다.
- `Optional.flatMap` 또한 스트림의 `flatMap` 과 유사하다.
    - `Optional.flatMap` 은 함수를 일차원 Optional 구조로 평준화 해준다.
    - 평준화란 두 `Optional` 을 합치는 기능을 수행하면서 둘 중 하나라도 null이면 빈 `Optional` 을 생성하는 연산이다.

### Optional 스트림 조작

자바9에서는 `Optional` 을 포함하는 스트림을 쉽게 처리하도록 `Optional` 에 `stream()` 메서드를 추가했다.

```java
public Set<String> getCarInsuranceNames(List<Person> persons) {
	return persons.stream()
								.map(Person::getCar) //Stream<Optional<Car>>
								.map(optCar -> optCar.flatMap(Car::Insurance)) //Stream<Optional<Insurance>>
								.map(optIns -> optIns.map(Insurance::getName)) //Stream<Optional<String>>
								.flatMap(Optional::stream) //Stream<String>
								.collect(toSet()); //Set<String>
```

### 디폴트 액션과 Optional 언랩

빈 `Optional` 인 상황에서 기본 값을 반환하도록 하기 위해서 `orElse()` 를 사용할 수도 있고 다양한 방법을 사용해서 `Optional`

- `get()` 은 값을 읽는 가장 간단하면서 동시에 가장 안전하지 않은 메서드다.
    - `get()` 은 래핑된 값이 있으면 해당 값을 반환하고 없으면 `NoSuchElementException` 을 발생시킨다. 따라서 값이 반드시 있다고 가정할 수 없다면 `get()` 메서드를 사용하지 않는 것이 바람직하다.
- `orElse()` 메서드를 이용하면 `Optional` 이 값을 포함하지 않을 때 기본값을 제공할 수 있다.
- `orElseGet(Supplier<? extends T> other)` 는 `orElse` 메서드에 대응하는 게으른 버전의 메서드다. `Optional` 에 값이 없을 때만 `Supplier` 가 실행되기 때문이다.
    - 디폴트 메서드를 만드는데 시가닝 걸리거나 `Optional` 이 비어있을 때만 기본값을 생성하고싶다면, 이 메서드를 사용해야 한다.
- `orElseThrow(Supplier<? extends X> exceptionSupplier)` 는 `Optional` 이 비어있을 때 예외를 발생시킨다는 점에서 `get()` 과 비슷하지만, 예외의 종류를 선택할 수 있다.
- `ifPresent(Consumer<? super T> consumer)` 를 이용하면 값이 존재할 때 인수로 넘겨준 동작을 실행할 수 있다. 값이 없으면 아무 일도 일어나지 않는다.
- `ifPresentOrElse(Consumer<? super T> action, Runnable emptyAction)` 는 `Optional` 이 비어있을 때 실행할 수 있는 `Runnable` 을 인수로 받는다는 점에서 `ifPresent` 와 다르다.
